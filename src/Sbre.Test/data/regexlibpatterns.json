[
    {
        "description": "Matches exactly 1 numeric digit (0-9).",
        "matches": [
            "1",
            "2",
            "3"
        ],
        "nonMatches": [
            "a",
            "324",
            "num"
        ],
        "pattern": "^\\d$",
        "title": "Test"
    },
    {
        "description": "This regular expression will match a hyphen-separated Social Security Number (SSN) in the format NNN-NN-NNNN.",
        "matches": [
            "333-22-4444",
            "123-45-6789"
        ],
        "nonMatches": [
            "123456789",
            "SSN"
        ],
        "pattern": "^\\d{3}-\\d{2}-\\d{4}$",
        "title": "Test"
    },
    {
        "description": "Matches any single upper- or lower-case letter.",
        "matches": [
            "a",
            "B",
            "c"
        ],
        "nonMatches": [
            "0",
            "&",
            "AbC"
        ],
        "pattern": "^[a-zA-Z]$",
        "title": "Test"
    },
    {
        "description": "Positive integer value.",
        "matches": [
            "123",
            "10",
            "54"
        ],
        "nonMatches": [
            "-54",
            "54.234",
            "abc"
        ],
        "pattern": "^\\d+$",
        "title": "Test"
    },
    {
        "description": "Matches any signed integer.",
        "matches": [
            "-34",
            "34",
            "+5"
        ],
        "nonMatches": [
            "abc",
            "3.1415",
            "-5.3"
        ],
        "pattern": "^(\\+|-)?\\d+$",
        "title": "Test"
    },
    {
        "description": "Simple email expression. Doesn\u0027t allow numbers in the domain name and doesn\u0027t allow for top level domains that are less than 2 or more than 3 letters (which is fine until they allow more). Doesn\u0027t handle multiple \".\" in the domain (joe@abc.co.uk).",
        "matches": [
            "joe@aol.com",
            "ssmith@aspalliance.com",
            "a@b.cc"
        ],
        "nonMatches": [
            "joe@123aspx.com",
            "joe@web.info",
            "joe@company.co.uk"
        ],
        "pattern": "^\\w+@[a-zA-Z_]+?\\.[a-zA-Z]{2,3}$",
        "title": "Test"
    },
    {
        "description": "This regular expressions matches dates of the form XX/XX/YYYY where XX can be 1 or 2 digits long and YYYY is always 4 digits long.",
        "matches": [
            "4/1/2001",
            "12/12/2001",
            "55/5/3434"
        ],
        "nonMatches": [
            "1/1/01",
            "12 Jan 01",
            "1-1-2001"
        ],
        "pattern": "^\\d{1,2}\\/\\d{1,2}\\/\\d{4}$",
        "title": "Test"
    },
    {
        "description": "This matches a single numeric digit between 1 and 5, and is the same as saying ^[12345]$.",
        "matches": [
            "1",
            "3",
            "4"
        ],
        "nonMatches": [
            "6",
            "23",
            "a"
        ],
        "pattern": "^[1-5]$",
        "title": "Test"
    },
    {
        "description": "This expression matches a hyphen separated US phone number, of the form ANN-NNN-NNNN, where A is between 2 and 9 and N is between 0 and 9.",
        "matches": [
            "800-555-5555",
            "333-444-5555",
            "212-666-1234"
        ],
        "nonMatches": [
            "000-000-0000",
            "123-456-7890",
            "2126661234"
        ],
        "pattern": "^[2-9]\\d{2}-\\d{3}-\\d{4}$",
        "title": "Test"
    },
    {
        "description": "Major credit card validator. Only checks that the format is 16 digits (optionally separated by hyphens), not the value of any of the digits.",
        "matches": [
            "1234-1234-1234-1234",
            "1234123412341234"
        ],
        "nonMatches": [
            "1234123412345"
        ],
        "pattern": "\\d{4}-?\\d{4}-?\\d{4}-?\\d{4}",
        "title": "Test"
    },
    {
        "description": "Tests for valid HTML hexadecimal color codes. The # symbol is optional. And it will except either the 3 digit form for the 216 Web safe colors, or the full 6 digit form. I am use it on my site to allow users to customize the site\u0027s colors.",
        "matches": [
            "#00ccff",
            "#039",
            "ffffcc"
        ],
        "nonMatches": [
            "blue",
            "0x000000",
            "#ff000"
        ],
        "pattern": "^#?([a-f]|[A-F]|[0-9]){3}(([a-f]|[A-F]|[0-9]){3})?$",
        "title": "Test"
    },
    {
        "description": "If you need to extract or remove any /* */ sytle comments from any Java, JavaScript, C, C++, CSS, etc code you have this regular expression can help.",
        "matches": [
            "/* my comment */",
            "/* my multiline comment */",
            "/* my nested comment */"
        ],
        "nonMatches": [
            "*/ anything here /*",
            "anything between 2 seperate comments",
            "\\* *\\"
        ],
        "pattern": "/\\*[\\d\\D]*?\\*/",
        "title": "Test"
    },
    
    {
        "description": "This RegEx requires a US phone number WITH area code. It is written to all users to enter whatever delimiters they want or no delimiters at all (i.e. 111-222-3333, or 111.222.3333, or (111) 222-3333, or 1112223333, etc...).",
        "matches": [
            "(111) 222-3333",
            "1112223333",
            "111-222-3333"
        ],
        "nonMatches": [
            "11122223333",
            "11112223333",
            "11122233333"
        ],
        "pattern": "^\\D?(\\d{3})\\D?\\D?(\\d{3})\\D?(\\d{4})$",
        "title": "Test"
    },
    {
        "description": "Matches any string between 4 and 8 characters in length. Limits the length of a string. Useful to add to password regular expressions.",
        "matches": [
            "asdf",
            "1234",
            "asdf1234"
        ],
        "nonMatches": [
            "asd",
            "123",
            "asdfe12345"
        ],
        "pattern": "^.{4,8}$",
        "title": "Test"
    },
    {
        "description": "Matches any integer number or numeric string, including positive and negative value characters (+ or -). Also matches empty strings.",
        "matches": [
            "123",
            "-123",
            "+123"
        ],
        "nonMatches": [
            "abc",
            "3.14159",
            "-3.14159"
        ],
        "pattern": "^[-+]?\\d*$",
        "title": "Test"
    },
    {
        "description": "Matches any unsigned floating point number/numeric string. Also matches empty strings.",
        "matches": [
            "123",
            "3.14159",
            ".234"
        ],
        "nonMatches": [
            "abc",
            "-3.14159",
            "3.4.2"
        ],
        "pattern": "^\\d*\\.?\\d*$",
        "title": "Test"
    },
    {
        "description": "Matches US phone number format. 1 in the beginning is optional, area code is required, spaces or dashes can be used as optional divider between number groups. Also alphanumeric format is allowed after area code.",
        "matches": [
            "1-(123)-123-1234",
            "123 123 1234",
            "1-800-ALPHNUM"
        ],
        "nonMatches": [
            "1.123.123.1234",
            "(123)-1234-123",
            "123-1234"
        ],
        "pattern": "^([0-9]( |-)?)?(\\(?[0-9]{3}\\)?|[0-9]{3})( |-)?([0-9]{3}( |-)?[0-9]{4}|[a-zA-Z0-9]{7})$",
        "title": "Test"
    },
    {
        "description": "This expression checks the validity of a date (US, but it is easily editable for other format\u0027s). Year\u0027s 1990-9999, Month\u0027s 1 or 01 to 12, Day\u0027s 1 or 01 to 31. Still needs to have individual months added (i.e., Feb\u0027s 28 days), and some how to check for leap year...the months issue should not be to hard, but the leap year seems like a real chore. Please let me know if you have any suggestions for leap year.",
        "matches": [
            "01/01/1990",
            "12/12/9999",
            "3/28/2001"
        ],
        "nonMatches": [
            "3-8-01",
            "13/32/1001",
            "03/32/1989"
        ],
        "pattern": "^[0,1]?\\d{1}\\/(([0-2]?\\d{1})|([3][0,1]{1}))\\/(([1]{1}[9]{1}[9]{1}\\d{1})|([2-9]{1}\\d{3}))$",
        "title": "Test"
    },
    {
        "description": "US Phone number that accept a dot, a space, a dash, a forward slash, between the numbers. Will Accept a 1 or 0 in front. Area Code not necessary",
        "matches": [
            "1.2123644567",
            "0-234.567/8912",
            "1-(212)-123 4567"
        ],
        "nonMatches": [
            "0-212364345",
            "1212-364,4321",
            "0212\\345/6789"
        ],
        "pattern": "((\\(\\d{3}\\)?)|(\\d{3}))([\\s-./]?)(\\d{3})([\\s-./]?)(\\d{4})",
        "title": "Test"
    },
    {
        "description": "Australian phone numbers: Matches all known formats incl normal 10-digit landline numbers (valid area code mandatory) 13, 1300, 1800, 1900, 1902 plus mobile 10 and 11-digit formats. Use a Replace function first to remove non-numerics which are probably separators (E.g. newNum = number.replace(/[\\D]/g, &quot;&quot;). Please contact me if you find any valid Aussie numbers being rejected.",
        "matches": [
            "0732105432",
            "1300333444",
            "131313"
        ],
        "nonMatches": [
            "32105432",
            "13000456"
        ],
        "pattern": "(^1300\\d{6}$)|(^1800|1900|1902\\d{6}$)|(^0[2|3|7|8]{1}[0-9]{8}$)|(^13\\d{4}$)|(^04\\d{2,3}\\d{6}$)",
        "title": "Test"
    },
    {
        "description": "This provides an expression to calidate the four major credit cards. It can be easily broken up to use for a specific type of card. It does not validate the number being a potential real number, only in the correct format.",
        "matches": [
            "4111-1234-1234-1234",
            "6011123412341234",
            "3711-123456-12345"
        ],
        "nonMatches": [
            "1234567890123456",
            "4111-123-1234-1234",
            "412-1234-1234-1234"
        ],
        "pattern": "(^(4|5)\\d{3}-?\\d{4}-?\\d{4}-?\\d{4}|(4|5)\\d{15})|(^(6011)-?\\d{4}-?\\d{4}-?\\d{4}|(6011)-?\\d{12})|(^((3\\d{3}))-\\d{6}-\\d{5}|^((3\\d{14})))",
        "title": "Test"
    },
    {
        "description": "This matches simple dates against 1 or 2 digits for the month, 1 or 2 digit for the day, and either 2 or 4 digits for the year",
        "matches": [
            "4/5/91",
            "04/5/1991",
            "4/05/89"
        ],
        "nonMatches": [
            "4/5/1"
        ],
        "pattern": "((\\d{2})|(\\d))\\/((\\d{2})|(\\d))\\/((\\d{4})|(\\d{2}))",
        "title": "Test"
    },
    {
        "description": "A regular expression to match phone numbers, allowing for an international dialing code at the start and hyphenation and spaces that are sometimes entered.",
        "matches": [
            "(+44)(0)20-12341234",
            "02012341234",
            "+44 (0) 1234-1234"
        ],
        "nonMatches": [
            "(44+)020-12341234",
            "12341234(+020)"
        ],
        "pattern": "^(\\(?\\+?[0-9]*\\)?)?[0-9_\\- \\(\\)]*$",
        "title": "Test"
    },
    {
        "description": "Matches standard 5 digit US Zip Codes, or the US ZIP + 4 Standard.",
        "matches": [
            "48222",
            "48222-1746"
        ],
        "nonMatches": [
            "4632",
            "Blake",
            "37333-32"
        ],
        "pattern": "^\\d{5}(-\\d{4})?$",
        "title": "Test"
    },
    {
        "description": "Regular expression to evaluate dutch-style phone numbers. Possible example prefixes: +31, +31(0), (+31)(0), 0, 0031 followed by 9 numbers (which can contain a space or -).",
        "matches": [
            "+31235256677",
            "+31(0)235256677",
            "023-5256677"
        ],
        "nonMatches": [
            "+3123525667788999",
            "3123525667788",
            "232-2566778"
        ],
        "pattern": "(^\\+[0-9]{2}|^\\+[0-9]{2}\\(0\\)|^\\(\\+[0-9]{2}\\)\\(0\\)|^00[0-9]{2}|^0)([0-9]{9}$|[0-9\\-\\s]{10}$)",
        "title": "Test"
    },
    {
        "description": "This is a pattern to search and verify that a decimal number ends with a 25, 50, 75, 0 or 00. It does match for a nothing after decimal also but I guess thats ok !!",
        "matches": [
            "0.25",
            ".75",
            "123.50"
        ],
        "nonMatches": [
            ".77",
            "1.435"
        ],
        "pattern": "^\\d*\\.?((25)|(50)|(5)|(75)|(0)|(00))?$",
        "title": "Test"
    },
    {
        "description": "This is a modification of the zip code regular expression submitted by Steven Smith (ssmith@aspalliance.com) It no longer matches 78754-12aA",
        "matches": [
            "78754",
            "78754-1234",
            "G3H 6A3"
        ],
        "nonMatches": [
            "78754-12aA",
            "7875A",
            "g3h6a3"
        ],
        "pattern": "^(\\d{5}-\\d{4}|\\d{5})$|^([a-zA-Z]\\d[a-zA-Z] \\d[a-zA-Z]\\d)$",
        "title": "Test"
    },
    {
        "description": "This regular expression can be used to validate UK postcodes. Especially useful if want to provide a client side validation on a web site.",
        "matches": [
            "SW112LE",
            "SW11 2LE",
            "CR05LE"
        ],
        "nonMatches": [
            "12CR0LE",
            "12CR 0LE",
            "SWLE05"
        ],
        "pattern": "^[A-Za-z]{1,2}[0-9A-Za-z]{1,2}[ ]?[0-9]{0,1}[A-Za-z]{2}$",
        "title": "Test"
    },
    {
        "description": "*CORRECTED: Again thanks for all the comments below. If you want to include internal domain as well change the partial code (\\.[\\w-_]+)+ to (\\.[\\w-_]+)? See the comments below* This is the regular expression I use to add links in my email program. It also ignores those suppose-to-be commas/periods/colons at the end of the URL, like this sentence \"check out http://www.yahoo.com/.\" (the period will be ignored) Note that it requires some modification to match ones that dont start with http.",
        "matches": [
            "http://regxlib.com/Default.aspx",
            "http://electronics.cnet.com/electronics/0-6342366-8-8994967-1.html"
        ],
        "nonMatches": [
            "www.yahoo.com"
        ],
        "pattern": "(http|ftp|https):\\/\\/[\\w\\-_]+(\\.[\\w\\-_]+)+([\\w\\-\\.,@?^=%&:/~\\+#]*[\\w\\-\\@?^=%&/~\\+#])?",
        "title": "Test"
    },
    {
        "description": "This just a minor mod to Steven Smith\u0027s credit card re to accept spaces as separators, as well as return the four parts of the card. [Updated Oct-18-2002 to work with Diners Club/Carte Blanche (prefix must be 36, 38, or 300-305)]",
        "matches": [
            "6011567812345678",
            "6011 5678 1234 5678",
            "6011-5678-1234-5678"
        ],
        "nonMatches": [
            "1234567890123456"
        ],
        "pattern": "^((?:4\\d{3})|(?:5[1-5]\\d{2})|(?:6011)|(?:3[68]\\d{2})|(?:30[012345]\\d))[ -]?(\\d{4})[ -]?(\\d{4})[ -]?(\\d{4}|3[4,7]\\d{13})$",
        "title": "Test"
    },
    {
        "description": "This regular expression will match a 24 hour time with no separators.",
        "matches": [
            "1200",
            "1645",
            "2359"
        ],
        "nonMatches": [
            "2400",
            "asbc",
            "12:45"
        ],
        "pattern": "^(20|21|22|23|[0-1]\\d)[0-5]\\d$",
        "title": "Test"
    },
    {
        "description": "Fully functional date validator in format dd.MM.yyyy Works only within range of years 2000-2099 ! It allows leading zeros but does not require them. The last year pattern (enumeration) is not very clever but I will improve it, if needed.",
        "matches": [
            "31.01.2002",
            "29.2.2004",
            "09.02.2005"
        ],
        "nonMatches": [
            "31.11.2002",
            "29.2.2002",
            "33.06.2000"
        ],
        "pattern": "^((0?[1-9]|[12][1-9]|3[01])\\.(0?[13578]|1[02])\\.20[0-9]{2}|(0?[1-9]|[12][1-9]|30)\\.(0?[13456789]|1[012])\\.20[0-9]{2}|(0?[1-9]|1[1-9]|2[0-8])\\.(0?[123456789]|1[012])\\.20[0-9]{2}|(0?[1-9]|[12][1-9])\\.(0?[123456789]|1[012])\\.20(00|04|08|12|16|20|24|28|32|36|40|44|48|52|56|60|64|68|72|76|80|84|88|92|96))$",
        "title": "Test"
    },
    {
        "description": "This can be used to match indian style pincodes / postal codes used by the indian postal departments which are 6 digits long and may have space after the 3rd digit",
        "matches": [
            "400 099",
            "400099",
            "400050"
        ],
        "nonMatches": [
            "2345678",
            "12345",
            "asdf"
        ],
        "pattern": "^\\d{3}\\s?\\d{3}$",
        "title": "Test"
    },
    {
        "description": "This expression matches three different formats of postal codes: 5 digit US ZIP code, 5 digit US ZIP code + 4, and 6 digit alphanumeric Canadian Postal Code. The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits. The Canadian postal code must be of the form ANA NAN where A is any uppercase alphabetic character and N is a numeric digit from 0 to 9.",
        "matches": [
            "44240",
            "44240-5555",
            "T2P 3C7"
        ],
        "nonMatches": [
            "44240ddd",
            "t44240-55",
            "t2p3c7"
        ],
        "pattern": "^((\\d{5}-\\d{4})|(\\d{5})|([A-Z]\\d[A-Z]\\s\\d[A-Z]\\d))$",
        "title": "Test"
    },
    {
        "description": "This re matches US currency format with lead dollar sign. Dollar value must have at least one digit and may or may not be comma separated. Cents value is optional.",
        "matches": [
            "$0.84",
            "$123458",
            "$1,234,567.89"
        ],
        "nonMatches": [
            "$12,3456.01",
            "12345",
            "$1.234"
        ],
        "pattern": "^\\$(\\d{1,3}(\\,\\d{3})*|(\\d+))(\\.\\d{2})?$",
        "title": "Test"
    },
    {
        "description": "Matches US currency input with or without commas. This provides a fix for the currency regular expression posted at http://regxlib.com/REDetails.aspx?regexp_id=70 by escaping the . (period) to ensure that no other characters may be used in it\u0027s place.",
        "matches": [
            "$3,023,123.34",
            "9,876,453",
            "123456.78"
        ],
        "nonMatches": [
            "4,33,234.34",
            "$1.234",
            "abc"
        ],
        "pattern": "^\\$?([0-9]{1,3},([0-9]{3},)*[0-9]{3}|[0-9]+)(\\.[0-9][0-9])?$",
        "title": "Test"
    },
    {
        "description": "A simple expression to brazilian phone number code, with international code. Simple DDI without \"+\" 99 plus simple DDD (99) plus simple local phone number 3 or 4 digits plus \"-\" plus 4 digits.",
        "matches": [
            "55(21)123-4567",
            "(11)1234-5678",
            "55(71)4562-2234"
        ],
        "nonMatches": [
            "3434-3432",
            "4(23)232-3232",
            "55(2)232-232"
        ],
        "pattern": "^([0-9]{2})?(\\([0-9]{2})\\)([0-9]{3}|[0-9]{4})-[0-9]{4}$",
        "title": "Test"
    },
    {
        "description": "This matches floating point expression in a more rigorous way - accepts both exponent as well as non exponent notations.",
        "matches": [
            "123",
            "-123.35",
            "-123.35e-2"
        ],
        "nonMatches": [
            "abc",
            "123.32e",
            "123.32.3"
        ],
        "pattern": "^[-+]?[0-9]+[.]?[0-9]*([eE][-+]?[0-9]+)?$",
        "title": "Test"
    },
    {
        "description": "Person\u0027s name (first, last, or both) in any letter case. Although not perfect, this expression will filter out many incorrect name formats (especially numerics and invalid special characters).",
        "matches": [
            "T.F. Johnson",
            "John O\u0027Neil",
            "Mary-Kate Johnson"
        ],
        "nonMatches": [
            "sam_johnson",
            "Joe--Bob Jones",
            "dfjsd0rd"
        ],
        "pattern": "^[a-zA-Z]+(([\\\u0027\\,\\.\\- ][a-zA-Z ])?[a-zA-Z]*)*$",
        "title": "Test"
    },
    {
        "description": "Percentage with 3 number after comma.",
        "matches": [
            "12,654",
            "1,987"
        ],
        "nonMatches": [
            "128,2",
            "12,"
        ],
        "pattern": "^100$|^[0-9]{1,2}$|^[0-9]{1,2}\\,[0-9]{1,3}$",
        "title": "Test"
    },
    {
        "description": "Password expresion that requires one lower case letter, one upper case letter, one digit, 6-13 length, and no spaces. This is merely an extension of a previously posted expression by Steven Smith (ssmith@aspalliance.com) . The no spaces is new.",
        "matches": [
            "1agdA*$#",
            "1agdA*$#",
            "1agdA*$#"
        ],
        "nonMatches": [
            "wyrn%@*&$# f",
            "mbndkfh782",
            "BNfhjdhfjd&*)%#$)"
        ],
        "pattern": "^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?!.*\\s).{4,8}$",
        "title": "Test"
    },
    {
        "description": "matches non-negative decimal floating points numbers less than 10",
        "matches": [
            "1.2345",
            "0.00001",
            "7"
        ],
        "nonMatches": [
            "12.2",
            "1.10.1",
            "15.98"
        ],
        "pattern": "^[0-9](\\.[0-9]+)?$",
        "title": "Test"
    },
    {
        "description": "Easy expression that checks for valid email addresses.",
        "matches": [
            "somthing@someserver.com",
            "firstname.lastname@mailserver.domain.com",
            "username-something@some-server."
        ],
        "nonMatches": [
            "username@someserver.domain.c",
            "somename@server.domain-com",
            "someone@something.se_eo"
        ],
        "pattern": "^([a-zA-Z0-9_\\-\\.]+)@([a-zA-Z0-9_\\-\\.]+)\\.([a-zA-Z]{2,5})$",
        "title": "Test"
    },
    {
        "description": "This regular expression validates a number NOT 0, with no more than 5 places ahead and 3 places behind the decimal point.",
        "matches": [
            "1",
            "12345.123",
            "0.5"
        ],
        "nonMatches": [
            "0",
            "0.0",
            "123456.1234"
        ],
        "pattern": "(?!^0*$)(?!^0*\\.0*$)^\\d{1,5}(\\.\\d{1,3})?$",
        "title": "Test"
    },
    {
        "description": "This matches an IP address, putting each number in its own group that can be retrieved by number. If you do not care about capturing the numbers, then you can make this shorter by putting everything after ^ until immediately after the first \\. in a group ( ) with a {3} after it. Then put the number matching regex in once more. It only permits numbers in the range 0-255.",
        "matches": [
            "0.0.0.0",
            "255.255.255.02",
            "192.168.0.136"
        ],
        "nonMatches": [
            "256.1.3.4",
            "023.44.33.22",
            "10.57.98.23."
        ],
        "pattern": "^(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])$",
        "title": "Test"
    },
    {
        "description": "This expression validates a date field in the European DD-MM-YYYY format. Days are validate for the given month and year.",
        "matches": [
            "05-01-2002",
            "29-02-2004",
            "31-12-2002"
        ],
        "nonMatches": [
            "1-1-02",
            "29-02-2002",
            "31-11-2002"
        ],
        "pattern": "^(((((0[1-9])|(1\\d)|(2[0-8]))-((0[1-9])|(1[0-2])))|((31-((0[13578])|(1[02])))|((29|30)-((0[1,3-9])|(1[0-2])))))-((20[0-9][0-9]))|(29-02-20(([02468][048])|([13579][26]))))$",
        "title": "Test"
    },
    {
        "description": "Postcode check for Netherlands",
        "matches": [
            "1234 AB",
            "1234AB"
        ],
        "nonMatches": [
            "123AB",
            "1234AAA"
        ],
        "pattern": "^[1-9]{1}[0-9]{3} ?[A-Z]{2}$",
        "title": "Test"
    },
    {
        "description": "Use this along with this replacement string <img\\1 /> to convert image tags to XHTML compliant image tags.",
        "matches": [
            "\u003Cimg src=\u0022bob\u0022\u003E"
        ],
        "nonMatches": [
            "\u003Cimg src=\u0022bob\u0022 /\u003E"
        ],
        "pattern": "\u003Cimg([^\u003E]*[^/])\u003E",
        "title": "Test"
    },
    {
        "description": "Password matching expression. Match all alphanumeric character and predefined wild characters. Password must consists of at least 8 characters and not more than 15 characters.",
        "matches": [
            "@12X*567",
            "1#Zv96g@*Yfasd4",
            "#67jhgt@erd"
        ],
        "nonMatches": [
            "$12X*567",
            "1#Zv_96",
            "+678jhgt@erd"
        ],
        "pattern": "^([a-zA-Z0-9@*#]{8,15})$",
        "title": "Test"
    },
    {
        "description": "This regular expressions matches dates in the format MM/YYYY where MM can be 01 to 12 and YYYY is always 4 digits long.",
        "matches": [
            "12/2002",
            "11/1900",
            "02/1977"
        ],
        "nonMatches": [
            "1/1977",
            "00/000",
            "15/2002"
        ],
        "pattern": "^((0[1-9])|(1[0-2]))\\/(\\d{4})$",
        "title": "Test"
    },
    {
        "description": "Meets german norm-standard: DIN 5008: 1996-05 for telephone numbers",
        "matches": [
            "(0 34 56) 34 56 67",
            "(03 45) 5 67 67",
            "(0 45) 2 33 45-45"
        ],
        "nonMatches": [
            "(2345) 34 34",
            "(0 56) 456 456",
            "(3 45) 2 34-45678"
        ],
        "pattern": "^\\(\\d{1,2}(\\s\\d{1,2}){1,2}\\)\\s(\\d{1,2}(\\s\\d{1,2}){1,2})((-(\\d{1,4})){0,1})$",
        "title": "Test"
    },
    {
        "description": "This RE validates standard Bible verse notation.",
        "matches": [
            "Genesis 3:3-4,6",
            "II Sam 2:11,2",
            "2 Tim 3:16"
        ],
        "nonMatches": [
            "Genesis chap 3, verse 3",
            "2nd Samuel 2"
        ],
        "pattern": "(?:\\d|I{1,3})?\\s?\\w{2,}\\.?\\s*\\d{1,}\\:\\d{1,}-?,?\\d{0,2}(?:,\\d{0,2}){0,2}",
        "title": "Test"
    },
    {
        "description": "This is a regular expression to validate a date string in \"MM/DD/YYYY\" format, a date time string in \"MM/DD/YYYY HH:MM\" or a date time string in \"MM/DD/YYYY HH:MM:SS\" format. It can validate date from 1600 to 2199.",
        "matches": [
            "12/30/2002",
            "01/12/1998 13:30",
            "01/28/2002 22:35:00"
        ],
        "nonMatches": [
            "13/30/2002",
            "01/12/1998 24:30",
            "01/28/2002 22:35:64"
        ],
        "pattern": "^([0]\\d|[1][0-2])\\/([0-2]\\d|[3][0-1])\\/([2][01]|[1][6-9])\\d{2}(\\s([0-1]\\d|[2][0-3])(\\:[0-5]\\d){1,2})?$",
        "title": "Test"
    },
    {
        "description": "Matches up to three alphabet words separated by spaces with first alphabet character of each word uppercase. Also matches empty strings.",
        "matches": [
            "Sacramento",
            "San Francisco",
            "San Luis Obispo"
        ],
        "nonMatches": [
            "SanFrancisco",
            "SanLuisObispo",
            "San francisco"
        ],
        "pattern": "^([A-Z]{1}[a-z]{1,})$|^([A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,})$|^([A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,})$|^$",
        "title": "Test"
    },
    {
        "description": "Validates time in MySQL time format. 24 hour time colon seperated hours:minutes:seconds",
        "matches": [
            "09:30:00",
            "17:45:20",
            "23:59:59"
        ],
        "nonMatches": [
            "24:00:00"
        ],
        "pattern": "(([0-1][0-9])|([2][0-3])):([0-5][0-9]):([0-5][0-9])",
        "title": "Test"
    },
    {
        "description": "Validate brazilian date formats: dd/mm/yyyy or d/m/yy or d.m.yyyy with separators: . - / Valid dates only! d (1-31)/ m (1-12)/ y (0..) (rizzipereira.com.br) For American date format: http://www.regexlib.com/REDetails.aspx?regexp_id=932",
        "matches": [
            "10/03/1979",
            "1-1-02",
            "01.1.2003"
        ],
        "nonMatches": [
            "10/03/197",
            "09--02--2004",
            "01 02 03"
        ],
        "pattern": "^([0]?[1-9]|[1|2][0-9]|[3][0|1])[./-]([0]?[1-9]|[1][0-2])[./-]([0-9]{4}|[0-9]{2})$",
        "title": "Test"
    },
    {
        "description": "Accepts only positive decimal values. Zero and negatvie numbers are non-matching. Allows zeros after last non-zero numeric value after decimal place for significant digits.",
        "matches": [
            "0.050",
            "5.0000",
            "5000"
        ],
        "nonMatches": [
            "0",
            "0.0",
            ".0"
        ],
        "pattern": "(^\\d*\\.?\\d*[1-9]+\\d*$)|(^[1-9]+\\d*\\.\\d*$)",
        "title": "Test"
    },
    {
        "description": "easy when you want to allow your users to post images, but in a controlled way. I used it like this (in php): $text = preg_replace(\"/(\\[IMG\\])(\\S+?)(\\[\\/IMG\\])/is\", \"<a href=\\\"\\\\2\\\" target=\\\"_blank\\\"><IMG SRC=\\\"\\\\2\\\" align=\\\"center\\\" height=\\\"100\\\" border=\\\"0\\\"></a>\",$text); so whenever they use [img]http://www.foo.com/bleh.jpg[/img] it will be converted to <a href=\"http://www.foo.com/bleh.jpg\" target=\"_blank\"><IMG SRC=\"http://www.foo.com/bleh.jpg\" align=\"center\" height=\"100\" border=\"0\"></a> so you get a 100 pixels high picture, and when they click on it it opens in a new window... (to prevent users from posting huge pictures and stuff)",
        "matches": [
            "[IMG]http://bleh.jpg[/IMG]",
            "[ImG]bleh[/imG]",
            "[img]ftp://login:pass@bleh.gif[/img]"
        ],
        "nonMatches": [
            "<img src=\"bleh.jpg\">"
        ],
        "pattern": "(\\[[Ii][Mm][Gg]\\])(\\S+?)(\\[\\/[Ii][Mm][Gg]\\])",
        "title": "Test"
    },
    {
        "description": "Accepts data of time in format h:mm and hh:mm ^([0-1]?[0-9]|[2][0-3]):([0-5][0-9])$ in php [0-23]:[0-59]{2} (posix)",
        "matches": [
            "0:00",
            "23:00",
            "00:59"
        ],
        "nonMatches": [
            "0:0",
            "24:00",
            "00:60"
        ],
        "pattern": "^([0-1]?[0-9]|[2][0-3]):([0-5][0-9])$",
        "title": "Test"
    },
    {
        "description": "Validates MM/YY for rough checking credit card expiration dates.",
        "matches": [
            "11/03",
            "01/04"
        ],
        "nonMatches": [
            "13/03",
            "10/2003"
        ],
        "pattern": "^((0[1-9])|(1[0-2]))\\/(\\d{2})$",
        "title": "Test"
    },
    {
        "description": "Incorporated other people\u0027s examples; removed extraneous parenthesis on 10/7/04. Currently the SSA site says 772 is the highest AREA number generated (http://www.ssa.gov/employer/highgroup.txt). Old expression was: (^|\\s)\\d{3}(-?|[\\. ])\\d{2}\\2\\d{4}($|\\s|[;:,!\\.\\?]). Looks for either the beginning of a line or whitespace before the beginning of the social security number, then either zero or one hyphen OR one of a period or space, then uses the \\3 to reference the value returned in the parenthesis that includes the -?|[\\. ] (basically says if the first dash, period, or space is there, then the second one is required; and if the first dash, period, or space is not there, then the second one can\u0027t be either), and finally looks for the end of a line, whitespace, or punctuation characters after the social security number.",
        "matches": [
            "123-45-6789",
            "123 45 6789",
            "123456789"
        ],
        "nonMatches": [
            "12345-67-890123",
            "1234-56-7890",
            "123-45-78901"
        ],
        "pattern": "(^|\\s)(00[1-9]|0[1-9]0|0[1-9][1-9]|[1-6]\\d{2}|7[0-6]\\d|77[0-2])(-?|[\\. ])([1-9]0|0[1-9]|[1-9][1-9])\\3(\\d{3}[1-9]|[1-9]\\d{3}|\\d[1-9]\\d{2}|\\d{2}[1-9]\\d)($|\\s|[;:,!\\.\\?])",
        "title": "Test"
    },
    {
        "description": "An expression for .NET regular expression validation controls intended to faciliate the entry of percentage values both a whole numbers or as their decimal representations. Also compatible with the default US format for string formatting for percentages. Recommend that if you intended accept a value passing this express that you strip the percentage signs and take measures to ensure that any whole values are converted to percentages.",
        "matches": [
            "4.0%",
            "0.45",
            ".0345"
        ],
        "nonMatches": [
            "123",
            "%12"
        ],
        "pattern": "^\\d{0,2}(\\.\\d{1,4})? *%?$",
        "title": "Test"
    },
    {
        "description": "Can be used to remove &amp;lt;SCRIPT language=&amp;quot;JavaScript&amp;quot;&amp;gt; &amp;lt;!-- //--&amp;gt; &amp;lt;/SCRIPT&amp;gt; from embeded javascript Should be used as case insensitive",
        "matches": [
            "<SCRIPT language=\"JavaScript\"> <!-- //--> </SCRIPT>",
            "<SCRIPT l"
        ],
        "nonMatches": [
            "<!-- //-->"
        ],
        "pattern": "(\\/\\/-->\\s*)?<\\/?SCRIPT([^>]*)>(\\s*<!--\\s)?",
        "title": "Test"
    },
    {
        "description": "UK Phone Number Allows leading and trailing spaces and optional spaces after the dialing code. Initially the expression I posted was \\s*0\\d{4}\\s*\\d{6}\\s*|\\s*0\\d{3}\\s*\\d{7}\\s* But this didn\u0027t include optional brackets e.g. (01603) 123123 or phone numbers in a London format e.g. 0208 123 1234",
        "matches": [
            "01603 123123",
            "0207 1234567",
            "(0208) 123 1234"
        ],
        "nonMatches": [
            "123 123132"
        ],
        "pattern": "(\\s*\\(?0\\d{4}\\)?\\s*\\d{6}\\s*)|(\\s*\\(?0\\d{3}\\)?\\s*\\d{3}\\s*\\d{4}\\s*)",
        "title": "Test"
    },
    {
        "description": "Is used to evaluating domain names, none of the extras such as paths or protocols.",
        "matches": [
            "zigamorph.com",
            "www.zigamorph.com",
            "localhost"
        ],
        "nonMatches": [
            "http://www.zigamorph.com",
            "ftp://zigamorph.com",
            "localhost/default.aspx"
        ],
        "pattern": "^(([\\w][\\w\\-\\.]*)\\.)?([\\w][\\w\\-]+)(\\.([\\w][\\w\\.]*))?$",
        "title": "Test"
    },
    {
        "description": "Regular expression to match a canadian postal code where it matches a string with or without the hyphen and in upercase or lowercase",
        "matches": [
            "a1a-1a1",
            "A1A1A1"
        ],
        "nonMatches": [
            "1a1-a1a",
            "aaa-aaa",
            "111-111"
        ],
        "pattern": "^([A-Za-z]\\d[A-Za-z][-]?\\d[A-Za-z]\\d)",
        "title": "Test"
    },
    {
        "description": "Correct German DateTime. Does not check leap year rules! Possible Formats of date part: D.M.YYYY or D.MM.YYYY or DD.MM.YYYY or DD.M.YYYY Possible formats of time part: h:mm or hh:mm",
        "matches": [
            "20.10.2003 08:10",
            "24.12.2003",
            "1.1.2004 8:15"
        ],
        "nonMatches": [
            "25.13.2004",
            "20.10.2003 08:9"
        ],
        "pattern": "^(([1-9]|[0-2]\\d|[3][0-1])\\.([1-9]|[0]\\d|[1][0-2])\\.[2][0]\\d{2})$|^(([1-9]|[0-2]\\d|[3][0-1])\\.([1-9]|[0]\\d|[1][0-2])\\.[2][0]\\d{2}\\s([1-9]|[0-1]\\d|[2][0-3])\\:[0-5]\\d)$",
        "title": "Test"
    },
    {
        "description": "Date with leap years. Accepts \u0027.\u0027\u0027-\u0027 and \u0027/\u0027 as separators d.m.yy to dd.mm.yyyy (or d.mm.yy, etc) Ex: dd-mm-yyyy d.mm/yy dd/m.yyyy etc etc Accept 00 years also.",
        "matches": [
            "29.2.2004",
            "31121975",
            "29/2-00"
        ],
        "nonMatches": [
            "29.2.2005",
            "32121975",
            "29.2/01"
        ],
        "pattern": "^((((0?[1-9]|[12]\\d|3[01])[\\.\\-\\/](0?[13578]|1[02])[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}))|((0?[1-9]|[12]\\d|30)[\\.\\-\\/](0?[13456789]|1[012])[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}))|((0?[1-9]|1\\d|2[0-8])[\\.\\-\\/]0?2[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}))|(29[\\.\\-\\/]0?2[\\.\\-\\/]((1[6-9]|[2-9]\\d)?(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)|00)))|(((0[1-9]|[12]\\d|3[01])(0[13578]|1[02])((1[6-9]|[2-9]\\d)?\\d{2}))|((0[1-9]|[12]\\d|30)(0[13456789]|1[012])((1[6-9]|[2-9]\\d)?\\d{2}))|((0[1-9]|1\\d|2[0-8])02((1[6-9]|[2-9]\\d)?\\d{2}))|(2902((1[6-9]|[2-9]\\d)?(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)|00))))$",
        "title": "Test"
    },
    {
        "description": "Date expression validator with format YYMMDD Validates leap years. Of course, as year has only 2 digits, it\u0027s not possible to invalidate years like 2100, 2200, 2300, etc as a non-leap years !",
        "matches": [
            "751231",
            "000229",
            "040229"
        ],
        "nonMatches": [
            "750431",
            "010229",
            "050229"
        ],
        "pattern": "^((\\d{2}((0[13578]|1[02])(0[1-9]|[12]\\d|3[01])|(0[13456789]|1[012])(0[1-9]|[12]\\d|30)|02(0[1-9]|1\\d|2[0-8])))|([02468][048]|[13579][26])0229)$",
        "title": "Test"
    },
    {
        "description": "Validates a UK Bank Sort code",
        "matches": [
            "09-01-29",
            "05-06-25"
        ],
        "nonMatches": [
            "090125"
        ],
        "pattern": "^[0-9]{2}[-][0-9]{2}[-][0-9]{2}$",
        "title": "Test"
    },
    {
        "description": "Input for Numeric values. Handles negatives, and comma formatted values. Also handles a single decimal point",
        "matches": [
            "5,000",
            "-5,000",
            "100.044"
        ],
        "nonMatches": [
            "abc",
            "Hundred",
            "1.3.4"
        ],
        "pattern": "^(\\d|-)?(\\d|,)*\\.?\\d*$",
        "title": "Test"
    },
    {
        "description": "Allows only positive integers that are greater then 0. Easily modified for +/- intergers and allowing zero.",
        "matches": [
            "1",
            "12",
            "124"
        ],
        "nonMatches": [
            "-1",
            "a",
            "1.0"
        ],
        "pattern": "^[1-9]+[0-9]*$",
        "title": "Test"
    },
    {
        "description": "does not allow IP for domain name : hello@154.145.68.12 does not allow litteral addresses \"hello, how are you?\"@world.com allows numeric domain names after the last \".\" minimum 2 letters",
        "matches": [
            "he_llo@worl.d.com",
            "hel.l-o@wor-ld.museum",
            "h1ello@123.com"
        ],
        "nonMatches": [
            "hello@worl_d.com",
            "he&llo@world.co1",
            ".hello@wor#.co.uk"
        ],
        "pattern": "^[A-Za-z0-9](([_\\.\\-]?[a-zA-Z0-9]+)*)@([A-Za-z0-9]+)(([\\.\\-]?[a-zA-Z0-9]+)*)\\.([A-Za-z]{2,})$",
        "title": "Test"
    },
    {
        "description": "This allows a sequence of real numbers to be added, separated by a comma (required) and a space (optional). Based pretty heavily on an expression by Steven Smith on this site.",
        "matches": [
            "8.0",
            "8.0,-.38,+8.9",
            "8.0, +8.8, 0.09"
        ],
        "nonMatches": [
            "+",
            ".",
            "a,b, c"
        ],
        "pattern": "^((\\d?)|(([-+]?\\d+\\.?\\d*)|([-+]?\\d*\\.?\\d+))|(([-+]?\\d+\\.?\\d*\\,\\ ?)*([-+]?\\d+\\.?\\d*))|(([-+]?\\d*\\.?\\d+\\,\\ ?)*([-+]?\\d*\\.?\\d+))|(([-+]?\\d+\\.?\\d*\\,\\ ?)*([-+]?\\d*\\.?\\d+))|(([-+]?\\d*\\.?\\d+\\,\\ ?)*([-+]?\\d+\\.?\\d*)))$",
        "title": "Test"
    },
    {
        "description": "Allows Canadian, American and UK postal/zip codes. Allowing hyphens, periods, or spaces to separate.",
        "matches": [
            "N9B.1Y8",
            "90210-1234",
            "NE21 6EQ"
        ],
        "nonMatches": [
            "NN8 Y83"
        ],
        "pattern": "^(\\d{5}((|-)-\\d{4})?)|([A-Za-z]\\d[A-Za-z][\\s\\.\\-]?(|-)\\d[A-Za-z]\\d)|[A-Za-z]{1,2}\\d{1,2}[A-Za-z]? \\d[A-Za-z]{2}$",
        "title": "Test"
    },
    {
        "description": "File Name Validator. Validates both UNC (\\\\server\\share\\file) and regular MS path (c:\\file).",
        "matches": [
            "File.txt",
            "c:\\Blah\\..\\.\\Blah Blah.Blah\\File.txt",
            "\\\\server\\share\\file.txt"
        ],
        "nonMatches": [
            "File.txt",
            "c:\\.File.txt",
            "c:\\.\\.Blah\\File.txt"
        ],
        "pattern": "^(([a-zA-Z]:|\\\\)\\\\)?(((\\.)|(\\.\\.)|([^\\\\/:\\*\\?\u0022\\|\u003C\u003E\\. ](([^\\\\/:\\*\\?\u0022\\|\u003C\u003E\\. ])|([^\\\\/:\\*\\?\u0022\\|\u003C\u003E]*[^\\\\/:\\*\\?\u0022\\|\u003C\u003E\\. ]))?))\\\\)*[^\\\\/:\\*\\?\u0022\\|\u003C\u003E\\. ](([^\\\\/:\\*\\?\u0022\\|\u003C\u003E\\. ])|([^\\\\/:\\*\\?\u0022\\|\u003C\u003E]*[^\\\\/:\\*\\?\u0022\\|\u003C\u003E\\. ]))?$",
        "title": "Test"
    },
    {
        "description": "Matches C style strings allowing for escaped string delimiters to be included in the match. ALTERED 13-Dec-2003 ------------------- Previous pattern was : \"([^\"](?:\\\\.|[^\\\\\"]*)*)\" Changed to: \"([^\"]*(?:\\\\.|[^\\\\\"]*)*)\" Making the first character after the opening quote optional allows the pattern to match on empty quotes: \"\".",
        "matches": [
            "\"This is a \\\"string\\\".\""
        ],
        "nonMatches": [
            "\"This is a \\\"string\\\"."
        ],
        "pattern": "\"([^\"](?:\\\\.|[^\\\\\"]*)*)\"",
        "title": "Test"
    },
    {
        "description": "Validates Dutch Postal Codes (ZipCode). There was a previous one listed here, but it\u0027s not entirely correct. Namely that dutch postal codes can contain a zero but cannot start with one, so this one is the adjusted version.",
        "matches": [
            "1234AB",
            "1234 AB",
            "1001 AB"
        ],
        "nonMatches": [
            "0123AB",
            "1234A B",
            "0123 AB"
        ],
        "pattern": "^[1-9][0-9]{3}\\s?[a-zA-Z]{2}$",
        "title": "Test"
    },
    {
        "description": "DateTime Validator.",
        "matches": [
            "12/25/2003",
            "08:03:31",
            "02/29/2004 12 AM"
        ],
        "nonMatches": [
            "02/29/2003 1:34 PM",
            "13:23 PM",
            "24:00:00"
        ],
        "pattern": "^(?=\\d)(?:(?:(?:(?:(?:0?[13578]|1[02])(\\/|-|\\.)31)\\1|(?:(?:0?[1,3-9]|1[0-2])(\\/|-|\\.)(?:29|30)\\2))(?:(?:1[6-9]|[2-9]\\d)?\\d{2})|(?:0?2(\\/|-|\\.)29\\3(?:(?:(?:1[6-9]|[2-9]\\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00))))|(?:(?:0?[1-9])|(?:1[0-2]))(\\/|-|\\.)(?:0?[1-9]|1\\d|2[0-8])\\4(?:(?:1[6-9]|[2-9]\\d)?\\d{2}))($|\\ (?=\\d)))?(((0?[1-9]|1[012])(:[0-5]\\d){0,2}(\\ [AP]M))|([01]\\d|2[0-3])(:[0-5]\\d){1,2})?$",
        "title": "Test"
    },
    {
        "description": "Date in DD/MM/YYYY format. Fecha en formato DD/MM/AAAA.",
        "matches": [
            "28/12/2003",
            "28/02/2003",
            "29/02/2000"
        ],
        "nonMatches": [
            "28-02-2003",
            "30/02/2003",
            "28.02.2003"
        ],
        "pattern": "(((0[1-9]|[12][0-9]|3[01])([/])(0[13578]|10|12)([/])(\\d{4}))|(([0][1-9]|[12][0-9]|30)([/])(0[469]|11)([/])(\\d{4}))|((0[1-9]|1[0-9]|2[0-8])([/])(02)([/])(\\d{4}))|((29)(\\.|-|\\/)(02)([/])([02468][048]00))|((29)([/])(02)([/])([13579][26]00))|((29)([/])(02)([/])([0-9][0-9][0][48]))|((29)([/])(02)([/])([0-9][0-9][2468][048]))|((29)([/])(02)([/])([0-9][0-9][13579][26])))",
        "title": "Test"
    },
    {
        "description": "Brazilian cep",
        "matches": [
            "12345-678"
        ],
        "nonMatches": [
            "12345678",
            "123456-12",
            "12345.678"
        ],
        "pattern": "(^\\d{5}\\x2D\\d{3}$)",
        "title": "Test"
    },
    {
        "description": "",
        "matches": [
            "<!-- <h1>this text has been removed</h1> -->",
            "<!-- yada -->"
        ],
        "nonMatches": [
            "<h1>this text has not been removed</h1>"
        ],
        "pattern": "<!--.*?-->",
        "title": "Test"
    },
    {
        "description": "Matches ANSI SQL date format YYYY-mm-dd hh:mi:ss am/pm. You can use / - or space for date delimiters, so 2004-12-31 works just as well as 2004/12/31. Checks leap year from 1901 to 2099.",
        "matches": [
            "2004-2-29",
            "2004-02-29 10:29:39 pm",
            "2004/12/31"
        ],
        "nonMatches": [
            "2003-2-29",
            "2003-13-02",
            "2003-2-2 10:72:30 am"
        ],
        "pattern": "^((\\d{2}(([02468][048])|([13579][26]))[\\-\\/\\s]?((((0?[13578])|(1[02]))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])))))|(\\d{2}(([02468][1235679])|([13579][01345789]))[\\-\\/\\s]?((((0?[13578])|(1[02]))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\-\\/\\s]?((0?[1-9])|(1[0-9])|(2[0-8]))))))(\\s(((0?[1-9])|(1[0-2]))\\:([0-5][0-9])((\\s)|(\\:([0-5][0-9])\\s))([AM|PM|am|pm]{2,2})))?$",
        "title": "Test"
    },
    {
        "description": "Checks domain names. This validates domains based on latest specifications (RFCs 952 and 1123 dealing with hostnames and RFC 1035 dealing with domain name system requirements) except that it only includes realistic fully-qualified domains: 1. requires at least one subdomain 2. allows shortest top-level domains like \"ca\", and \"museum\" as longest. Other validation rules: 1. Labels/parts should be seperated by period. 2. Each label/part has maximum of 63 characters. 3. First and last character of label must be alphanumeric, other characters alphanumeric or hyphen. 4. Does not check maxlength of domain which incidentally is 253 characters of text (255 binary representation). For a regular expression that matches ALL domains: ^([a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?\\.)*[a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?$",
        "matches": [
            "regexlib.com",
            "this.is.a.museum",
            "3com.com"
        ],
        "nonMatches": [
            "notadomain-.com",
            "helloworld.c",
            ".oops.org"
        ],
        "pattern": "^([a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,6}$",
        "title": "Test"
    },
    {
        "description": "This validates the states and territories of the United States in a 2 character uppercase format. Very poor excuse for a regular expression! ;) Written by Jason Gaylord.",
        "matches": [
            "NY",
            "PA",
            "NJ"
        ],
        "nonMatches": [
            "Pennsylvania",
            "Pa",
            "pa"
        ],
        "pattern": "^((AL)|(AK)|(AS)|(AZ)|(AR)|(CA)|(CO)|(CT)|(DE)|(DC)|(FM)|(FL)|(GA)|(GU)|(HI)|(ID)|(IL)|(IN)|(IA)|(KS)|(KY)|(LA)|(ME)|(MH)|(MD)|(MA)|(MI)|(MN)|(MS)|(MO)|(MT)|(NE)|(NV)|(NH)|(NJ)|(NM)|(NY)|(NC)|(ND)|(MP)|(OH)|(OK)|(OR)|(PW)|(PA)|(PR)|(RI)|(SC)|(SD)|(TN)|(TX)|(UT)|(VT)|(VI)|(VA)|(WA)|(WV)|(WI)|(WY))$",
        "title": "Test"
    },
    {
        "description": "It is the exact phone number regular expression for \u0027(###) ###-####\u0027. Written by Jason Gaylord.",
        "matches": [
            "(555) 555-1212"
        ],
        "nonMatches": [
            "555-1212",
            "1-800-555-1212",
            "555-555-1212"
        ],
        "pattern": "^([\\(]{1}[0-9]{3}[\\)]{1}[ ]{1}[0-9]{3}[\\-]{1}[0-9]{4})$",
        "title": "Test"
    },
    {
        "description": "This RE validates dates in the dd MMM yyyy format. Spaces separate the values.",
        "matches": [
            "31 January 2003",
            "29 March 2004",
            "29 Feb 2008"
        ],
        "nonMatches": [
            "Jan 1 2003",
            "31 Sept 2003",
            "29 February 2003"
        ],
        "pattern": "^((31(?!\\ (Feb(ruary)?|Apr(il)?|June?|(Sep(?=\\b|t)t?|Nov)(ember)?)))|((30|29)(?!\\ Feb(ruary)?))|(29(?=\\ Feb(ruary)?\\ (((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))|(0?[1-9])|1\\d|2[0-8])\\ (Jan(uary)?|Feb(ruary)?|Ma(r(ch)?|y)|Apr(il)?|Ju((ly?)|(ne?))|Aug(ust)?|Oct(ober)?|(Sep(?=\\b|t)t?|Nov|Dec)(ember)?)\\ ((1[6-9]|[2-9]\\d)\\d{2})$",
        "title": "Test"
    },
    {
        "description": "This RE validate the full name of the months.",
        "matches": [
            "January",
            "May",
            "October"
        ],
        "nonMatches": [
            "Jan",
            "Septem",
            "Octo"
        ],
        "pattern": "^(?:J(anuary|u(ne|ly))|February|Ma(rch|y)|A(pril|ugust)|(((Sept|Nov|Dec)em)|Octo)ber)$",
        "title": "Test"
    },
    {
        "description": "validate a number 5 digits and 2 decimal places allowing zero",
        "matches": [
            "12345.67",
            "0",
            "0.1"
        ],
        "nonMatches": [
            "123456.78",
            "123456.789",
            ".1"
        ],
        "pattern": "^\\d{1,5}(\\.\\d{1,2})?$",
        "title": "Test"
    },
    {
        "description": "More permissive than others on the site, this one allows you to let a user enter US phone numbers in the way they most commonly use, without letting them enter non-valid combinations.",
        "matches": [
            "5551212",
            "614555-1212",
            "(614)555-1212"
        ],
        "nonMatches": [
            "A12-5555",
            "(614-555-1212",
            "555*1212"
        ],
        "pattern": "^([\\(]{1}[0-9]{3}[\\)]{1}[\\.| |\\-]{0,1}|^[0-9]{3}[\\.|\\-| ]?)?[0-9]{3}(\\.|\\-| )?[0-9]{4}$",
        "title": "Test"
    },
    {
        "description": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes. It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long. Canadain postal codes can contain a space and take form of A1A 1A1. The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.",
        "matches": [
            "00501",
            "84118-3423",
            "n3a 3B7"
        ],
        "nonMatches": [
            "501-342",
            "123324",
            "Q4B 5C5"
        ],
        "pattern": "^((\\d{5}-\\d{4})|(\\d{5})|([AaBbCcEeGgHhJjKkLlMmNnPpRrSsTtVvXxYy]\\d[A-Za-z]\\s?\\d[A-Za-z]\\d))$",
        "title": "Test"
    },
    {
        "description": "This regular expression match any valid file path. It checks local drives and network path. The file extension is required.",
        "matches": [
            "c:\\Test.txt",
            "\\\\server\\shared\\Test.txt",
            "\\\\server\\shared\\Test.t"
        ],
        "nonMatches": [
            "c:\\Test",
            "\\\\server\\shared",
            "\\\\server\\shared\\Test.?"
        ],
        "pattern": "^([a-zA-Z]\\:|\\\\\\\\[^\\/\\\\:*?\u0022\u003C\u003E|]+\\\\[^\\/\\\\:*?\u0022\u003C\u003E|]+)(\\\\[^\\/\\\\:*?\u0022\u003C\u003E|]+)+(\\.[^\\/\\\\:*?\u0022\u003C\u003E|]+)$",
        "title": "Test"
    },
    {
        "description": "A regex that attempts to accurately parse the elements from a proper name where the format is in <<First, Last>> order or some permutation of that order. Critiques and suggestions for improvement are welcome.",
        "matches": [
            "David F Walker",
            "J. S. Smith, Jr.",
            "Catherine Zeta-Jones"
        ],
        "nonMatches": [
            "oscar peterson"
        ],
        "pattern": "(?\u003CFirstName\u003E[A-Z]\\.?\\w*\\-?[A-Z]?\\w*)\\s?(?\u003CMiddleName\u003E[A-Z]\\w*|[A-Z]?\\.?)\\s?(?\u003CLastName\u003E[A-Z]\\w*\\-?[A-Z]?\\w*)(?:,\\s|)(?\u003CSuffix\u003EJr\\.|Sr\\.|IV|III|II|)",
        "title": "Test"
    },
    {
        "description": "Street Address. While far from perfect it validates street addresses reasonably. Created with absolutely no experience using a cool tool downloaded from http://www.codeproject.com/dotnet/expresso.asp?target=e%20xpresso",
        "matches": [
            "2\\34 Wodonga Ave",
            "54a Beechworth Rd",
            "47/675 WODONGA DRIVE"
        ],
        "nonMatches": [
            "aaa Beechworth Rd",
            "65 Beechworth Rd",
            "65 Beechworth/ Rd"
        ],
        "pattern": "\\d{1,3}.?\\d{0,3}\\s[a-zA-Z]{2,30}\\s[a-zA-Z]{2,15}",
        "title": "Test"
    },
    {
        "description": "HTML Pattern Matching PLEASE HELP /<[^>]*>/ig The above pattern is only successful when html tag are simple (they don\u0027t include any javascript). This mean that the pattern will fail if something like this is within the tag <input type=button value=test onclick=\u0027if(n.value>5)do_this();\u0027>. It will not match the entire open n close sign. How do you write a pattern that will pass all these tag so that the pattern will match from the open to the close sign and not when it just see a > within a \u0027\u0027 or \"\". <input type=button onclick=\u0027if(n.value>5)do_this();\u0027> not this <br> <input type=button onclick=\"n>5?a():b();\" value=test> not this <br> <input type=button onclick=\"n>5?a(\\\"OK\\\"):b(\u0027Not Ok\u0027);\" value=test> not this <br> <input type=button onclick=\u0027n>5\u0027 value=test onmouseover=\"n<5&&n>8\" onmouseout=\u0027if(n>5)alert(\\\u0027True\\\u0027);else alert(\"False\")\u0027> not this <br> Any help would be greatly appreciate. Thanks a whole lot. Logan",
        "matches": [
            "\u003Chtml\u003E"
        ],
        "nonMatches": [
            "abc"
        ],
        "pattern": "\u003C[^\u003E]*\u003E",
        "title": "Test"
    },
    {
        "description": "This regular expressions matches phone numbers with area codes and optional US country code and optional phone extension. User have so many ways of entering phone numbers into input fields. This allows for some of the ones I\u0027ve encountered. Feel free to contact me if you find ones that do not match.",
        "matches": [
            "2405525009",
            "1(240) 652-5009",
            "240/752-5009 ext.55"
        ],
        "nonMatches": [
            "(2405525009",
            "2 (240) 652-5009"
        ],
        "pattern": "^(1\\s*[-\\/\\.]?)?(\\((\\d{3})\\)|(\\d{3}))\\s*[-\\/\\.]?\\s*(\\d{3})\\s*[-\\/\\.]?\\s*(\\d{4})\\s*(([xX]|[eE][xX][tT])\\.?\\s*(\\d+))*$",
        "title": "Test"
    },
    {
        "description": "US Zip Code + 4 digit extension Postal Code",
        "matches": [
            "14467",
            "144679554",
            "14467-9554"
        ],
        "nonMatches": [
            "14467 955",
            "14467-",
            "1446-9554"
        ],
        "pattern": "^[0-9]{5}([- /]?[0-9]{4})?$",
        "title": "Test"
    },
    {
        "description": "This pattern returns as much of the first x characters of a string as full words or sentences as a match, where x is currently 20. Change x to adjust the length supported in your database field. I\u0027m currently using this within a string shortening utility to shrink large text regions to word/sentance-boundary elements and appending an ellipsis as a text continuator.",
        "matches": [
            "Any text of any length",
            "...but will only \u0027match\u0027 the first 20 characters at a period or space."
        ],
        "nonMatches": [
            "N/A"
        ],
        "pattern": "^([\\s\\S]){1,20}([\\s\\.])",
        "title": "Test"
    },
    {
        "description": "The RE match U.S. state abbreviation used by the U.S. Post Office.",
        "matches": [
            "AL",
            "CA",
            "AA"
        ],
        "nonMatches": [
            "New York",
            "California",
            "ny"
        ],
        "pattern": "^(?-i:A[LKSZRAEP]|C[AOT]|D[EC]|F[LM]|G[AU]|HI|I[ADLN]|K[SY]|LA|M[ADEHINOPST]|N[CDEHJMVY]|O[HKR]|P[ARW]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY])$",
        "title": "Test"
    },
    {
        "description": "captures US street address. Address format: ##### Street 2ndunit City, ST zip+4 address1 - must have street number and proper case street name. no punctuation or P.O Box #### punctuation manditory for P.O. address2 - optional secondary unit abbr. Secondary range required for some units. City - Proper case city name. State - State abbreviation. All caps zip - zip+4. Can\u0027t be all zeroes Abbreviations for secondary units and States are those used by the US Postal Service. http://www.usps.com/ncsc/lookups/usps_abbreviations.html Certain secondary units require a secondary range, see the above link THis RE isn\u0027t unbreakable, Probably will allow some false positives but should work for most addresses.",
        "matches": [
            "123 Park Ave Apt 123 New York City, NY 10002",
            "P.O. Box 12345 Los Angeles, CA 12304"
        ],
        "nonMatches": [
            "123 Main St",
            "123 City, State 00000",
            "123 street city, ST 00000"
        ],
        "pattern": "^(?n:(?\u003Caddress1\u003E(\\d{1,5}(\\ 1\\/[234])?(\\x20[A-Z]([a-z])+)+ )|(P\\.O\\.\\ Box\\ \\d{1,5}))\\s{1,2}(?i:(?\u003Caddress2\u003E(((APT|B LDG|DEPT|FL|HNGR|LOT|PIER|RM|S(LIP|PC|T(E|OP))|TRLR|UNIT)\\x20\\w{1,5})|(BSMT|FRNT|LBBY|LOWR|OFC|PH|REAR|SIDE|UPPR)\\.?)\\s{1,2})?)(?\u003Ccity\u003E[A-Z]([a-z])+(\\.?)(\\x20[A-Z]([a-z])+){0,2})\\, \\x20(?\u003Cstate\u003EA[LKSZRAP]|C[AOT]|D[EC]|F[LM]|G[AU]|HI|I[ADL N]|K[SY]|LA|M[ADEHINOPST]|N[CDEHJMVY]|O[HKR]|P[ARW]|RI|S[CD] |T[NX]|UT|V[AIT]|W[AIVY])\\x20(?\u003Czipcode\u003E(?!0{5})\\d{5}(-\\d {4})?))$",
        "title": "Test"
    },
    {
        "description": "Matches on MMDDYYYY only, requires all 8 digits",
        "matches": [
            "01012003",
            "02292000"
        ],
        "nonMatches": [
            "01/01/2003"
        ],
        "pattern": "((^(10|12|0?[13578])(3[01]|[12][0-9]|0?[1-9])((1[8-9]\\d{2})|([2-9]\\d{3}))$)|(^(11|0?[469])(30|[12][0-9]|0?[1-9])((1[8-9]\\d{2})|([2-9]\\d{3}))$)|(^(0?2)(2[0-8]|1[0-9]|0?[1-9])((1[8-9]\\d{2})|([2-9]\\d{3}))$)|(^(0?2)(29)([2468][048]00)$)|(^(0?2)(29)([3579][26]00)$)|(^(0?2)(29)([1][89][0][48])$)|(^(0?2)(29)([2-9][0-9][0][48])$)|(^(0?2)(29)([1][89][2468][048])$)|(^(0?2)(29)([2-9][0-9][2468][048])$)|(^(0?2)(29)([1][89][13579][26])$)|(^(0?2)(29)([2-9][0-9][13579][26])$))",
        "title": "Test"
    },
    {
        "description": "New DateTime Regex. Rebuilt better than before, better, stronger, faster.",
        "matches": [
            "1/31/2002 10 AM",
            "2/29/2004",
            "4:15:04 PM"
        ],
        "nonMatches": [
            "2/29/2003",
            "12/32/2003",
            "4:00"
        ],
        "pattern": "(?n:^(?=\\d)((?\u003Cmonth\u003E(0?[13578])|1[02]|(0?[469]|11)(?!.31)|0?2(?(.29)(?=.29.((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|(16|[2468][048]|[3579][26])00))|(?!.3[01])))(?\u003Csep\u003E[-./])(?\u003Cday\u003E0?[1-9]|[12]\\d|3[01])\\k\u003Csep\u003E(?\u003Cyear\u003E(1[6-9]|[2-9]\\d)\\d{2})(?(?=\\x20\\d)\\x20|$))?(?\u003Ctime\u003E((0?[1-9]|1[012])(:[0-5]\\d){0,2}(?i:\\x20[AP]M))|([01]\\d|2[0-3])(:[0-5]\\d){1,2})?$)",
        "title": "Test"
    },
    {
        "description": "This tests an input string for only a-z and A-Z and only allows underscores, hyphens and spaces. The purpose is to force users to generate legitimate, readable file names that can be streamed from the web.",
        "matches": [
            "123Testing",
            "123_Testing",
            "123-Testing This"
        ],
        "nonMatches": [
            "!@#Testing",
            "Testing \"This\"",
            "Don\u0027t Forget to Write"
        ],
        "pattern": "^[a-zA-Z0-9_\\s-]+$",
        "title": "Test"
    },
    {
        "description": "It matches .jpg files. It allows for a dot in the path. A dot may occur in such directories as: C:\\Documents and Settings\\roman.lukyanenko\\Desktop\\stuff\\b_card2.jpg or C:\\Windows\\Microsoft.NET etc",
        "matches": [
            "C:\\Documents and Settings\\roman.lukyanenko\\Desktop\\stuff\\b_card2.jpg",
            "C:\\b_card.jpg",
            "\\\\network\\fol"
        ],
        "nonMatches": [
            "C:\\file.xls"
        ],
        "pattern": "^(([a-zA-Z]:)|(\\\\{2}\\w+)\\$?)(\\\\(\\w[\\w ]*.*))+\\.(jpg|JPG)$",
        "title": "Test"
    },
    {
        "description": "I built this expression to test a string in ASP for valid username and password constraints. It can be adapted for any number of scenerios. For instance in this case, we needed to ensure the username someone wanted was not all numbers or all letters and was 6-15 characters in length with no special characters. This expression tests negatively for all number cases, then all letter cases, and lastly tests for only alphanumeric characters in the required range. In other words: the match must be alphanumeric with at least one number, one letter, and be between 6-15 character in length.",
        "matches": [
            "C2dfeed",
            "sporttrak1",
            "11223a"
        ],
        "nonMatches": [
            "pookie",
            "d34_fff",
            "123456"
        ],
        "pattern": "(?!^[0-9]*$)(?!^[a-zA-Z]*$)^([a-zA-Z0-9]{6,15})$",
        "title": "Test"
    },
    {
        "description": "This RE will match all the valid elements in HTML 4.01",
        "matches": [
            "\u003CHTML\u003E",
            "\u003Ca href=\u0022link.html\u0022\u003ELink\u003C/a\u003E"
        ],
        "nonMatches": [
            "\u003Cxml\u003E",
            "\u003Cphonytag\u003E",
            "\u003Cimage\u003E"
        ],
        "pattern": "(\u003C\\/?)(?i:(?\u003Celement\u003Ea(bbr|cronym|ddress|pplet|rea)?|b(ase(font)?|do|ig|lockquote|ody|r|utton)?|c(aption|enter|ite|(o(de|l(group)?)))|d(d|el|fn|i(r|v)|l|t)|em|f(ieldset|o(nt|rm)|rame(set)?)|h([1-6]|ead|r|tml)|i(frame|mg|n(put|s)|sindex)?|kbd|l(abel|egend|i(nk)?)|m(ap|e(nu|ta))|no(frames|script)|o(bject|l|pt(group|ion))|p(aram|re)?|q|s(amp|cript|elect|mall|pan|t(r(ike|ong)|yle)|u(b|p))|t(able|body|d|extarea|foot|h|itle|r|t)|u(l)?|var))(\\s(?\u003Cattr\u003E.+?))*\u003E",
        "title": "Test"
    },
    {
        "description": "Used to validate Credit Card numbers, Checks if it contains 16 numbers in groups of 4 separated by -, ,or nothing",
        "matches": [
            "1111-2323-2312-3434",
            "1234343425262837",
            "1111 2323 2312 3434"
        ],
        "nonMatches": [
            "1111 2323 2312-3434",
            "34323423",
            "1111-2323-23122-3434"
        ],
        "pattern": "^(\\d{4}-){3}\\d{4}$|^(\\d{4} ){3}\\d{4}$|^\\d{16}$",
        "title": "Test"
    },
    {
        "description": "Matches a Julian date in the format YYDDD. Two digit year followed by a number from 1 - 366 indicating the day of the year.",
        "matches": [
            "99366",
            "00001"
        ],
        "nonMatches": [
            "74000",
            "04367"
        ],
        "pattern": "^([0-9]{2})(00[1-9]|0[1-9][0-9]|[1-2][0-9][0-9]|3[0-5][0-9]|36[0-6])$",
        "title": "Test"
    },
    {
        "description": "This regex validates U.S. social security numbers, within the range of numbers that have been currently allocated.",
        "matches": [
            "078-05-1120",
            "078 05 1120",
            "078051120"
        ],
        "nonMatches": [
            "987-65-4320",
            "000-00-0000",
            "(555) 555-5555"
        ],
        "pattern": "^(?!000)([0-6]\\d{2}|7([0-6]\\d|7[012]))([ -]?)(?!00)\\d\\d\\3(?!0000)\\d{4}$",
        "title": "Test"
    },
    {
        "description": "Validates a UNC to conform to \\\\server\\service Must have a \"\\\\\" at the start Server may contain alpha/numeric/underscore/dash, Followed by another single \"\\\" Service may contain alpha/numeric/underscore/dash/$/space Note: Service may not start nor end with a space Service may only contain one $, and only at the end No additional \"\\\" may follow afterwards",
        "matches": [
            "\\\\server\\service",
            "\\\\server\\my service",
            "\\\\serv_001\\service$"
        ],
        "nonMatches": [
            "\\\\my server\\service",
            "\\\\server\\ service",
            "\\\\server$\\service"
        ],
        "pattern": "^\\\\{2}[\\w-]+\\\\(([\\w-][\\w-\\s]*[\\w-]+[$$]?$)|([\\w-][$$]?$))",
        "title": "Test"
    },
    {
        "description": "Regular expression for validating a decimal IP address. Matches 4 groups of from 1 to 3 digits, where each group of digits ranges from 0 to 255 in value. Groups of digits must be separated by a single period (.) with no other formatting characters present. Uses conditional regex with lookahead syntax to prevent a match on a period following the final group of digits.",
        "matches": [
            "217.6.9.89",
            "0.0.0.0",
            "255.255.255.255"
        ],
        "nonMatches": [
            "256.0.0.0",
            "0127.3",
            "217.6.9.89."
        ],
        "pattern": "^(?:(?:25[0-5]|2[0-4]\\d|[01]\\d\\d|\\d?\\d)(?(?=\\.?\\d)\\.)){4}$",
        "title": "Test"
    },
    {
        "description": "To detect non-alphanumeric characters (for new username/password validation, for instance): monkey(AT)greyledge.net 14-Oct-2003 11:26",
        "matches": [
            "!@#$",
            "%^&*",
            "\u0027><?.,\""
        ],
        "nonMatches": [
            "ABC123abc",
            "abc123ABC",
            "abc0132ABC"
        ],
        "pattern": "[^A-Za-z0-9]",
        "title": "Test"
    },
    {
        "description": "This expression will help match Quebec\u0027s postal codes.",
        "matches": [
            "h2j-3c4",
            "H2J 3C4",
            "H2J-3c4"
        ],
        "nonMatches": [
            "H2J_3C4",
            "H213C4",
            "123456"
        ],
        "pattern": "^[a-zA-Z]{1}[0-9]{1}[a-zA-Z]{1}(\\-| |){1}[0-9]{1}[a-zA-Z]{1}[0-9]{1}$",
        "title": "Test"
    },
    {
        "description": "validates numbers, with or without decimal places, and comma 1000 separators.",
        "matches": [
            "9999999",
            "99999.99999",
            "99,999,999.9999"
        ],
        "nonMatches": [
            "9999.",
            "9,99,99999.999",
            "999.9999.9999"
        ],
        "pattern": "^(((\\d{1,3})(,\\d{3})*)|(\\d+))(.\\d+)?$",
        "title": "Test"
    },
    {
        "description": "Date validation in the dd/mm/yyyy format for years 1000+ (i.e 999 or 0999 not matching) and taking february leap years into account.",
        "matches": [
            "12/12/2003",
            "29-02-2004",
            "31-03-1980"
        ],
        "nonMatches": [
            "29/02/2003",
            "31-04-2002",
            "10-10-0999"
        ],
        "pattern": "((([0][1-9]|[12][\\d])|[3][01])[-/]([0][13578]|[1][02])[-/][1-9]\\d\\d\\d)|((([0][1-9]|[12][\\d])|[3][0])[-/]([0][13456789]|[1][012])[-/][1-9]\\d\\d\\d)|(([0][1-9]|[12][\\d])[-/][0][2][-/][1-9]\\d([02468][048]|[13579][26]))|(([0][1-9]|[12][0-8])[-/][0][2][-/][1-9]\\d\\d\\d)",
        "title": "Test"
    },
    {
        "description": "This regex can be used to restrict passwords to a length of 8 to 20 aplhanumeric characters and select special characters. The password also can not start with a digit, underscore or special character and must contain at least one digit.",
        "matches": [
            "password1",
            "pa$$word2",
            "pa!@#$%3"
        ],
        "nonMatches": [
            "password",
            "1stpassword",
            "$password#"
        ],
        "pattern": "^(?=[^\\d_].*?\\d)\\w(\\w|[!@#$%]){7,20}",
        "title": "Test"
    },
    {
        "description": "YYYY/MM/DD hh:mm:ss format DateTime Regex. This regex will validate a date, time or a datetime. It will also capture the date fields and the time. Dates are in the YYYY/MM/DD format and validated for months, number of days in a month and leap years (29/2) Date field can be separated by matched periods(.), dashes(-) or forward slashes(/) Time is either 12 hour AM/PM format (hh:mm:ss AM), where minutes and seconds are optional. AM or PM required. or 24 hour military format (hh:mm:ss), from 00:00:00 to 23:59:59, where hours and minutes fields are required, including leading 0 for hours less than 10. Please refer to http://blogs.regexadvice.com/mash/archive/2004/04/23/1021.aspx for additional info Datetime is the above date and time formats separated by a space, with the date first (YYYY/MM/DD hh:mm:ss) !IMPORTANT NOTE: your regex engine must support lookbehinds and named groups to use this expression",
        "matches": [
            "12:30 PM",
            "2004-02-29",
            "2004/3/31 02:31:35 AM"
        ],
        "nonMatches": [
            "2:00",
            "2200.2.29",
            "0000/00/00 00:00:00 AM"
        ],
        "pattern": "^(?ni:(?=\\d)((?\u0027year\u0027((1[6-9])|([2-9]\\d))\\d\\d)(?\u0027sep\u0027[/.-])(?\u0027month\u00270?[1-9]|1[012])\\2(?\u0027day\u0027((?\u003C!(\\2((0?[2469])|11)\\2))31)|(?\u003C!\\2(0?2)\\2)(29|30)|((?\u003C=((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|(16|[2468][048]|[3579][26])00)\\2\\3\\2)29)|((0?[1-9])|(1\\d)|(2[0-8])))(?:(?=\\x20\\d)\\x20|$))?((?\u003Ctime\u003E((0?[1-9]|1[012])(:[0-5]\\d){0,2}(\\x20[AP]M))|([01]\\d|2[0-3])(:[0-5]\\d){1,2}))?)$",
        "title": "Test"
    },
    {
        "description": "UK mobile phone number, with optional +44 national code. Allows optional brackets and spaces at appropriate positions.",
        "matches": [
            "07222 555555",
            "(07222) 555555",
            "+44 7222 555 555"
        ],
        "nonMatches": [
            "7222 555555",
            "+44 07222 555555",
            "(+447222) 555555"
        ],
        "pattern": "^(\\+44\\s?7\\d{3}|\\(?07\\d{3}\\)?)\\s?\\d{3}\\s?\\d{3}$",
        "title": "Test"
    },
    {
        "description": "Matches hexadecimal values like in c-sourcecode exists.",
        "matches": [
            "0x0ffe"
        ],
        "nonMatches": [
            "x0ffe"
        ],
        "pattern": "[0][x][0-9a-fA-F]+",
        "title": "Test"
    },
    {
        "description": "Validate a comma delimited string of integer between 1 and 99999999 (change {0,7} to whatever you need). No zero leading.",
        "matches": [
            "1,2,3455,12345678",
            "23045,34678,2892",
            "1,2,99999999"
        ],
        "nonMatches": [
            "01,234,567",
            "123,0445,3434,",
            "121,,1212,,12,"
        ],
        "pattern": "^([1-9]{1}[0-9]{0,7})+((,[1-9]{1}[0-9]{0,7}){0,1})+$",
        "title": "Test"
    },
    {
        "description": "Alphanumeric expression with spaces",
        "matches": [
            "123asd",
            "111 ee11e",
            "223 eeddd23"
        ],
        "nonMatches": [
            "12\u0027 ggg",
            "<>dfdg 444",
            "dfgdfg/dfgd"
        ],
        "pattern": "^[a-zA-Z0-9\\s]+$",
        "title": "Test"
    },
    {
        "description": "This regex validates Currency. The base monetary unit (ex. US dollar) followed by option two digit cent denomination. Base unit can\u0027t have leading zero. Comma\u0027s are optional on base units. Note: Your regex engine must support the \\p character class to use this. For example this will work in .net but not javascript which doesn\u0027t support \\p Also the \u0026#162; is removed from the match by force. Any other cent symbol would need to be added to the exclude to not match.",
        "matches": [
            "$1,501.13",
            "\u0026#163;215",
            "\u20AC4.93"
        ],
        "nonMatches": [
            "01.00",
            "$.00",
            "\u0026#162;50"
        ],
        "pattern": "^(?!\\u00a2) #Don\u0027t allow cent symbol \\p{Sc}? #optional unicode currency symbols (?!0,?\\d) #don\u0027t allow leading zero if 1 or more unit (\\d{1,3} # 1 to 3 digits (\\,\\d{3})* # if the is a comma it must be followed by 3 digits |(\\d+)) # more than 3 digit with no comma separator (\\.\\d{2})?$ # option cents",
        "title": "Test"
    },
    {
        "description": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-1212, etc. You can add/remove formatting options to meet your needs.",
        "matches": [
            "5305551212",
            "(530) 555-1212",
            "530-555-1212"
        ],
        "nonMatches": [
            "0010011212",
            "1991991212",
            "123) not-good"
        ],
        "pattern": "^(?:\\([2-9]\\d{2}\\)\\ ?|[2-9]\\d{2}(?:\\-?|\\ ?))[2-9]\\d{2}[- ]?\\d{4}$",
        "title": "Test"
    },
    {
        "description": "Captures Submatches, problem:domainname length can be longer than 64 chars, because every [a-zA-Z0-9][\\.\\-_] is only countet as one char.",
        "matches": [
            "abc@def.gh",
            "a+b_c@d-e_f.gh",
            "abc@def.ghijkl"
        ],
        "nonMatches": [
            "__@__.__",
            "-a-@-b-.cd",
            "a--b@c__d.ef"
        ],
        "pattern": "^((?:(?:(?:[a-zA-Z0-9][\\.\\-\\+_]?)*)[a-zA-Z0-9])+)\\@((?:(?:(?:[a-zA-Z0-9][\\.\\-_]?){0,62})[a-zA-Z0-9])+)\\.([a-zA-Z0-9]{2,6})$",
        "title": "Test"
    },
    {
        "description": "DateTime Validator. This RE validates both dates and/or times patterns. Days in Feb. are also validated for Leap years. Dates: in dd/mm/yyyy or d/m/yy format between 1/1/1600 - 31/12/9999. Leading zeroes are optional. Date separators can be either matching dashes(-), slashes(/) or periods(.) Times: in the hh:MM:ss AM/PM 12 hour format (12:00 AM - 11:59:59 PM) or hh:MM:ss military time format (00:00:00 - 23:59:59). The 12 hour time format: 1) may have a leading zero for the hour. 2) Minutes and seconds are optional for the 12 hour format 3) AM or PM is required and case sensitive. Military time 1) must have a leading zero for all hours less than 10. 2) Minutes are manditory. 3) seconds are optional. Datetimes: combination of the above formats. A date first then a time separated by a space. ex) dd/mm/yyyy hh:MM:ss This RE is an variation of one of my other Datetime (mm/dd/yyyy) validator already in this library http://www.regexlib.com/REDetails.aspx?regexp_id=369, so the same rules for leap year apply. All 4 digit year and all two digit years except 00, which might not be a leap year.",
        "matches": [
            "31/12/2003 11:59:59 PM",
            "29-2-2004",
            "01:45:02"
        ],
        "nonMatches": [
            "12/31/2003",
            "29.02.2005",
            "13:30 PM"
        ],
        "pattern": "^(?=\\d)(?:(?:31(?!.(?:0?[2469]|11))|(?:30|29)(?!.0?2)|29(?=.0?2.(?:(?:(?:1[6-9]|[2-9]\\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00)))(?:\\x20|$))|(?:2[0-8]|1\\d|0?[1-9]))([-./])(?:1[012]|0?[1-9])\\1(?:1[6-9]|[2-9]\\d)?\\d\\d(?:(?=\\x20\\d)\\x20|$))?(((0?[1-9]|1[012])(:[0-5]\\d){0,2}(\\x20[AP]M))|([01]\\d|2[0-3])(:[0-5]\\d){1,2})?$",
        "title": "Test"
    },
    {
        "description": "Wrote this to accept either decimals or zero, but not whole numbers - for a particular project...",
        "matches": [
            "1.1",
            "12.12",
            "0"
        ],
        "nonMatches": [
            ".",
            ".123",
            "123."
        ],
        "pattern": "(^([0-9]+[.]+[0-9]+)|(0)$)",
        "title": "Test"
    },
    {
        "description": "This regex can be used to split the values of a comma delimitted list. List elements may be quoted, unquoted or empty. Commas inside a pair of quotation marks are not matched.",
        "matches": [
            "1,,3\u0022\u0022but, wait\u0022,5",
            "1,2,3"
        ],
        "nonMatches": [
            "\u0022Test\u0022\u0022a,b,c,d\u0022\u0022ing\u0022",
            "no comma",
            "semi; colon"
        ],
        "pattern": ",(?!(?\u003C=(?:^|,)\\s*\\x22(?:[^\\x22]|\\x22\\x22|\\\\\\x22)*,)(?:[^\\x22]|\\x22\\x22|\\\\\\x22)*\\x22\\s*(?:,|$))",
        "title": "Test"
    },
    {
        "description": "Version 1.3.0: I needed a regexp to validate URL\u0027s without the ht(f)tp(s):// and include North American domains (like .us and .ca) and there didn\u0027t seem to be one available...so I created one. It will also work with ASP QueryStrings and anchor URL\u0027s. If you have a problem with the expression or have any suggestions to improve, please write me and let me know. Added .uk domain and expression now allows for URLs that contain JSP session IDs. 4/14/04 - added ability to include URLs that start with server names.",
        "matches": [
            "www.blah.com:8103",
            "www.blah.com/blah.asp?sort=ASC",
            "www.blah.com/blah.htm#blah"
        ],
        "nonMatches": [
            "www.state.ga",
            "http://www.blah.ru"
        ],
        "pattern": "^(((ht|f)tp(s?))\\://)?(www.|[a-zA-Z].)[a-zA-Z0-9\\-\\.]+\\.(com|edu|gov|mil|net|org|biz|info|name|museum|us|ca|uk)(\\:[0-9]+)*(/($|[a-zA-Z0-9\\.\\,\\;\\?\\\u0027\\\\\\+&%\\$#\\=~_\\-]+))*$",
        "title": "Test"
    },
    {
        "description": "currency format that allows optional $, optional \"-\"(MinusSignNegative) OR \"()\" (ParenNegative) but not both, optional cents, and optional commas separating thousands. Minus sign can be before or after $, but parens must be outside the $. UPDATED: now fails to match a \"$\" without any further numbers",
        "matches": [
            "($4,000.00)",
            "-$4000.00",
            "-$400.00"
        ],
        "nonMatches": [
            "4,00.000",
            "abc",
            "$"
        ],
        "pattern": "^\\$?\\-?([1-9]{1}[0-9]{0,2}(\\,\\d{3})*(\\.\\d{0,2})?|[1-9]{1}\\d{0,}(\\.\\d{0,2})?|0(\\.\\d{0,2})?|(\\.\\d{1,2}))$|^\\-?\\$?([1-9]{1}\\d{0,2}(\\,\\d{3})*(\\.\\d{0,2})?|[1-9]{1}\\d{0,}(\\.\\d{0,2})?|0(\\.\\d{0,2})?|(\\.\\d{1,2}))$|^\\(\\$?([1-9]{1}\\d{0,2}(\\,\\d{3})*(\\.\\d{0,2})?|[1-9]{1}\\d{0,}(\\.\\d{0,2})?|0(\\.\\d{0,2})?|(\\.\\d{1,2}))\\)$",
        "title": "Test"
    },
    {
        "description": "I needed a regular expression to break urls into labled parts. This is what I came up with. Got a few ideas from regexlib.com and from this msdn article. http://msdn.microsoft.com/library/default.asp?url=/library/en-us/script56/html/reconbackreferences.asp http://www.domain.com/folder does return a match but will not grab the folder name unless there is \"/\" at the end. http://www.domain.com/folder/",
        "matches": [
            "https://192.168.0.2:80/users/~fname.lname/file.ext",
            "ftp://user1:pwd@www.domain.com",
            "http://www.dom"
        ],
        "nonMatches": [
            "www.domain.com",
            "user1:pwd@domain.com",
            "192.168.0.2/folder/file.ext"
        ],
        "pattern": "(?:(?\u003Cprotocol\u003Ehttp(?:s?)|ftp)(?:\\:\\/\\/)) (?:(?\u003Cusrpwd\u003E\\w+\\:\\w+)(?:\\@))? (?\u003Cdomain\u003E[^/\\r\\n\\:]+)? (?\u003Cport\u003E\\:\\d+)? (?\u003Cpath\u003E(?:\\/.*)*\\/)? (?\u003Cfilename\u003E.*?\\.(?\u003Cext\u003E\\w{2,4}))? (?\u003Cqrystr\u003E\\??(?:\\w+\\=[^\\#]+)(?:\\\u0026?\\w+\\=\\w+)*)* (?\u003Cbkmrk\u003E\\#.*)?",
        "title": "Test"
    },
    {
        "description": "This expression will return the first letter of each word in a string. Best used if you need to get initials from a name. \"James Kramer\" = \"J K\" & \"Sir Richard Branson\" = \"S R B\" & \"33 yoYo 654 ma\" = \"y m\"",
        "matches": [
            "James Kramer",
            "Sir Richard Branson",
            "33 yoYo 654 ma"
        ],
        "nonMatches": [
            "33 66 4ju"
        ],
        "pattern": "(^[A-Za-z])|(\\s)([A-Za-z])",
        "title": "Test"
    },
    {
        "description": "Validates windows path and invalidates UNC path",
        "matches": [
            "c:\\34\\445\\546\\3.htm",
            "C:\\"
        ],
        "nonMatches": [
            "\\\\qaz",
            "c:\\Ram<\\",
            "C: or c:\\\\ or \\\\"
        ],
        "pattern": "^([a-zA-Z]\\:) (\\\\{1}| ((\\\\{1}) [^\\\\] ([^/:*?<>\"|]*(?<![ ])))+)$",
        "title": "Test"
    },
    {
        "description": "Brazilian CEP - (XXXXX-XXX)",
        "matches": [
            "22251-050",
            "22251-888",
            "22251-051"
        ],
        "nonMatches": [
            "22251-8050",
            "22251A050",
            "22251/050"
        ],
        "pattern": "(^\\d{5}\\-\\d{3}$)",
        "title": "Test"
    },
    {
        "description": "Brazilian CNPJ",
        "matches": [
            "01.004.717/0001-74"
        ],
        "nonMatches": [
            "01.004.717000174"
        ],
        "pattern": "(^[0-9]{2,3}\\.[0-9]{3}\\.[0-9]{3}\\/[0-9]{4}-[0-9]{2}$)",
        "title": "Test"
    },
    {
        "description": "Matches files extension",
        "matches": [
            "file.jpg",
            "file.c",
            "file.gif"
        ],
        "nonMatches": [
            "file.34"
        ],
        "pattern": "(?!\\.)[a-z]{1,4}$",
        "title": "Test"
    },
    {
        "description": "Match the VB Language specification BNF for DateTime literal. http://msdn.microsoft.com/library/en-us/vbls7/html/vblrfvbspec2_4_6.asp?frame=true DateLiteral ::= # [ Whitespace+ ] DateOrTime [ Whitespace+ ] # DateOrTime ::= DateValue Whitespace+ TimeValue | DateValue | TimeValue DateValue ::= MonthValue / DayValue / YearValue | MonthValue \u2013 DayValue - YearValue TimeValue ::= HourValue : MinuteValue [ : SecondValue ] [ WhiteSpace+ ] [ AMPM ] MonthValue ::= IntLiteral DayValue ::= IntLiteral YearValue ::= IntLiteral HourValue ::= IntLiteral MinuteValue ::= IntLiteral SecondValue ::= IntLiteral AMPM ::= AM | PM",
        "matches": [
            "# 8/23/1970 3:45:39AM #",
            "# 8/23/1970 #"
        ],
        "nonMatches": [
            "##",
            "# 23/8/1970 #"
        ],
        "pattern": "(?\u0027DateLiteral\u0027 (?# Per the VB Spec : DateLiteral ::= \u0027#\u0027 [ Whitespace+ ] DateOrTime [ Whitespace+ ] \u0027#\u0027 ) \\#\\s* (?\u0027DateOrTime\u0027 (?# DateOrTime ::= DateValue Whitespace+ TimeValue | DateValue | TimeValue ) (?\u0027DateValue\u0027 (?# DateValue ::= Whitespace+ TimeValue | DateValue | TimeValue ) ( (?# DateValue ::= MonthValue / DayValue / YearValue | MonthValue - DayValue - YearValue ) (?\u0027Month\u0027(0?[1-9])|1[0-2]) (?# Month 01 - 12 ) (?\u0027Sep\u0027[-/]) (?# Date separator \u0027-\u0027 or \u0027/\u0027 ) (?\u0027Day\u00270?[1-9]|[12]\\d|3[01]) (?# Day 01 - 31 ) \\k\u0027Sep\u0027 (?# whatever date separator was previously matched ) (?\u0027Year\u0027\\d{1,4}) \\s+ (?# TimeValue ::= HourValue : MinuteValue [ : SecondValue ] [ WhiteSpace+ ] [ AMPM ] ) (?\u0027HourValue\u0027(0?[1-9])|1[0-9]|2[0-4]) (?# Hour 01 - 24 ) [:] (?\u0027MinuteValue\u00270?[1-9]|[1-5]\\d|60) (?# Minute 01 - 60 ) [:] (?\u0027SecondValue\u0027:0?[1-9]|[1-5]\\d|60)? (?# Optional Minute :01 - :60 ) \\s* (?\u0027AMPM\u0027[AP]M)? ) | ( (?# DateValue ::= MonthValue / DayValue / YearValue | MonthValue - DayValue - YearValue ) (?\u0027Month\u0027(0?[1-9])|1[0-2]) (?# Month 01 - 12 ) (?\u0027Sep\u0027[-/]) (?# Date separator \u0027-\u0027 or \u0027/\u0027 ) (?\u0027Day\u00270?[1-9]|[12]\\d|3[01]) (?# Month 01 - 31 ) \\k\u0027Sep\u0027 (?# whatever date separator was previously matched ) (?\u0027Year\u0027\\d{4}) ) | ( (?# TimeValue ::= HourValue : MinuteValue [ : SecondValue ] [ WhiteSpace+ ] [ AMPM ] ) (?\u0027HourValue\u0027(0?[1-9])|1[0-9]|2[0-4]) (?# Hour 01 - 24 ) [:] (?\u0027MinuteValue\u00270?[1-9]|[1-5]\\d|60) (?# Minute 01 - 60 ) [:] (?\u0027SecondValue\u0027:0?[1-9]|[1-5]\\d|60)? (?# Optional Minute :01 - :60 ) \\s* (?\u0027AMPM\u0027[AP]M)? ) ) ) \\s*\\# )",
        "title": "Test"
    },
    {
        "description": "This regexp tests Argentinian CUIT / CUIT numbers. Esta expresi\u0026#243;n regular sirve para validar n\u0026#250;meros de CUIT / CUIL de Argentina.",
        "matches": [
            "20-28564123-9",
            "21-89656598-7",
            "20-89653265-8"
        ],
        "nonMatches": [
            "202-56899-1",
            "1-23265865-9",
            "12548965232"
        ],
        "pattern": "^[0-9]{2}-[0-9]{8}-[0-9]$",
        "title": "Test"
    },
    {
        "description": "Check italian fiscal code (codice fiscale) with \"OMOCODIA\" control",
        "matches": [
            "BTTNDR78R06A79QU"
        ],
        "nonMatches": [
            "BTTNDR78R06A79AU"
        ],
        "pattern": "^[A-Za-z]{6}[0-9LMNPQRSTUV]{2}[A-Za-z]{1}[0-9LMNPQRSTUV]{2}[A-Za-z]{1}[0-9LMNPQRSTUV]{3}[A -Za-z]{1}$",
        "title": "Test"
    },
    {
        "description": "I wrote up this regular expression to fetch the href attribute found in <a> tags as well as a few other HTML tags.",
        "matches": [
            "href=\u0022www.yahoo.com\u0022",
            "href=\u0022http://localhost/blah/\u0022",
            "href=\u0022eek\u0022"
        ],
        "nonMatches": [
            "href=\u0022\u0022",
            "href=eek",
            "href=\u0022bad example\u0022"
        ],
        "pattern": "href=[\\\u0022\\\u0027](http:\\/\\/|\\.\\/|\\/)?\\w+(\\.\\w+)*(\\/\\w+(\\.\\w+)?)*(\\/|\\?\\w*=\\w*(\u0026\\w*=\\w*)*)?[\\\u0022\\\u0027]",
        "title": "Test"
    },
    {
        "description": "It matches .jpg files. It allows for a dot in the path. A dot may occur in such directories as: C:\\Documents and Settings\\roman.lukyanenko\\Desktop\\stuff\\b_card2.txt or C:\\Windows\\Microsoft.NET etc",
        "matches": [
            "C:\\Documents and Settings\\roman.lukyanenko\\Desktop\\stuff\\b_card2.txt"
        ],
        "nonMatches": [
            "C:\\file.doc"
        ],
        "pattern": "^(([a-zA-Z]:)|(\\\\{2}\\w+)\\$?)(\\\\(\\w[\\w ]*.*))+\\.(txt|TXT)$",
        "title": "Test"
    },
    {
        "description": "I know its simple, yet there was no Russian postal code regular expression on the RegExLib. Just in case some needs to know the format.",
        "matches": [
            "150016"
        ],
        "nonMatches": [
            "qqww"
        ],
        "pattern": "^[0-9]{6}",
        "title": "Test"
    },
    {
        "description": "Matches the copyright symbol (&copy;). Pretty simple, yet I dont think existed on RegExLib before.",
        "matches": [
            "\u00A9"
        ],
        "nonMatches": [
            "anything"
        ],
        "pattern": "\\xA9",
        "title": "Test"
    },
    {
        "description": "This regular expression can be used to parse a comma delimited string. Leading whitespaces (at the beginning of the entire string) and ending commas are not acceptable. Any combination of letters and numbers with zero or one white space between them are acceptable. Note: To change the delimiter, simply replace the comma in the square brackets to the delimiter of choice.",
        "matches": [
            "123, 4567, 8901",
            "abc, defghi, jklmn",
            "abc123"
        ],
        "nonMatches": [
            "abc123",
            "abc123,",
            ",abc123"
        ],
        "pattern": "^([A-Za-z0-9]\\s?)+([,]\\s?([A-Za-z0-9]\\s?)+)*$",
        "title": "Test"
    },
    {
        "description": "Spam trap Catches many and many way to write viagra (replacing letters with similar chars, spacing chars with one space, etc).",
        "matches": [
            "Viagra",
            "v1@G R /\\",
            "\\/iagr@"
        ],
        "nonMatches": [
            "viaagra",
            "vi agra",
            "v1 gra"
        ],
        "pattern": "[v,V,(\\\\/)](\\W|)[i,I,1,l,L](\\W|)[a,A,@,(\\/\\\\)](\\W|)[g,G](\\W|)[r,R](\\W|)[a,A,@,(\\/\\\\))]",
        "title": "Test"
    },
    {
        "description": "regex which matches UAE mobile phone numbers. Its capable to take inputs +97150 3827741, +97-150-3827741, +97150 - 3827741,050 3827741, 050 - 3827741 Enjoy REGEXXXXXXX!!!!!!!",
        "matches": [
            "+97150 3827741",
            "0503827741",
            "050-3827741"
        ],
        "nonMatches": [
            "040 3827741",
            "05 3827741",
            "050_______spaces_______3827741"
        ],
        "pattern": "^(\\+97[\\s]{0,1}[\\-]{0,1}[\\s]{0,1}1|0)50[\\s]{0,1}[\\-]{0,1}[\\s]{0,1}[1-9]{1}[0-9]{6}$",
        "title": "Test"
    },
    {
        "description": "The regex matches the UAE land phone numbers. Checks the area codes[04,02,06...etc] strictly. Force user to input phone numbers in strict manner(it take input 04 3452488, but not 04______spaces_______3452488)",
        "matches": [
            "04 3452488",
            "04 -3452488",
            "04 - 3452499"
        ],
        "nonMatches": [
            "01 -3452488",
            "04 34524888",
            "08 3452488"
        ],
        "pattern": "^0[234679]{1}[\\s]{0,1}[\\-]{0,1}[\\s]{0,1}[1-9]{1}[0-9]{6}$",
        "title": "Test"
    },
    {
        "description": "Letter Grade scores A-F + and -",
        "matches": [
            "a+",
            "A",
            "F-"
        ],
        "nonMatches": [
            "z",
            "6",
            "D +"
        ],
        "pattern": "(^[a-fA-F]+[+-]?$)",
        "title": "Test"
    },
    {
        "description": "match for 0 - 65535",
        "matches": [
            "0",
            "65535",
            "59999"
        ],
        "nonMatches": [
            "123456",
            "69999",
            "65599"
        ],
        "pattern": "^([0-5]?\\d?\\d?\\d?\\d|6[0-4]\\d\\d\\d|65[0-4]\\d\\d|655[0-2]\\d|6553[0-5])$",
        "title": "Test"
    },
    {
        "description": "DD.MM.YY or DD.MM.YYYY separator could be on choice \u0027.\u0027\u0027/\u0027 or \u0027-\u0027 leap years compatible, 00 is treated as year 2000.",
        "matches": [
            "29.2.04",
            "29/02-2004",
            "3.4.05"
        ],
        "nonMatches": [
            "29.2.03",
            "2902.2004",
            "12.31.1975"
        ],
        "pattern": "^(((0?[1-9]|[12]\\d|3[01])[\\.\\-\\/](0?[13578]|1[02])[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}))|((0?[1-9]|[12]\\d|30)[\\.\\-\\/](0?[13456789]|1[012])[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}))|((0?[1-9]|1\\d|2[0-8])[\\.\\-\\/]0?2[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}))|(29[\\.\\-\\/]0?2[\\.\\-\\/]((1[6-9]|[2-9]\\d)?(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)|00)))$",
        "title": "Test"
    },
    {
        "description": "This regexp has been posted specialy for \"Mike O Shea\" as he requested a mono digit year validation. matches DD/MM/Y or DD/MM/YYYY or D/M/Y or DD/M/YYYY Leap years treated. (Italian style with tomato) Years 0-9 equal years 2000 to 2009 for leap years",
        "matches": [
            "1/1/2005",
            "29/02/12",
            "29/02/2400"
        ],
        "nonMatches": [
            "29/2/2005",
            "29/02/13",
            "29/02/2200"
        ],
        "pattern": "^(((0?[1-9]|[12]\\d|3[01])[\\.\\-\\/](0?[13578]|1[02])[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}|\\d))|((0?[1-9]|[12]\\d|30)[\\.\\-\\/](0?[13456789]|1[012])[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}|\\d))|((0?[1-9]|1\\d|2[0-8])[\\.\\-\\/]0?2[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}|\\d))|(29[\\.\\-\\/]0?2[\\.\\-\\/]((1[6-9]|[2-9]\\d)?(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)|00|[048])))$",
        "title": "Test"
    },
    {
        "description": "This is derived from Steven Smith\u0027s Integer expression (http://www.regexlib.com/REDetails.aspx?regexp_id=51). The only difference is that this does not accept blanks. Written by Jason N. Gaylord.",
        "matches": [
            "2",
            "50",
            "0"
        ],
        "nonMatches": [
            "-15",
            "1.2"
        ],
        "pattern": "^\\d+$",
        "title": "Test"
    },
    {
        "description": "DD/MM/YY D/M/YY DD/MM/YYYY",
        "matches": [
            "15/05/2004",
            "15/5/04"
        ],
        "nonMatches": [
            "15/45/04"
        ],
        "pattern": "(?<Day>[1-9]|[0-3][0-9])/(?<Month>[01][012]|[1-9]|0[1-9])/(?<Year>[12]\\d{3}|\\d{2})",
        "title": "Test"
    },
    {
        "description": "telphone number check.",
        "matches": [
            "0833-1234567-8888",
            "(0833)1234567-8888",
            "12345678"
        ],
        "nonMatches": [
            "ceocio",
            "!@$@#$"
        ],
        "pattern": "((\\(\\d{3,4}\\)|\\d{3,4}-)\\d{4,9}(-\\d{1,5}|\\d{0}))|(\\d{4,12})",
        "title": "Test"
    },
    {
        "description": "Specifier Format of Guid Values that this RegEx supports: 32 digits: [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx] 32 digits separated by hyphens: [xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx] 32 digits separated by hyphens, enclosed in brackets: [{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}] 32 digits separated by hyphens, enclosed in parentheses: [(xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)]",
        "matches": [
            "914D226A-2F5B-4944-934D-96BBE6571977",
            "{914D226A-2F5B-4944-934D-96BBE6571977}"
        ],
        "nonMatches": [
            "914D226A-2F5B-4944-XXXX-96BBE6571977",
            "{914D226A-2F5B-4944-XXXX-96BBE6571977}"
        ],
        "pattern": "^[{|\\(]?[0-9a-fA-F]{8}[-]?([0-9a-fA-F]{4}[-]?){3}[0-9a-fA-F]{12}[\\)|}]?$",
        "title": "Test"
    },
    {
        "description": "Matches the \u2122 symbol. Pretty simple, yet I dont think existed on RegExLib before.",
        "matches": [
            "\u2122"
        ],
        "nonMatches": [
            "anything else"
        ],
        "pattern": "\\u2122",
        "title": "Test"
    },
    {
        "description": "Matches the registered trademark (\u0026#174;). Pretty simple, yet I dont think existed on RegExLib before.",
        "matches": [
            "\u00AE"
        ],
        "nonMatches": [
            "anything else"
        ],
        "pattern": "\\u00AE",
        "title": "Test"
    },
    {
        "description": "Matches the British Pound symbol. Pretty simple, yet I dont think existed on RegExLib before.",
        "matches": [
            "\u00A3"
        ],
        "nonMatches": [
            "anything else"
        ],
        "pattern": "\\u00A3",
        "title": "Test"
    },
    {
        "description": "Matches the Euro sign. Pretty simple, yet I dont think existed on RegExLib before.",
        "matches": [
            "\u20AC"
        ],
        "nonMatches": [
            "anything else"
        ],
        "pattern": "\\u20AC",
        "title": "Test"
    },
    {
        "description": "Matches the Yen sign. Pretty simple, yet I dont think existed on RegExLib before.",
        "matches": [
            "\u00A5"
        ],
        "nonMatches": [
            "anything else"
        ],
        "pattern": "\\u00A5",
        "title": "Test"
    },
    {
        "description": "Matches infinity symbol. Pretty simple, yet I dont think existed on RegExLib before.",
        "matches": [
            "8"
        ],
        "nonMatches": [
            "anything else"
        ],
        "pattern": "\\u221E",
        "title": "Test"
    },
    {
        "description": "A co-worker needed a regex to validate time. He could only find patterns that match a 24hour clock. I whipped this expression up to validate a 12hour clock. Hope somebody finds it useful.",
        "matches": [
            "12:00am",
            "01:30pm",
            "4:59"
        ],
        "nonMatches": [
            "15:30",
            "4:78am",
            "00:00"
        ],
        "pattern": "(?\u003CTime\u003E^(?:0?[1-9]:[0-5]|1(?=[012])\\d:[0-5])\\d(?:[ap]m)?)",
        "title": "Test"
    },
    {
        "description": "This allows the formatting of most phone numbers.",
        "matches": [
            "1-800-DISCOVER",
            "(610) 310-5555 x5555",
            "533-1123"
        ],
        "nonMatches": [
            "1 533-1123",
            "553334",
            "66/12343"
        ],
        "pattern": "^(?:(?:[\\+]?(?\u003CCountryCode\u003E[\\d]{1,3}(?:[ ]+|[\\-.])))?[(]?(?\u003CAreaCode\u003E[\\d]{3})[\\-/)]?(?:[ ]+)?)?(?\u003CNumber\u003E[a-zA-Z2-9][a-zA-Z0-9 \\-.]{6,})(?:(?:[ ]+|[xX]|(i:ext[\\.]?)){1,2}(?\u003CExt\u003E[\\d]{1,5}))?$",
        "title": "Test"
    },
    {
        "description": "evaluates dates in the format of DD/MM/YY or DD/MM/YYYY DD & YY - can be of the form: One digit 2 Zero leading 02",
        "matches": [
            "1/3/98",
            "01/03/04"
        ],
        "nonMatches": [
            "15/20/04",
            "1/13/04",
            "12/02/"
        ],
        "pattern": "(?\u003CDay\u003E[0-3][0-9]|[1-9])/(?\u003CMonth\u003E[1-9]|1[0-2]|0[1-9])/(?\u003CYear\u003E[12]\\d{3}|\\d{2})",
        "title": "Test"
    },
    {
        "description": "valid values are du or gu or tu or ds or gs or da or ga or or ta or dq or gq or tq, upper & lowercase",
        "matches": [
            "du",
            "DU",
            "gu"
        ],
        "nonMatches": [
            "99",
            "dx"
        ],
        "pattern": "[du]{2}|[gu]{2}|[tu]{2}|[ds]{2}|[gs]{2}|[da]{2}|[ga]{2}|[ta]{2}|[dq]{2}|[gq]{2}|[tq]{2}|[DU]{2}|[GU]{2}|[TU]{2}|[DS]{2}|[GS]{2}|[DA]{2}|[GA]{2}|[TA]{2}|[DQ]{2}|[GQ]{2}|[TQ]{2}",
        "title": "Test"
    },
    {
        "description": "Matches a md5 hash, simple yet powerful",
        "matches": [
            "790d2cf6ada1937726c17f1ef41ab125"
        ],
        "nonMatches": [
            "790D2CF6ADA1937726C17F1EF41AB125",
            "790d2cf6ada1937726c17f1ef41ab125f6k"
        ],
        "pattern": "^([a-z0-9]{32})$",
        "title": "Test"
    },
    {
        "description": "will match free floating valid protocol + urls in text ... will not touch the ones wrapped in a tag, so that you can auto-link the ones that aren\u0027t :) couple of things to know : 1. if the url is next to a tag this won\u0027t work (eg : <br>http://www.acme.com), the url must either start with a \\s, \\n or any character other than >. 2. the pattern will match the preceding \\s and \\n too, so when you replace put them back in place $1 will either be \\s or \\n, $2 will be the exact match vb usage : set re = New RegExp re.Pattern =\"(\\s|\\n|^)(\\w+://[^\\s\\n]+)\" strResult = re.Replace(strText, \"$1<a href=\u0027$2\u0027 target=\u0027_new\u0027>$2</a>\")",
        "matches": [
            "http://www.acme.com",
            "ftp://ftp.acme.com/hede",
            "gopher://asdfasd.asdfasdf"
        ],
        "nonMatches": [
            "<a href=\"http://acme.com\">http://www.acme.com</a>",
            "<br>http://www.acme."
        ],
        "pattern": "(\\s|\\n|^)(\\w+://[^\\s\\n]+)",
        "title": "Test"
    },
    {
        "description": "This is the Brazilian Date Format. DD/MM/YYYY with the right days per month. Dates >=1900 <=2999.",
        "matches": [
            "29/02/2004",
            "31/01/1900",
            "31/01/2999"
        ],
        "nonMatches": [
            "29/02/2003",
            "12042004",
            "20/04/04"
        ],
        "pattern": "(((0[1-9]|[12][0-9]|3[01])([/])(0[13578]|10|12)([/])([1-2][0,9][0-9][0-9]))|(([0][1-9]|[12][0-9]|30)([/])(0[469]|11)([/])([1-2][0,9][0-9][0-9]))|((0[1-9]|1[0-9]|2[0-8])([/])(02)([/])([1-2][0,9][0-9][0-9]))|((29)(\\.|-|\\/)(02)([/])([02468][048]00))|((29)([/])(02)([/])([13579][26]00))|((29)([/])(02)([/])([0-9][0-9][0][48]))|((29)([/])(02)([/])([0-9][0-9][2468][048]))|((29)([/])(02)([/])([0-9][0-9][13579][26])))",
        "title": "Test"
    },
    {
        "description": "Expression to validate values to fields Decimal 5,2 or 5 numbers. values >=100,00 <=99999,99 100,00=100 5000,00 = 5000",
        "matches": [
            "100,00",
            "100",
            "99999,99"
        ],
        "nonMatches": [
            "99,99",
            "999999",
            "1,00"
        ],
        "pattern": "(^\\d{3,5}\\,\\d{2}$)|(^\\d{3,5}$)",
        "title": "Test"
    },
    {
        "description": "Mathces in format DD-MON-YYYY (hyphen between results). Validates for leap years. Ensures month is in uppercase.",
        "matches": [
            "9-MAY-1981",
            "29-FEB-2004",
            "25-DEC-1999"
        ],
        "nonMatches": [
            "09 MAY 1981",
            "06 Jul 2003"
        ],
        "pattern": "^((31(?! (FEB|APR|JUN|SEP|NOV)))|((30|29)(?! FEB))|(29(?= FEB (((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))|(0?[1-9])|1\\d|2[0-8])-(JAN|FEB|MAR|MAY|APR|JUL|JUN|AUG|OCT|SEP|NOV|DEC)-((1[6-9]|[2-9]\\d)\\d{2})$",
        "title": "Test"
    },
    {
        "description": "Essa express\u0026#227;o \u0026#233; uma valida\u0026#231;\u0026#227;o de data simplicada onde n\u0026#227;o aceita datas com ano inferior a 1900. Interessante pra valida\u0026#231;\u0026#227;o de data de idade, data atual, etc",
        "matches": [
            "25/11/1979",
            "5-12-2004",
            "5 2 1901"
        ],
        "nonMatches": [
            "25/11/1899",
            "9-12-1700",
            "25111979"
        ],
        "pattern": "(0?[1-9]|[12][0-9]|3[01])[/ -](0?[1-9]|1[12])[/ -](19[0-9]{2}|[2][0-9][0-9]{2})",
        "title": "Test"
    },
    {
        "description": "This is an new data Validation to MM/YYYY from 1900 to 2999 this is an validation expression to Client From MOnth/Year.",
        "matches": [
            "01/1900",
            "10/1990",
            "12/2999"
        ],
        "nonMatches": [
            "1/1900",
            "12/1899",
            "01/3000"
        ],
        "pattern": "(((0[123456789]|10|11|12)([/])(([1][9][0-9][0-9])|([2][0-9][0-9][0-9]))))",
        "title": "Test"
    },
    {
        "description": "I searched for a smiley expression but couldn\u0027t find one. This one should find all the usual ways of writing the sad emotion icon.",
        "matches": [
            ":o(",
            ":+<",
            ";-(("
        ],
        "nonMatches": [
            ":)",
            ":/"
        ],
        "pattern": "[:;]{1}[-~+o]?[(<\\[]+",
        "title": "Test"
    },
    {
        "description": "This ist the Expression for a happy smiley. It should find all the usual writings of the emotion icon :)",
        "matches": [
            ":)))))",
            ":+>",
            ":o)"
        ],
        "nonMatches": [
            ";o)",
            ":-("
        ],
        "pattern": "[:]{1}[-~+o]?[)>]+",
        "title": "Test"
    },
    {
        "description": "Matches all positive & negative decimal floating point numbers, to any magnitude. Allows empty string.",
        "matches": [
            "4.4",
            ".4",
            "-.4"
        ],
        "nonMatches": [
            ".",
            "...",
            "zero"
        ],
        "pattern": "^-?\\d*(\\.\\d+)?$",
        "title": "Test"
    },
    {
        "description": "Word HTML cleanup code. Use this expression to get rid of most of the stuff that Word adds to an HTML document such as: lots of span elements, font-family and font-size style attributes, class attributes, a whole bunch of if-then statements. Use this expression in a regex.replace(originalHtml, regExpr, \"\").",
        "matches": [
            "<span>"
        ],
        "nonMatches": [
            "<table>"
        ],
        "pattern": "(?s)( class=\\w+(?=([^<]*>)))|(<!--\\[if.*?<!\\[endif\\]-->)|(<!\\[if !\\w+\\]>)|(<!\\[endif\\]>)|(<o:p>[^<]*</o:p>)|(<span[^>]*>)|(</span>)|(font-family:[^>]*[;\u0027])|(font-size:[^>]*[;\u0027])(?-s)",
        "title": "Test"
    },
    {
        "description": "Cheap and cheerful URL checker. Requires a http/https/ftp at the start and will then allow anything starting with at least a <something>.<something>.<something> then valid characters separated by dots and slashes",
        "matches": [
            "http://www.thedaddy.org",
            "http://forum.thedaddy.org/index.html",
            "ftp://hows.it.going_buddy/checkit/o"
        ],
        "nonMatches": [
            "www.thedaddy.org",
            "http://hello",
            "ftp://check.it"
        ],
        "pattern": "^(ht|f)tp(s?)\\:\\/\\/[a-zA-Z0-9\\-\\._]+(\\.[a-zA-Z0-9\\-\\._]+){2,}(\\/?)([a-zA-Z0-9\\-\\.\\?\\,\\\u0027\\/\\\\\\+&%\\$#_]*)?$",
        "title": "Test"
    },
    {
        "description": "Get any file extension...",
        "matches": [
            "foo.bar",
            "more.foo.bar"
        ],
        "nonMatches": [
            ".",
            "bar"
        ],
        "pattern": ".+\\.([^.]+)$",
        "title": "Test"
    },
    {
        "description": "This Expression checks if the value is an integer, positive, not zero and not a decimal. Very handy for use when people need to fill in whole numbers, like when ordering car parts on a website (you dont want your customers to order -10 tires or 0.7 mirrors..",
        "matches": [
            "1",
            "00000428123",
            "1230000"
        ],
        "nonMatches": [
            "0",
            "00000000",
            "any text or +, - or any other character"
        ],
        "pattern": "^[0-9]*[1-9]+$|^[1-9]+[0-9]*$",
        "title": "Test"
    },
    {
        "description": "Simple US phone number matching, allowing area code or not. Allows spaces, dashes, dots, or none of the above. Area code, if entered, can be surrounded by parenthesis or not.",
        "matches": [
            "(555) 555-5555",
            "555.555.5555",
            "555-5555"
        ],
        "nonMatches": [
            "(555)-555-5555"
        ],
        "pattern": "^(\\(?[0-9]{3}[\\)-\\.]?\\ ?)?[0-9]{3}[-\\.]?[0-9]{4}$",
        "title": "Test"
    },
    {
        "description": "This expression is a trim using regular expression. This expression removes white spaces before and after the given input string",
        "matches": [
            "kesav",
            "kkk",
            "kk"
        ],
        "nonMatches": [
            "kesav",
            "kesav kumar"
        ],
        "pattern": "^\\s+|\\s+$",
        "title": "Test"
    },
    {
        "description": "This Works good until we want a multiple email address validator, I am working on it to make it work with the multiple email address, If anyone can work on this part as to validate a multiple email address then that will produce a very good expression, i think the best of this kind. AIM - to Validate Mohit <myadav@yahoo.com>; Rohit <ryadav@yahoo.com>; .........(any number of times)",
        "matches": [
            "Mohit <myadav@yahoo.com>",
            "Xon <JON@jon.com>",
            "Xon@something.com"
        ],
        "nonMatches": [
            "mohit<myadav@yahoo.com>",
            "Xon <JON@jon.com>, tom <jon@jon.com>",
            "Xon@somthing.com,"
        ],
        "pattern": "^[a-zA-Z]+(([\\\u0027\\,\\.\\- ][a-zA-Z ])?[a-zA-Z]*)*\\s+<(\\w[-._\\w]*\\w@\\w[-._\\w]*\\w\\.\\w{2,3})>$|^(\\w[-._\\w]*\\w@\\w[-._\\w]*\\w\\.\\w{2,3})$",
        "title": "Test"
    },
    {
        "description": "Here is a regular expression I wrote that validates U.S. phone numbers with area codes. You can\u0027t have a leading \u00270\u0027 or \u00271\u0027 but you can separate the number blocks with a space, a dot, a slash, or a hyphen. It also prevents a \u00270\u0027 or \u00271\u0027 for the first digit of the prefix. No extension is allowed and it must be 10 digits.",
        "matches": [
            "(713) 555-1212",
            "713/555/1212",
            "713.555 1212"
        ],
        "nonMatches": [
            "07135551212",
            "7130125551212"
        ],
        "pattern": "^[\\(]? ([^0-1]){1}([0-9]){2}([-,\\),/,\\.])*([ ])?([^0-1]){1}([0-9]){2}[ ]?[-]?[/]?[\\.]? ([0-9]){4}$",
        "title": "Test"
    },
    {
        "description": "CSS Length Unit Regex for cm, mm, in, pt (not px, ex, em)",
        "matches": [
            "+1.04in",
            "1.5cm",
            "4"
        ],
        "nonMatches": [
            "100+cm",
            "1.90.0",
            "100px"
        ],
        "pattern": "^\\s* (?<signedNumber>(\\+|\\-){0,1}((\\d*(\\.\\d+))|(\\d*)){1}) (?<unit>((in)|(cm)|(mm)|(pt)){0,1}) \\s*$",
        "title": "Test"
    },
    {
        "description": "the regex\u0027s on this site for pulling links off a page always seemed to be faulty, or at least never worked with PHP, so i made this one. simple, as i\u0027m an amateur with regex\u0027s, but stumbled thru it and this one actually works. tested with PHP function: preg_match_all(\"/href[ ]*=[ ]*(\u0027|\\\")([^\\\"\u0027])*(\u0027|\\\")/\",$string,$matches)",
        "matches": [
            "href=\"index.php\"",
            "href = \u0027http://www.dailymedication.com\u0027",
            "href = \"irc://irc.junk"
        ],
        "nonMatches": [
            "href=http://www.dailymedication.com"
        ],
        "pattern": "href[ ]*=[ ]*(\u0027|\\\")([^\\\"\u0027])*(\u0027|\\\")",
        "title": "Test"
    },
    {
        "description": "yyyy-mm-dd Datetime for AD, with leap year. See http://blogs.regexadvice.com/mash/archive/2004/04/23/1021.aspx for details on similar regexs",
        "matches": [
            "0001-06-16 12:00:01 AM",
            "2004/2/29",
            "3:30 PM"
        ],
        "nonMatches": [
            "9999/99/99",
            "24:00:00",
            "2003-02-29"
        ],
        "pattern": "(?#Calandar from January 1st 1 A.D to December 31, 9999 )(?# in yyyy-mm-dd format )(?!(?:1582\\D10\\D(?:0?[5-9]|1[0-4]))|(?#Missing days from 1582 )(?:1752\\D0?9\\D(?:0?[3-9]|1[0-3]))(?#or Missing days from 1752 )(?# both sets of missing days should not be in the same calendar so remove one or the other))(?n:^(?=\\d)(?# the character at the beginning a the string must be a digit )((?\u0027year\u0027\\d{4})(?\u0027sep\u0027[-./])(?\u0027month\u00270?[1-9]|1[012])\\k\u0027sep\u0027(?\u0027day\u0027(?\u003C!(?:0?[469]|11).)31|(?\u003C!0?2.)30|2[0-8]|1\\d|0?[1-9]|(?# if feb 29th check for valid leap year )(?:(?\u003C=(?!(?#exclude these years from leap year pattern ) 000[04](?#No year 0 and no leap year in year 4 )|(?:(?:1[^0-6]|[2468][^048]|[3579][^26])00)(?# centurial years \u003E 1500 not evenly divisible by 400 are not leap year))(?:(?:\\d\\d)(?# century)(?:[02468][048]|[13579][26])(?#leap years))\\k\u0027sep\u0027(?:0?2)\\k\u0027sep\u0027)|(?# else if not Feb 29 )(?\u003C!\\k\u0027sep\u0027(?:0?2)\\k\u0027sep\u0027)(?# and day not Feb 30 or 31 ))29)(?(?=\\x20\\d)\\x20|$))?(?# if there is a space followed by a digit check for time )(?\u003Ctime\u003E((?# 12 hour format )(0?[1-9]|1[012])(?# hours )(:[0-5]\\d){0,2}(?# optional minutes and seconds )(?i:\\x20[AP]M)(?# required AM or PM ))|(?# 24 hour format )([01]\\d|2[0-3])(?#hours )(:[0-5]\\d){1,2})(?#required minutes optional seconds )?$)",
        "title": "Test"
    },
    {
        "description": "mm/dd/yyyy hh:MM:ss Datetime for all AD years, including leap years. Javascript safe version of http://regexlib.com/REDetails.aspx?regexp_id=644. Please see that regex for details of what is being checked",
        "matches": [
            "11/24/0004 11:59 PM",
            "2.29.2008",
            "02:50:10"
        ],
        "nonMatches": [
            "12/33/1020",
            "2/29/2005",
            "13:00 AM"
        ],
        "pattern": "(?=\\d)^(?:(?!(?:10\\D(?:0?[5-9]|1[0-4])\\D(?:1582))|(?:0?9\\D(?:0?[3-9]|1[0-3])\\D(?:1752)))((?:0?[13578]|1[02])|(?:0?[469]|11)(?!\\/31)(?!-31)(?!\\.31)|(?:0?2(?=.?(?:(?:29.(?!000[04]|(?:(?:1[^0-6]|[2468][^048]|[3579][^26])00))(?:(?:(?:\\d\\d)(?:[02468][048]|[13579][26])(?!\\x20BC))|(?:00(?:42|3[0369]|2[147]|1[258]|09)\\x20BC))))))|(?:0?2(?=.(?:(?:\\d\\D)|(?:[01]\\d)|(?:2[0-8])))))([-.\\/])(0?[1-9]|[12]\\d|3[01])\\2(?!0000)((?=(?:00(?:4[0-5]|[0-3]?\\d)\\x20BC)|(?:\\d{4}(?!\\x20BC)))\\d{4}(?:\\x20BC)?)(?:$|(?=\\x20\\d)\\x20))?((?:(?:0?[1-9]|1[012])(?::[0-5]\\d){0,2}(?:\\x20[aApP][mM]))|(?:[01]\\d|2[0-3])(?::[0-5]\\d){1,2})?$",
        "title": "Test"
    },
    {
        "description": "dd/mm/yyyy hh:MM:ss Datetime for all AD years, including leap years. Javascript safe version of http://regexlib.com/REDetails.aspx?regexp_id=691. Please see that regex for details of what is being checked",
        "matches": [
            "31.12.6008",
            "5:30 AM",
            "30-04-1066"
        ],
        "nonMatches": [
            "00/00/0000",
            "99:99:99",
            "29/02/2005"
        ],
        "pattern": "^(?=\\d)(?:(?!(?:(?:0?[5-9]|1[0-4])(?:\\.|-|\\/)10(?:\\.|-|\\/)(?:1582))|(?:(?:0?[3-9]|1[0-3])(?:\\.|-|\\/)0?9(?:\\.|-|\\/)(?:1752)))(31(?!(?:\\.|-|\\/)(?:0?[2469]|11))|30(?!(?:\\.|-|\\/)0?2)|(?:29(?:(?!(?:\\.|-|\\/)0?2(?:\\.|-|\\/))|(?=\\D0?2\\D(?:(?!000[04]|(?:(?:1[^0-6]|[2468][^048]|[3579][^26])00))(?:(?:(?:\\d\\d)(?:[02468][048]|[13579][26])(?!\\x20BC))|(?:00(?:42|3[0369]|2[147]|1[258]|09)\\x20BC))))))|2[0-8]|1\\d|0?[1-9])([-.\\/])(1[012]|(?:0?[1-9]))\\2((?=(?:00(?:4[0-5]|[0-3]?\\d)\\x20BC)|(?:\\d{4}(?:$|(?=\\x20\\d)\\x20)))\\d{4}(?:\\x20BC)?)(?:$|(?=\\x20\\d)\\x20))?((?:(?:0?[1-9]|1[012])(?::[0-5]\\d){0,2}(?:\\x20[aApP][mM]))|(?:[01]\\d|2[0-3])(?::[0-5]\\d){1,2})?$",
        "title": "Test"
    },
    {
        "description": "yyyy/mm/dd hh:MM:ss Datetime for all AD years, including leap years. Javascript safe version of http://regexlib.com/REDetails.aspx?regexp_id=760. Please see that regex for details of what is being checked",
        "matches": [
            "0008-02-29",
            "2:34:59 PM",
            "9999/12/31 11:59 PM"
        ],
        "nonMatches": [
            "04/04/04",
            "1:00",
            "1999/1/32"
        ],
        "pattern": "^(?=\\d)(?:(?!(?:1582(?:\\.|-|\\/)10(?:\\.|-|\\/)(?:0?[5-9]|1[0-4]))|(?:1752(?:\\.|-|\\/)0?9(?:\\.|-|\\/)(?:0?[3-9]|1[0-3])))(?=(?:(?!000[04]|(?:(?:1[^0-6]|[2468][^048]|[3579][^26])00))(?:(?:\\d\\d)(?:[02468][048]|[13579][26]))\\D0?2\\D29)|(?:\\d{4}\\D(?!(?:0?[2469]|11)\\D31)(?!0?2(?:\\.|-|\\/)(?:29|30))))(\\d{4})([-\\/.])(0?\\d|1[012])\\2((?!00)[012]?\\d|3[01])(?:$|(?=\\x20\\d)\\x20))?((?:(?:0?[1-9]|1[012])(?::[0-5]\\d){0,2}(?:\\x20[aApP][mM]))|(?:[01]\\d|2[0-3])(?::[0-5]\\d){1,2})?$",
        "title": "Test"
    },
    {
        "description": "Matches URLS that start with numbers and any TLD that is 2 to 6 characters long. Matches most URLs. Thanks to eveyone for suggesting modifications! UPDATES::[Nov. 11, 2005] Now it matches uppercase and lower case protocols. Updates::December 3, 2005 Added restriction to ports since they will only go up to 65535. (Thanks lorello) Keep the suggestions coming! Thanks for the heads up!!",
        "matches": [
            "hTtP://3iem.net/",
            "http://3iem.museum:1337/",
            "plik.co.uk"
        ],
        "nonMatches": [
            "http://foobar",
            "lameurl.toolongtld"
        ],
        "pattern": "^((((H|h)(T|t)|(F|f))(T|t)(P|p)((S|s)?))\\://)?(www.|[a-zA-Z0-9].)[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,6}(\\:[0-9]{1,5})*(/($|[a-zA-Z0-9\\.\\,\\;\\?\\\u0027\\\\\\+&%\\$#\\=~_\\-]+))*$",
        "title": "Test"
    },
    {
        "description": "Identifies http, https, ftp, and ftps",
        "matches": [
            "http://3iem.net/",
            "https://foo.org",
            "ftps://jormahma.tk/"
        ],
        "nonMatches": [
            "yahoo.com",
            "lame://protocol.us"
        ],
        "pattern": "^(((ht|f)tp(s?))\\://).*$",
        "title": "Test"
    },
    {
        "description": "Password must contain at least one letter, at least one number, and be longer than six charaters.",
        "matches": [
            "a1b2c3",
            "abcdefg123",
            "12345a"
        ],
        "nonMatches": [
            "abcdefghij",
            "1234567890"
        ],
        "pattern": "^(?=.*[0-9]+.*)(?=.*[a-zA-Z]+.*)[0-9a-zA-Z]{6,}$",
        "title": "Test"
    },
    {
        "description": "Standard freight container number in upper or lower case.",
        "matches": [
            "HJCU1234567",
            "coou9876543"
        ],
        "nonMatches": [
            "HJCY1234567",
            "HJCU123456"
        ],
        "pattern": "^[a-zA-Z]{3}[uU]{1}[0-9]{7}$",
        "title": "Test"
    },
    {
        "description": "Regular expression to evaluate a date in German date format (DD.MM.YYYY). Leading zeros for days and months are valid. Period from 1.1.2000 until 31.12.2099 is valid. Leap years are checked.",
        "matches": [
            "1.1.2000",
            "29.02.2004",
            "31.12.2099"
        ],
        "nonMatches": [
            "1.1.1999",
            "29.02.2003",
            "01.01.2100"
        ],
        "pattern": "^(((((0?[1-9])|(1\\d)|(2[0-8]))\\.((0?[1-9])|(1[0-2])))|((31\\.((0[13578])|(1[02])))|((29|30)\\.((0?[1,3-9])|(1[0-2])))))\\.((20[0-9][0-9]))|(29\\.0?2\\.20(([02468][048])|([13579][26]))))$",
        "title": "Test"
    },
    {
        "description": "This regexp is used to match c++,java,etc style multi-line and single line comments.",
        "matches": [
            "/* This is a multi-line comment */",
            "// this is a single-line"
        ],
        "nonMatches": [
            "/sometext",
            "/*/"
        ],
        "pattern": "(\\/\\*(\\s*|.*?)*\\*\\/)|(\\/\\/.*)",
        "title": "Test"
    },
    {
        "description": "This will match valid UK telephone numbers. This adheres to ofcom\u0027s code and number length guide available at http://www.ofcom.org.uk/licensing_numbering/numbers/num_user_guide#1b Brackets and international codes are not allowed. A space MUST be used after the dialling code, and spaces at the expected points within the remainder of the number can be used if need be, but not nessesary, hence 0208 6473 373 is the same as 0208 647 3373 and 0208 6473373",
        "matches": [
            "01323 293 374",
            "020 73643763",
            "017354 7478"
        ],
        "nonMatches": [
            "02 83838 74",
            "(01323) 828223",
            "+44 88282 828"
        ],
        "pattern": "(^0[1-9]\\d{1}\\s\\d{4}\\s?\\d{4}$)|(^0[1-9]\\d{2}\\s\\d{3}\\s?\\d{4}$)|(^0[1-9]\\d{2}\\s\\d{4}\\s?\\d{3}$)|(^0[1-9]\\d{3}\\s\\d{3}\\s?\\d{2}$)|(^0[1-9]\\d{3}\\s\\d{3}\\s?\\d{3}$)|(^0[1-9]\\d{4}\\s\\d{3}\\s?\\d{2}$)|(^0[1-9]\\d{4}\\s\\d{2}\\s?\\d{3}$)|(^0[1-9]\\d{4}\\s\\d{2}\\s?\\d{2}$)",
        "title": "Test"
    },
    {
        "description": "As I could understand the HTML standard, this is the valid reg.exp. for comments. The only differenc from the last one is that the comment can be terminated by two minuses followed by none OR SOME space caracters and then by character >",
        "matches": [
            "<!-- anything -- >",
            "<!-- anything -> -> -->"
        ],
        "nonMatches": [
            "<!-- something -- and more >"
        ],
        "pattern": "<!--[\\s\\S]*?--[ \\t\\n\\r]*>",
        "title": "Test"
    },
    {
        "description": "Matched Australian Postcodes, as defined by AusPost. Many Australian developers are unaware of the small range of 3 digit, or 0 starting postcodes. 220 and 221 (or 0220 and 0221) are for ANU and LVR. 800s and 900s (or 0800s and 0900s) are for NT, and parts of SA, WA. 1000s are for big companies in Sydney, competition mailings, etc.",
        "matches": [
            "200",
            "0820",
            "2753"
        ],
        "nonMatches": [
            "700",
            "0700",
            "abcd"
        ],
        "pattern": "^(((2|8|9)\\d{2})|((02|08|09)\\d{2})|([1-9]\\d{3}))$",
        "title": "Test"
    },
    {
        "description": "Checks for the format yyyy-MM-dd HH:mm:ss also known as SortableDateTimePattern (conforms to ISO 8601) using local time. From 1900-01-01 00:00:00 to 9999-12-31 23:59:59. No check for leap year.",
        "matches": [
            "2004-07-12 14:25:59",
            "1900-01-01 00:00:00",
            "9999-12-31 23:59:59"
        ],
        "nonMatches": [
            "04-07-12 14:25:59",
            "20004-07-12 14:25",
            "2004/07/12 14:25:59"
        ],
        "pattern": "^(19[0-9]{2}|[2-9][0-9]{3})-((0(1|3|5|7|8)|10|12)-(0[1-9]|1[0-9]|2[0-9]|3[0-1])|(0(4|6|9)|11)-(0[1-9]|1[0-9]|2[0-9]|30)|(02)-(0[1-9]|1[0-9]|2[0-9]))\\x20(0[0-9]|1[0-9]|2[0-3])(:[0-5][0-9]){2}$",
        "title": "Test"
    },
    {
        "description": "Does not allow these characters in a string #$%^&*()\u0027",
        "matches": [
            "Test",
            "Whatever Text",
            "D://folder/file.ext"
        ],
        "nonMatches": [
            "word\u0027s",
            "test#",
            "(something)"
        ],
        "pattern": "^(a-z|A-Z|0-9)*[^#$%^\u0026*()\u0027]*$",
        "title": "Test"
    },
    {
        "description": "This expression evaluates simple currency values... alteast 1 digit and max 5 digits and if period then atleast one digit after period and max two digits after period",
        "matches": [
            "0",
            "00000",
            "00.00"
        ],
        "nonMatches": [
            "asds",
            "000000",
            "00000."
        ],
        "pattern": "(^\\d{1,5}$|^\\d{1,5}\\.\\d{1,2}$)",
        "title": "Test"
    },
    {
        "description": "Simple URL Validator -- allows http, https, ftp, ftps, 2-6 letter TLD, ports, any path. Sorry, no IP addresses. Not too fussy, but then, it\u0027s not too long either ;-)",
        "matches": [
            "http://www.site.com",
            "https://www.secure.com:10000",
            "ftp://ftp.site.com/pub/files/"
        ],
        "nonMatches": [
            "www.site.com",
            "https://www.site.longtld",
            "ftp:/badformat.com"
        ],
        "pattern": "^((ht|f)tp(s?))\\://([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]{2,6}(\\:[0-9]+)?(/\\S*)?$",
        "title": "Test"
    },
    {
        "description": "will match all dates in mm/dd/yyyy format. takes into account leap-years and months without 31 days.",
        "matches": [
            "2/29/2004",
            "07/16/1492",
            "12/31/1999"
        ],
        "nonMatches": [
            "2/29/2003",
            "2/29/2100",
            "11/31/2003"
        ],
        "pattern": "^(?:(?:0?[13578]|1[02])|(?:0?[469]|11)(?!\\/31)|(?:0?2)(?:(?!\\/3[01]|\\/29\\/(?:(?:0[^48]|[13579][^26]|[2468][^048])00|(?:\\d{2}(?:0[^48]|[13579][^26]|[2468][^048]))))))\\/(?:0?[1-9]|[12][0-9]|3[01])\\/\\d{4}$",
        "title": "Test"
    },
    {
        "description": "Matches euro currency (portuguese regional options). Uses the dot sign as the thousands separator (optional) and the comma sign as the decimal separator. Matches only 2 digitals after decimal. Also matches negative numbers.",
        "matches": [
            "-123123,12 \u20AC",
            "12312432134",
            "-12.234.123,23"
        ],
        "nonMatches": [
            "1234.12,234"
        ],
        "pattern": "^\\s*-?((\\d{1,3}(\\.(\\d){3})*)|\\d*)(,\\d{1,2})?\\s?(\\u20AC)?\\s*$",
        "title": "Test"
    },
    {
        "description": "Expresion para tipo Money \u0026#243; Cantidad",
        "matches": [
            "132,123,123.23",
            "123456.23",
            "0.23"
        ],
        "nonMatches": [
            "123,12",
            "123.123",
            "1322,132.23"
        ],
        "pattern": "^([1-9]{1}[\\d]{0,2}(\\,[\\d]{3})*(\\.[\\d]{0,2})?|[1-9]{1}[\\d]{0,}(\\.[\\d]{0,2})?|0(\\.[\\d]{0,2})?|(\\.[\\d]{1,2})?)$",
        "title": "Test"
    },
    {
        "description": "ASP.NET required field validator control.",
        "matches": [
            "<asp:requiredfieldvalidator id=rfvtReg runat=\"server\" CssClass=\"rlt\" ErrorMes"
        ],
        "nonMatches": [
            "<asp:requiredfieldvalidator id=rfvtNewUserReg runat=\"server\" CssClass=\"copyright\u0026a"
        ],
        "pattern": "<asp:requiredfieldvalidator(\\s*\\w+\\s*=\\s*\\\"?\\s*\\w+\\s*\\\"?\\s*)+\\s*>\\s*<\\/asp:requiredfieldvalidator>",
        "title": "Test"
    },
    {
        "description": "This matches the specific value for a unique identifier (GUID) from SQL server. Written by Jason N. Gaylord.",
        "matches": [
            "{A2B95C88-F211-4A2B-9729-2CFAB45C8984}",
            "{A2B95C88-F211-4A2B-9729-2CFAB45C8123}",
            "{A2B95C88-F211-4A2"
        ],
        "nonMatches": [
            "A2B95C88-F211-4A2B-9729-2CFAB45C8984",
            "A2B95C88F2114A2B9729-2CFAB45C8984",
            "123456a"
        ],
        "pattern": "\\{[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}\\}",
        "title": "Test"
    },
    {
        "description": "U.S. social security numbers (SSN), within the range of numbers that have been currently allocated. Matches the pattern AAA-GG-SSSS, AAA GG SSSS, AAA-GG SSSS, AAA GG-SSSS, AAAGGSSSS, AAA-GGSSSS, AAAGG-SSSS, AAAGG SSSS or AAA GGSSSS. All zero in any one field is not allowed. ** Additionally, spaces and/or dashes and/or nothing are allowed. In Michael Ash\u0027s example 123-45 6789 and 123456789 would fail there was a \u0027\\3\u0027 after the second octet of numbers that seemed to confuse the regex. now any combination of spaces, dashes, or nothing will work between the SSN octets. BoxerX.com thanks Michael for the regex!",
        "matches": [
            "145470191",
            "145 47 0191",
            "145-47 0191"
        ],
        "nonMatches": [
            "000470191",
            "145-00-0191",
            "145.47.0191"
        ],
        "pattern": "^(?!000)([0-6]\\d{2}|7([0-6]\\d|7[012])) ([ -])? (?!00)\\d\\d([ -|])? (?!0000)\\d{4}$",
        "title": "Test"
    },
    {
        "description": "This expression matches valid image URLs. The main use for this would be in UBBC tags. Written by RyanJ and Jick for FWD (http://flexwebdev.thenamesdan.com/)",
        "matches": [
            "http://www.location.com/images/image1.gif",
            "http://www.location.com/images/mainImgs/image1.png"
        ],
        "nonMatches": [
            "/images/image1.jpeg",
            "http://www.location.com/images/image1.swf",
            "http://www.something.com/hello/..j"
        ],
        "pattern": "((ht|f)tp(s?))(:((\\/\\/)(?!\\/)))(((w){3}\\.)?)([a-zA-Z0-9\\-_]+(\\.(com|edu|gov|int|mil|net|org|biz|info|name|pro|museum|co\\.uk)))(\\/(?!\\/))(([a-zA-Z0-9\\-_\\/]*)?)([a-zA-Z0-9])+\\.((jpg|jpeg|gif|png)(?!(\\w|\\W)))",
        "title": "Test"
    },
    {
        "description": "This Regex matches valid SQL identifiers, including names for Stored Procedures and the like. Note that local variables/parameters (which begin with an \"@\") will not match this Regex, nor will temporary objects (beginning with a \"#\"), or global temporary objects (beginning with \"##\"). All other valid identifiers/variables/table names/stored procedure names/columns etc., will match. Please let me know if you find this useful or have any complaints - trash@primalblaze.com.",
        "matches": [
            "upApplicationReadContacts",
            "_Application_ReadContacts",
            "a_45$#z"
        ],
        "nonMatches": [
            "upApplication ReadContacts",
            "$Application_ReadContacts",
            "a_45%$#z"
        ],
        "pattern": "^[a-zA-Z_]{1}[a-zA-Z0-9_@$#]*$",
        "title": "Test"
    },
    {
        "description": "Regular expression that matches Mexican RFC\u0027s (Registro Federal de Contribuyentes).",
        "matches": [
            "LOZG7802117B9",
            "LOZG-780211-7B9",
            "LOZG780211-7B9"
        ],
        "nonMatches": [
            "LO-ZG-78-02-11-7B9"
        ],
        "pattern": "^[A-Za-z]{4}[ |\\-]{0,1}[0-9]{6}[ |\\-]{0,1}[0-9A-Za-z]{3}$",
        "title": "Test"
    },
    {
        "description": "validates Percents, where Positive numbers are allowed over 100% (in this case up to 9999), but where Negative percents must not go to or below -100% This also allows for the \"%\" to be present or missing. This was used to validate sales Growth Percents (allows for large positive growth, but you could not go negative for more than 100%).",
        "matches": [
            "1234.56%",
            "23.32",
            "-42.23%"
        ],
        "nonMatches": [
            "12345%",
            "-200%",
            "5.1234%"
        ],
        "pattern": "^(\\d{0,4}(?:\\.\\d{0,2})? | [-]\\d{0,2}(?:\\.\\d{0,2})? )[%]{0,1}$",
        "title": "Test"
    },
    {
        "description": "Checks 0001-9999 Along with leap years intermediate symbols can be / or . or - this can be modified easily",
        "matches": [
            "29-02/0004",
            "29/02/0004",
            "29.02.9996"
        ],
        "nonMatches": [
            "29-2-0004",
            "29/02/0005",
            "29.02.0000"
        ],
        "pattern": "^(((((0[1-9])|(1\\d)|(2[0-8]))[/.-]((0[1-9])|(1[0-2])))|((31[/.-]((0[13578])|(1[02])))|((29|30)[/.-]((0[1,3-9])|(1[0-2])))))[/.-]((000[^0])&([0-9][0-9][0-9][0-9]))|(29[/.-]02[/.-](([0-9][0-9](([02468][48])|([2468][048])|([13579][26])))|((([02468][48])|([2468][048])|([13579][26]))00))))$",
        "title": "Test"
    },
    {
        "description": "Checks for years 0001-9999. Checks leap year corectly (0004,0400,0040) Can use / as separators or can replace it. Easy to understand and can be modified easily for mm/dd/yyyy or yyyy/dd/mm or mm-dd-yy or to any date format.",
        "matches": [
            "29/02/0400",
            "01/01/0001",
            "31/12/9999"
        ],
        "nonMatches": [
            "29/2/0400",
            "1/01/0001",
            "29/02/5555"
        ],
        "pattern": "^(((((0[1-9])|(1\\d)|(2[0-8]))/((0[1-9])|(1[0-2])))|((31/((0 [13578])|(1[02])))|((29|30)/((0[1,3-9])|(1[0-2])))))/((000 [1-9])|(00[1-9][0-9])|(0[1-9][0-9][0-9])|([1-9][0-9][0-9] [0-9]))|(29/02/(([0-9][0-9](([02468][48])|([2468][048])| ([13579][26])))|((([02468][48])|([2468][048])|([13579] [26]))00))))$",
        "title": "Test"
    },
    {
        "description": "Zip+4 Zipcode RegEx. You may ommit the +4 digits but you must also then ommit the hyphen/dash as well. In 1983, the Postal Service\u2122 began using an expanded ZIP Code\u2122 number called called the \"ZIP+4\u0026#174;\" Code. The nine digits of a ZIP+4 code (e.g., 12345-6789) is broken down as follows: [123]Sectional Center or Large City. [45]Post Office\u2122 facility or Delivery Area. [-]Required \"dash\" or \"hyphen\". [67]Sector or Several Blocks. [89]Segment or One Side of a Street. Also just FYI, ZIP codes in the northeast US frequently start with \u00270\u0027 or \u002700\u0027. [00988-Carolina, PR] [03110-Bedford, NH]. Thanks, Ryan v-",
        "matches": [
            "98121",
            "00988",
            "12345-6789"
        ],
        "nonMatches": [
            "98121-",
            "12345-678",
            "1234"
        ],
        "pattern": "^\\d{5}(-\\d{4})?$",
        "title": "Test"
    },
    {
        "description": "All positive non-zero integers between 1 and 999. You can adjust the upper range of this expression by changing the second number (ie 2) in the {0,2} part of the expression.",
        "matches": [
            "1",
            "561",
            "999"
        ],
        "nonMatches": [
            "-1",
            "0",
            "1000"
        ],
        "pattern": "^[1-9][0-9]{0,2}$",
        "title": "Test"
    },
    {
        "description": "will match as long as the only chars exist in the string : A-Z,a-z,0-9,\u0027Space\u0027 chr(32),%&\u0027+-@_. It\u0027s useful for check vs Account Names where you might want to forbid entering other chars then what is in the pattern. also will not allow repeated space in the string",
        "matches": [
            "AccountName_123",
            "Account@email.com",
            "James \u0026 Dana Inc."
        ],
        "nonMatches": [
            "!MYACCOUNT!",
            "{Superman}",
            "$ Money Man $"
        ],
        "pattern": "^([A-Z]|[a-z]|[0-9])(([A-Z])*(([a-z])*([0-9])*(%)*(\u0026)*(\u0027)*(\\+)*(-)*(@)*(_)*(\\.)*)|(\\ )[^ ])+$",
        "title": "Test"
    },
    {
        "description": "Usefull for SQL update and insert sentence..",
        "matches": [
            "01.01.2004",
            "30.12.2005"
        ],
        "nonMatches": [
            "01/01/2004",
            "1.1.2004",
            "01-01-2004"
        ],
        "pattern": "(((0[1-9]|[12][0-9]|3[01])([.])(0[13578]|10|12)([.])([1-2][0,9][0-9][0-9]))|(([0][1-9]|[12][0-9]|30)([.])(0[469]|11)([.])([1-2][0,9][0-9][0-9]))|((0[1-9]|1[0-9]|2[0-8])([.])(02)([.])([1-2][0,9][0-9][0-9]))|((29)(\\.|-|\\/)(02)([.])([02468][048]00))|((29)([.])(02)([.])([13579][26]00))|((29)([.])(02)([.])([0-9][0-9][0][48]))|((29)([.])(02)([.])([0-9][0-9][2468][048]))|((29)([.])(02)([.])([0-9][0-9][13579][26])))",
        "title": "Test"
    },
    {
        "description": "This works good for account names where u don\u0027t want your users to create ugly account names. 3 rules apllied in it: 1. an account name must start with Letter or Number 2. the only valid signs are : ^%&\u0027+-@. and (space (chr32)) 3. a sign can\u0027t be repeated by any sign execept space which can\u0027t be repeated as well.",
        "matches": [
            "AccountName_123",
            "ABC \u0026 DEF Inc.",
            "me@myemail.com"
        ],
        "nonMatches": [
            "-=superman=-",
            "$$ Money Man $$",
            "Lord -- Foo"
        ],
        "pattern": "^([A-Z]|[a-z]|[0-9])([A-Z]|[a-z]|[0-9]|([A-Z]|[a-z]|[0-9]|(%|\u0026|\u0027|\\+|\\-|@|_|\\.|\\ )[^%\u0026\u0027\\+\\-@_\\.\\ ]|\\.$|([%\u0026\u0027\\+\\-@_\\.]\\ [^\\ ]|\\ [%\u0026\u0027\\+\\-@_\\.][^%\u0026\u0027\\+\\-@_\\.])))+$",
        "title": "Test"
    },
    {
        "description": "Strip (X)HTML comments",
        "matches": [
            "<!-- any comments -->"
        ],
        "nonMatches": [
            "<!- - 111 -->"
        ],
        "pattern": "<!--((?!-->).)*-->",
        "title": "Test"
    },
    {
        "description": "I did not found a Regex for german date, so I created my own. This RE validate dates in the dd.MM.yyyy format with leap years 100% integrated valid years from 1600 to 9999. As usual, many tests have been made. I think this one should be fine.",
        "matches": [
            "1.1.2004",
            "01.01.2004",
            "29.2.2004"
        ],
        "nonMatches": [
            "1/1/2004",
            "1-1-2004"
        ],
        "pattern": "^(((0?[1-9]|[12]\\d|3[01])\\.(0[13578]|[13578]|1[02])\\.((1[6-9]|[2-9]\\d)\\d{2}))|((0?[1-9]|[12]\\d|30)\\.(0[13456789]|[13456789]|1[012])\\.((1[6-9]|[2-9]\\d)\\d{2}))|((0?[1-9]|1\\d|2[0-8])\\.0?2\\.((1[6-9]|[2-9]\\d)\\d{2}))|(29\\.0?2\\.((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))$",
        "title": "Test"
    },
    {
        "description": "Matches dutch telephone numbers WITHOUT country code prefix Tests on mobile numbers, 3 digits prefix city-codes and 4 digit prefix city codes. * Disallows a 0 directly after a prefix * Allows space or a - between prefix and telephonenumber * Also allows space between telephone digits to compensate the nasty habit of making telphone numbers more readable",
        "matches": [
            "06 539 439 99",
            "023-123 1233",
            "023 121 12 12"
        ],
        "nonMatches": [
            "06-539-439-99",
            "05-75 46 30 50"
        ],
        "pattern": "([0]{1}[6]{1}[-\\s]*([1-9]{1}[\\s]*){8})|([0]{1}[1-9]{1}[0-9]{1}[0-9]{1}[-\\s]*([1-9]{1}[\\s]*){6})|([0]{1}[1-9]{1}[0-9]{1}[-\\s]*([1-9]{1}[\\s]*){7})",
        "title": "Test"
    },
    {
        "description": "Validates currency, must have two leading and two digits following a decimal point. Does not accept leading zero\u0027s.",
        "matches": [
            "10.00",
            "32.50"
        ],
        "nonMatches": [
            "01.00",
            "12",
            "12.0"
        ],
        "pattern": "^(?!0,?\\d)([0-9]{2}[0-9]{0,}(\\.[0-9]{2}))$",
        "title": "Test"
    },
    {
        "description": "simply email regular expression",
        "matches": [
            "d-m__9@k.info",
            "+482222222@mobile.com",
            "test@test1.test2a-test2b.us"
        ],
        "nonMatches": [
            "d.@m",
            "d__-d@k.org",
            "k@m--d..uk"
        ],
        "pattern": "^\\+?[a-z0-9](([-+.]|[_]+)?[a-z0-9]+)*@([a-z0-9]+(\\.|\\-))+[a-z]{2,6}$",
        "title": "Test"
    },
    {
        "description": "Validates UNC Paths, with or without files. Does not validate on shares ($) or local files (c:\\xxx). Thanks to Erlend Oftedal for helping me out with this one!",
        "matches": [
            "\\\\server\\directory\\",
            "\\\\server\\directory with space",
            "\\\\server\\directory1\\directory2\\file1.xxx"
        ],
        "nonMatches": [
            "c:\\directory",
            "c:\\directory\\file.xx",
            "\\\\server\\\\directory\\file.xx.xx"
        ],
        "pattern": "^\\\\(\\\\[\\w-]+){1,}(\\\\[\\w-()]+(\\s[\\w-()]+)*)+(\\\\(([\\w-()]+(\\s[\\w-()]+)*)+\\.[\\w]+)?)?$",
        "title": "Test"
    },
    {
        "description": "This was written for quick entry on a timecard system. It allows you to create a number with an option of 2 decimal places. I have the digits left of the decimal unrestricted for this example, but in the real world of time keeping, you wouldn\u0027t surpass 3 digits on the left of the decimal.",
        "matches": [
            "4000",
            "40.25",
            ".75"
        ],
        "nonMatches": [
            "-5.2",
            "40.258",
            "9,325"
        ],
        "pattern": "^(\\d+|(\\d*\\.{1}\\d{1,2}){1})$",
        "title": "Test"
    },
    {
        "description": "This is used to validate an Australian telephone number with no other characters than the () being used. Validates area code being between 01 - 09.",
        "matches": [
            "(02)12341234",
            "(03)12341234",
            "(05)12341234"
        ],
        "nonMatches": [
            "00 1234 1234",
            "00-1234-1234",
            "(00)12341234"
        ],
        "pattern": "^\\(0[1-9]{1}\\)[0-9]{8}$",
        "title": "Test"
    },
    {
        "description": "This pattern matches the windows console (cmd) prompt (also know as command prompt)",
        "matches": [
            "x:\\dir\u003E",
            "x:\\dir\\another.dir\u003E",
            "x:\\\u003E"
        ],
        "nonMatches": [
            "x:\\dir\\\u003E",
            "x:\\dir",
            "\\dir"
        ],
        "pattern": "^[a-zA-Z]:(\\\\|(\\\\[^\\\\/\\s:*\u0022\u003C\u003E|]+)+)\u003E",
        "title": "Test"
    },
    {
        "description": "Valida\u0026#231;\u0026#227;o de CPF Brasileiro com ou sem os divisores.",
        "matches": [
            "00000000000",
            "123.456.789-98",
            "12345678998"
        ],
        "nonMatches": [
            "0000.000.000-00"
        ],
        "pattern": "(^(\\d{3}.\\d{3}.\\d{3}-\\d{2})|(\\d{11})$)",
        "title": "Test"
    },
    {
        "description": "Formato de Telefone Brasileiro, sem o DDD",
        "matches": [
            "1111-9865",
            "111-9856",
            "11119865"
        ],
        "nonMatches": [
            "111111",
            "1111111111",
            "1111 9865"
        ],
        "pattern": "(^\\d{3,4}\\-\\d{4}$)|(^\\d{7,8}$)",
        "title": "Test"
    },
    {
        "description": "This regular expression finds all opening tags that have the runat=\u0027server\u0027 attribute specified. It groups the type of the control (eg. asp:Label) in to a group named TYPE and the id of the control into a group named NAME. It is useful for finding all server tags or controls in an ASPX (ASP.NET) page.",
        "matches": [
            "<asp:Label id=\"Label1\" runat=server>",
            "<TABLE id=\"tblTable\" runat=serve"
        ],
        "nonMatches": [
            "<table class=\"tableclass\">",
            "<asp:Label id=\"Label2\">"
        ],
        "pattern": "<(?i)(?=.[^>]*runat=[\"]?server)(?<TYPE>\\S[^>\\s]+).[^>]*id=[\"]?(?<NAME>\\w+).[^>]*>",
        "title": "Test"
    },
    {
        "description": "Valida\u0026#231;\u0026#227;o para letras maiusculas e minusculas sem acentos, incluinto os caracteres . - & e /",
        "matches": [
            "A-9",
            "b&56-8.2"
        ],
        "nonMatches": [
            "*u7",
            "R$25.12"
        ],
        "pattern": "^\\s*[a-zA-Z0-9&\\-\\./,\\s]+\\s*$",
        "title": "Test"
    },
    {
        "description": "Express\u0026#227;o para a Valida\u0026#231;\u0026#227;o do CNPJ contendo ou n\u0026#227;o os caracteres de separa\u0026#231;\u0026#227;o . e /.",
        "matches": [
            "00.000.000/0000-00",
            "00000000000000"
        ],
        "nonMatches": [
            "000.000.000/0000-00"
        ],
        "pattern": "(^(\\d{2}.\\d{3}.\\d{3}/\\d{4}-\\d{2})|(\\d{14})$)",
        "title": "Test"
    },
    {
        "description": "Express\u0026#227;o para a Valida\u0026#231;\u0026#227;o de Telefones Celulares sem o DDD valida celulares com inicio igual a 7,8 e 9.",
        "matches": [
            "9999-9595",
            "88888787",
            "7777-6589"
        ],
        "nonMatches": [
            "44445555",
            "2222-9658",
            "22223658"
        ],
        "pattern": "((([7-9])(\\d{3})([-])(\\d{4}))|(([7-9])(\\d{7})))",
        "title": "Test"
    },
    {
        "description": "Expression validating a hex string of any length.",
        "matches": [
            "1E3",
            "82E5AAA4",
            "01ff"
        ],
        "nonMatches": [
            "1g3",
            "4Z",
            "01x"
        ],
        "pattern": "^([0-9a-fA-F])*$",
        "title": "Test"
    },
    {
        "description": "THE Complex Password Filter Matching 3 of 4 Character catagories: 1.) at least 1 upper case character 2.) at least 1 lower case character 3.) at least 1 numerical character 4.) at least 1 special character It also enforces a min and max length and works for .Net and script Regex implimentations.",
        "matches": [
            "Passw0rd",
            "assW@rd",
            "1B2a345@#$%"
        ],
        "nonMatches": [
            "123123123",
            "Password",
            "asdf&"
        ],
        "pattern": "(?=^.{6,255}$)((?=.*\\d)(?=.*[A-Z])(?=.*[a-z])|(?=.*\\d)(?=.*[^A-Za-z0-9])(?=.*[a-z])|(?=.*[^A-Za-z0-9])(?=.*[A-Z])(?=.*[a-z])|(?=.*\\d)(?=.*[A-Z])(?=.*[^A-Za-z0-9]))^.*",
        "title": "Test"
    },
    {
        "description": "It validates Indian Vehicle Registration Number",
        "matches": [
            "mh-12-bj-1780",
            "mmx-1234"
        ],
        "nonMatches": [
            "mmm-123-1234",
            "mm-12345"
        ],
        "pattern": "^([A-Z|a-z]{2}-\\d{2}-[A-Z|a-z]{2}-\\d{1,4})?([A-Z|a-z]{3}-\\d{1,4})?$",
        "title": "Test"
    },
    {
        "description": "This pattern highlights any characters in double or single quotes, single line only .For the reason that refreshing the whole document every keystroke would send the application to a crawl. Only Dreamweaver achieve parsing the whole document fast enough. Other application can only achieve refreshing a line dynamically. note: open quotes are highlighted until the end, as they are with most syntax highlighting applications.",
        "matches": [
            "One \"two\" three \u0027fwo\u0027 finve \u0027six",
            "One \"highlighted still \u0027all highlighted\u0027\"",
            "O"
        ],
        "nonMatches": [
            "Come on now"
        ],
        "pattern": "\".*?\"|\".*$|\u0027.*?\u0027|\u0027.*$",
        "title": "Test"
    },
    {
        "description": "This pattern will match all dates from the year 1900 to 2099, invalid dates like 0000-00-00 will not be accepted. Replacement string can be used as the Year Month and day is named. The \"-\" character can be replaced with \"/\" character for the required format, and also the <Year>, <Month> and <Day> can also be interchanged according the local culture format (eg dd/mm/yy)",
        "matches": [
            "1900-01-01",
            "2099-12-31",
            "2004-10-11"
        ],
        "nonMatches": [
            "2004-01-00",
            "2004-00-01",
            "0000-01-01"
        ],
        "pattern": "(?\u003CYear\u003E(19|20)[0-9][0-9])-(?\u003CMonth\u003E0[1-9]|1[0-2])-(?\u003CDay\u003E0[1-9]|[12][0-9]|3[01])",
        "title": "Test"
    },
    {
        "description": "This will make sure that if your number starts w. a 99 it will have 10 more digits after it and if it starts w. a 5 it will also have 10 digits after that. So if you have a number starting with 99 it must be 12 digits long if it starts with a 5 it must be 11.",
        "matches": [
            "991234567890",
            "51234567890"
        ],
        "nonMatches": [
            "99123456789",
            "91234567890"
        ],
        "pattern": "^[9]9\\d{10}|^[5]\\d{10}",
        "title": "Test"
    },
    {
        "description": "This RegExp is degigned to mach SQL OLEDB Connection String to the Named Groups Properties useful for .Net MATCH EXAMPLE(the submition field is too short):Provider=\"SQLOLEDB.1\";Data Source=(local);Initial Catalog=master;User ID=sa;Password=\"SA_PASS\";Connection TimeOut=90",
        "matches": [
            "Provider=\u0022SQLOLEDB.1\u0022;Data Source=(local);Initial Catalog=master;User ID=sa;Password=\u0026quot"
        ],
        "nonMatches": [
            "Any non SQL Connection String"
        ],
        "pattern": "(?:Provider=\u0022??(?\u003CProvider\u003E[^;\\n]+)\u0022??[;\\n\u0022]??|Data\\sSource=(?\u003CDataSource\u003E[^;\\n]+)[;\\n\u0022]??|Initial\\sCatalog=(?\u003CInitialCatalog\u003E[^;\\n]+)[;\\n\u0022]??|User\\sID=(?\u003CUserID\u003E[^;\\n]+)[;\\n\u0022]??|Password=\u0022??(?\u003CPassword\u003E[^;\\n]+)\u0022??[;\\n\u0022]??|Integrated\\sSecurity=(?\u003CIntegratedSecurity\u003E[^;\\n]+)[;\\n]??|Connection\\sTimeOut=(?\u003CConnectionTimeOut\u003E[^;\\n]+)[;\\n\u0022]??)+$",
        "title": "Test"
    },
    {
        "description": "Regular expression for validating US and CANADA telephone numbers with OPTIONAL contry code, OPTIONAL area code, and OPTIONAL extension. Matches various permutations of formatting characters (parenthesis, space, dash). Parses the telephone number contry code, area code, prefix, suffix, and extension ...",
        "matches": [
            "1-(222) 333-4444",
            "1 (222) 333-4444",
            "12223334444"
        ],
        "nonMatches": [
            "1- (222) 333 4444",
            "1 (222) 333-4444",
            "1 2223334444"
        ],
        "pattern": "^(?:(?\u003CContry\u003E\\d{1,1})(?\u003C5\u003E[- ]?)?)?(?:(?\u003C1\u003E[(])?(?\u003CAreaCode\u003E[2-9]\\d{2})(?(1)[)])(?(1)(?\u003C2\u003E[ ])|(?:(?\u003C3\u003E[-])|(?\u003C4\u003E[ ])))?)?(?\u003CPrefix\u003E[1-9]\\d{2})(?(AreaCode)(?:(?(1)(?(2)[- ]|[-]?))|(?(3)[-])|(?(4)[- ]))|[- ]?)(?\u003CSuffix\u003E\\d{4})(?:[ ]?[#xXeE]?(?\u003CExt\u003E\\d{2,4}))?$",
        "title": "Test"
    },
    {
        "description": "This is to check release names... it only allowes alphanumeric and numeric chars , and also _ - and .",
        "matches": [
            "The.Cooler.2003.LIMITED.DVDRip.XViD-ALLiANCE",
            "blaat.bleahz-GROUP",
            "blaat_bleahz-GROUP"
        ],
        "nonMatches": [
            "The Cooler 2003 LIMITED DVDRip XViD-ALLiANCE",
            "blaat~bleahz@GROUP"
        ],
        "pattern": "^[a-zA-Z0-9._-]+$",
        "title": "Test"
    },
    {
        "description": "Matches xml namespace (xmlns) attribtutes. Works with single and double quotes, could be extended to support unquoted attributes.",
        "matches": [
            "<el xmlns=\"http://SomeCorp/Namespace1\">",
            "<el xmlns=\u0027http://SomeCorp/Namespace1\u0027\u0026"
        ],
        "nonMatches": [
            "<el xmlns=http://SomeCorp/Namespace1>"
        ],
        "pattern": "( xmlns:.*=[\",\u0027].*[\",\u0027])|( xmlns=[\",\u0027].*[\",\u0027])",
        "title": "Test"
    },
    {
        "description": "Retrieves all anchor links in a html document, useful for spidering. You will need to do a replace of \" and \u0027 after the regular expression, as the expression gets all links. As far as I know there is no way, even with \\1 groupings, of getting a condition on whether the link contains a \",\u0027 or nothing at all (\" and \u0027 is easy enough, but what happens if the link starts with \", and has a javascript function call with a string in it). If there is, it\u0027s probably quicker to do it like this and do a string replace anyway.",
        "matches": [
            "<a href=\"http://www.blah.com\">",
            "<a href=\u0027../blah.html\u0027 target=\"_top\"\u0026a"
        ],
        "nonMatches": [
            "<a href = http://www.idiothtmlprogrammers.com >"
        ],
        "pattern": "<a\\s*href=(.*?)[\\s|>]",
        "title": "Test"
    },
    {
        "description": "This is the simplest RegEx for validating someone\u0027s name. The name can contain only alphabets(in either case) & should be of minimum length 4 & maximum length 32. Only white spaces are allowed apart from alphabets.",
        "matches": [
            "some body",
            "hey there",
            "hello"
        ],
        "nonMatches": [
            "hi",
            "hey 27",
            "hell?"
        ],
        "pattern": "^([a-zA-z\\s]{4,32})$",
        "title": "Test"
    },
    {
        "description": "This RegEx will match boolean values, either numeric or literal. It will accept MS Access \"-1\" values for \"true\", and recognizes English and Brazilian Portuguese.",
        "matches": [
            "False",
            "verdadeiro",
            "0"
        ],
        "nonMatches": [
            "+0",
            "1-1"
        ],
        "pattern": "^([Vv]+(erdade(iro)?)?|[Ff]+(als[eo])?|[Tt]+(rue)?|0|[\\+\\-]?1)$",
        "title": "Test"
    },
    {
        "description": "Matches canonical Uniform Resource Names (URNs) as defined in RFC 2141.",
        "matches": [
            "urn:vrml:umel:/some/dir/file.ext",
            "urn:schemas-microsoft-com:xml-data",
            "URN:foo:a123,456"
        ],
        "nonMatches": [
            "urn:11111.345:12",
            "http://www.example.org/",
            "urn:a#-12:555"
        ],
        "pattern": "urn:[a-z0-9]{1}[a-z0-9\\-]{1,31}:[a-z0-9_,:=@;!\u0027%/#\\(\\)\\+\\-\\.\\$\\*\\?]+",
        "title": "Test"
    },
    {
        "description": "Allows you to check the length of a number (in this case either 3 or 4 digits). I found it useful when validating Credit Card Identification Codes (CVV2/CVC2/CID) which are either 3 or 4 numerical digits.",
        "matches": [
            "123",
            "1234"
        ],
        "nonMatches": [
            "12",
            "12345"
        ],
        "pattern": "^([0-9]{3,4})$",
        "title": "Test"
    },
    {
        "description": "I\u0027am using it in PHP preg_match() to replace in string parts with non-entity ampersand. Made for my RSS.",
        "matches": [
            "[&]",
            "[ & ]",
            "[dasdasd&fsdfsd]"
        ],
        "nonMatches": [
            "[&quot;]",
            "[gdfgd&#123;vvf]"
        ],
        "pattern": "&(?!([a-zA-Z0-9#]{1,6};))",
        "title": "Test"
    },
    {
        "description": "This is a simple expression used to match a normal 12 hour clock, requires AM/PM in any or mixed case and requires a space before the AM or PM and minutes are required.",
        "matches": [
            "1:45 am",
            "12:01 aM",
            "01:23 pm"
        ],
        "nonMatches": [
            "13:34 am",
            "1:60 am",
            "13:45"
        ],
        "pattern": "^((0?[1-9]|1[012])(:[0-5]\\d){1,2}(\\ [AaPp][Mm]))$",
        "title": "Test"
    },
    {
        "description": "will break out a valid CSS stylesheet into it\u0027s components. Groups on each style, all selectors, each selector within a comma delimited list of selectors, all properties, each property set, each property and each value. In other words, it breaks it all down for you :) The only two problems I\u0027m having with it: A) it is ignorant of comment blocks. so if you have styles within a /* */ block, it\u0027ll pick those up. B) the first style following a comment block is not parsed correctly (it incorrectly includes the comment as a selector best thing to do would be to use another regexp to remove all comments before processing with this one",
        "matches": [
            "div#main { position:relative; width:809px; margin-left:auto; margin-right:auto; padding:0; }"
        ],
        "nonMatches": [
            "-----"
        ],
        "pattern": "((\\s*([^,{]+)\\s*,?\\s*)*?){((\\s*([^:]+)\\s*:\\s*([^;]+?)\\s*;\\s*)*?)}",
        "title": "Test"
    },
    {
        "description": "A regex that will split a CSV file when used for MATCH function. All values must be in quotes, and seperated by commas. Ex. \"test1\",\"test2\",\"test3\" Quotes themselves are not captured Note: Only works in regex engines that support backreferences (Java, .NET, php, etc). JavaScript is not one of them.",
        "matches": [
            "\u0022test1\u0022,\u0022test2\u0022"
        ],
        "nonMatches": [
            "test1,test2"
        ],
        "pattern": "(?\u003C=(?:^|,)\u0022)(?:[^\u0022]|\u0022\u0022)+",
        "title": "Test"
    },
    {
        "description": "Single field zip code validator, useful for Web Forms. Allows user to enter 5-digit or 5-digit plus 4 zip code, with hyphen or space or NO space between last 4 digits.",
        "matches": [
            "92078-4705",
            "920784705",
            "92078 4705"
        ],
        "nonMatches": [
            "9027x",
            "902",
            "92078.4705"
        ],
        "pattern": "^\\d{5}((-|\\s)?\\d{4})?$",
        "title": "Test"
    },
    {
        "description": "Telephone validator allowing user to enter 10 digit telephone number with segments of number separated by hyphens, periods or spaces. Also braces allowed around area code.",
        "matches": [
            "213-123-1234",
            "2131231234",
            "(213) 123-1234"
        ],
        "nonMatches": [
            "123-123-1234"
        ],
        "pattern": "^(\\([2-9]|[2-9])(\\d{2}|\\d{2}\\))(-|.|\\s)?\\d{3}(-|.|\\s)?\\d{4}$",
        "title": "Test"
    },
    {
        "description": "Very easy expression for using with arachnoWare XmlDbelt for obtaining information about data store connection string and XPath based query over the store.",
        "matches": [
            "(\u0027storage=xmlcs:doc.xml;username=admin;password=nothing;\u0027)//node[@id=\u0027222\u0027]"
        ],
        "nonMatches": [
            "(storage=xmlcs:doc.xml;username=admin;password=nothing;)//node"
        ],
        "pattern": "\u0027(?\u003Cdocument\u003E.*)\u0027\\)(?\u003Cpath\u003E.*)",
        "title": "Test"
    },
    {
        "description": "Validate american date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators: . - / Valid dates only! m (1-12)/ d (1-31)/ y (0..) (rizzipereira.com.br) For Brazilian date format: http://www.regexlib.com/REDetails.aspx?regexp_id=250",
        "matches": [
            "10.03.1979",
            "12/30/2004",
            "01/01/2004"
        ],
        "nonMatches": [
            "09--02--2004",
            "15-15-2004",
            "13/12/2004"
        ],
        "pattern": "^([0]?[1-9]|[1][0-2])[./-]([0]?[1-9]|[1|2][0-9]|[3][0|1])[./-]([0-9]{4}|[0-9]{2})$",
        "title": "Test"
    },
    {
        "description": "Matches the date format \"YYYY-mm-dd\" and also validates month and number of days in a month. All leap year dates \"YYYY-02-29\" passes trough. Could easily be changed to another format.",
        "matches": [
            "2004-04-30",
            "2004-02-29"
        ],
        "nonMatches": [
            "2004-04-31",
            "2004-02-30"
        ],
        "pattern": "^[0-9]{4}-(((0[13578]|(10|12))-(0[1-9]|[1-2][0-9]|3[0-1]))|(02-(0[1-9]|[1-2][0-9]))|((0[469]|11)-(0[1-9]|[1-2][0-9]|30)))$",
        "title": "Test"
    },
    {
        "description": "Meets dutch phone number requirements.. One posted here before didn\u0027t allow the 0 after the first digit of the call ID (so the second number or later after the prefix), which should be allowed. I modified that one to meet full requirements now.. Enjoy!!",
        "matches": [
            "06 12345678",
            "010-1234560",
            "0111-101234"
        ],
        "nonMatches": [
            "05-43021212",
            "123-4567890",
            "1234567890"
        ],
        "pattern": "([0]{1}[6]{1}[-\\s]*[1-9]{1}[\\s]*([0-9]{1}[\\s]*){7})|([0]{1}[1-9]{1}[0-9]{1}[0-9]{1}[-\\s]*[1-9]{1}[\\s]*([0-9]{1}[\\s]*){5})|([0]{1}[1-9]{1}[0-9]{1}[-\\s]*[1-9]{1}[\\s]*([0-9]{1}[\\s]*){6})",
        "title": "Test"
    },
    {
        "description": "IPv4 ip:port checker, I hope it will help you. $1 - IP, $2 - port. More to come, maybe :)",
        "matches": [
            "127.0.0.1:80",
            "255.255.255.0:21",
            "1.0.0.0:1"
        ],
        "nonMatches": [
            "0.0.0.0:1",
            "256.1.1.1:20",
            "127.0.0.1:65536"
        ],
        "pattern": "^((?:2[0-5]{2}|1\\d{2}|[1-9]\\d|[1-9])\\.(?:(?:2[0-5]{2}|1\\d{2}|[1-9]\\d|\\d)\\.){2}(?:2[0-5]{2}|1\\d{2}|[1-9]\\d|\\d)):(\\d|[1-9]\\d|[1-9]\\d{2,3}|[1-5]\\d{4}|6[0-4]\\d{3}|654\\d{2}|655[0-2]\\d|6553[0-5])$",
        "title": "Test"
    },
    {
        "description": "This RE match the SQL Basics Queries (SELECT, UPDATE, INSERT and DELETE).",
        "matches": [
            "SELECT * FROM TABLE",
            "UPDATE TABLE SET FIELD=VALUE WHERE ID_FIELD=VALUE_ID",
            "DELETE FROM TABLE WHERE"
        ],
        "nonMatches": [
            "SELECT TABLE",
            "UPDATE SET TABLE",
            "INSERT INTO FIELD=VALUE TABLE"
        ],
        "pattern": "(SELECT\\s[\\w\\*\\)\\(\\,\\s]+\\sFROM\\s[\\w]+)| (UPDATE\\s[\\w]+\\sSET\\s[\\w\\,\\\u0027\\=]+)| (INSERT\\sINTO\\s[\\d\\w]+[\\s\\w\\d\\)\\(\\,]*\\sVALUES\\s\\([\\d\\w\\\u0027\\,\\)]+)| (DELETE\\sFROM\\s[\\d\\w\\\u0027\\=]+)",
        "title": "Test"
    },
    {
        "description": "Finds sentences (assuming they end with a full stop, question mark or exclamation mark).",
        "matches": [
            "This is a series of sentences. They end predictably! Where would we be without punctuation?"
        ],
        "nonMatches": [
            "This sentence just trails off"
        ],
        "pattern": "([^\\.\\?\\!]*)[\\.\\?\\!]",
        "title": "Test"
    },
    {
        "description": "Verifies South African mobile numbers with or without the country code.",
        "matches": [
            "+27832762842",
            "27832762842",
            "0832762842"
        ],
        "nonMatches": [
            "083 276 2842"
        ],
        "pattern": "^((?:\\+27|27)|0)(=72|82|73|83|74|84)(\\d{7})$",
        "title": "Test"
    },
    {
        "description": "Matches UK postcodes of the below formats. The space is optional. AN NAA AAN NAA ANN NAA ANA NAA AANA NAA AANN NAA",
        "matches": [
            "A11AA",
            "AA1A 1AA",
            "AA11 1AA"
        ],
        "nonMatches": [
            "AAA 1AA",
            "AA11A 1AA",
            "AAA1AA"
        ],
        "pattern": "^(([A-Z]{1,2}[0-9]{1,2})|([A-Z]{1,2}[0-9][A-Z]))\\s?([0-9][A-Z]{2})$",
        "title": "Test"
    },
    {
        "description": "Just test in C#. Validates a China Unicom mobile phone number with (or without) the International code.",
        "matches": [
            "+8613012345678",
            "86 13012345678",
            "13245679087"
        ],
        "nonMatches": [
            "+86130123456781231434352",
            "13560012513",
            "++8613012345678"
        ],
        "pattern": "^(?\u003Cnational\u003E\\+?(?:86)?)(?\u003Cseparator\u003E\\s?-?)(?\u003Cphone\u003E(?\u003Cvender\u003E13[0-4])(?\u003Carea\u003E\\d{4})(?\u003Cid\u003E\\d{4}))$",
        "title": "Test"
    },
    {
        "description": "This is the best RFC 2822 ( http://www.faqs.org/rfcs/rfc2822 ) date format regular expression I could come up with. I\u0027ve tested it, not very extensively though. This regex also validates obsolete standard, excluding comments anywhere.",
        "matches": [
            "Thu, 6 Jan 2005 18:44:56 -0500",
            "Thu, 21 Dec 2000 16:01:07 +0200 (\\(proper\\) \u0026 (nested) comment)"
        ],
        "nonMatches": [
            "Thu, 0 Jan 1856 18: 44:56 -0500",
            "Thu, 21 Dec 2000 16:01:07 +0200 (\\(improper) comment)",
            "blah"
        ],
        "pattern": "^(?:\\s*(Sun|Mon|Tue|Wed|Thu|Fri|Sat),\\s*)?(0?[1-9]|[1-2][0-9]|3[01])\\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s+(19[0-9]{2}|[2-9][0-9]{3}|[0-9]{2})\\s+(2[0-3]|[0-1][0-9]):([0-5][0-9])(?::(60|[0-5][0-9]))?\\s+([-\\+][0-9]{2}[0-5][0-9]|(?:UT|GMT|(?:E|C|M|P)(?:ST|DT)|[A-IK-Z]))(\\s*\\((\\\\\\(|\\\\\\)|(?\u003C=[^\\\\])\\((?\u003CC\u003E)|(?\u003C=[^\\\\])\\)(?\u003C-C\u003E)|[^\\(\\)]*)*(?(C)(?!))\\))*\\s*$",
        "title": "Test"
    },
    {
        "description": "Matches a negative or positive percentage between 0 and 100 (inclusive). Accepts up to 2 decimal places.",
        "matches": [
            "12.34",
            "100.00",
            "-2.1"
        ],
        "nonMatches": [
            "101.1",
            "10.123",
            "100.10"
        ],
        "pattern": "^-?[0-9]{0,2}(\\.[0-9]{1,2})?$|^-?(100)(\\.[0]{1,2})?$",
        "title": "Test"
    },
    {
        "description": "Removes \"stop\" or \"delete\" words that google removes from search strings. Ordinarily have no search significance. I used this to remove the words in my own web search application. Take out the ?: for grouping. I\u0027ve tested this a bit, yet this is my 1st regex that I\u0027ve ever written. It\u0027s working fine for me.",
        "matches": [
            "by",
            "when",
            "or"
        ],
        "nonMatches": [
            "bye",
            "craptastic",
            "nor"
        ],
        "pattern": "\\b(?:a(?:[nst]|re|nd)?|b[ey]|f(?:or|rom)|i[nst]?|o[fnr]|t(?:o|hat|he|his)|w(?:as|h(?:at|en|ere|ich|o)|i(?:th|ll)))\\b",
        "title": "Test"
    },
    {
        "description": "Expression validating a Binary string of any length",
        "matches": [
            "10101000",
            "01010000",
            "100000001"
        ],
        "nonMatches": [
            "01000200",
            "00021000",
            "e10000000"
        ],
        "pattern": "^([0-1])*$",
        "title": "Test"
    },
    {
        "description": "Expression validating a octal string of any length.",
        "matches": [
            "1357",
            "445005",
            "101"
        ],
        "nonMatches": [
            "900508",
            "7FFF",
            "599D"
        ],
        "pattern": "^([0-7])*$",
        "title": "Test"
    },
    {
        "description": "This Blacklist RegEx is designed to search a user input for any malicious code or SQL injection attempts.",
        "matches": [
            "http://www.domain.com/page.asp?param=</script>",
            "https://www.domain.com/page.asp?param=;SELECT"
        ],
        "nonMatches": [
            "https://www.domain.com/page.asp?param=RealParam"
        ],
        "pattern": "(script)|(<)|(>)|(%3c)|(%3e)|(SELECT) |(UPDATE) |(INSERT) |(DELETE)|(GRANT) |(REVOKE)|(UNION)|(&lt;)|(&gt;)",
        "title": "Test"
    },
    {
        "description": "Hex number/string validation method for the Electronic Serial Number(ESN) used in Cellular Phone products.",
        "matches": [
            "8ECCA04F",
            "82E5AAA4",
            "82e5aaa4"
        ],
        "nonMatches": [
            "8ECCAOF",
            "82E5AA4",
            "82e5aaa45"
        ],
        "pattern": "^([0-9a-fA-F]){8}$",
        "title": "Test"
    },
    {
        "description": "Expresion Regular para Tel\u0026#233;fonos con clave lada en M\u0026#233;xico separada o no con guiones o espacios. Sirve para tel\u0026#233;fonos estacionarios y/o celulares, con o sin par\u0026#233;ntesis, 10 n\u0026#250;meros a fuerzas, funciona en .net",
        "matches": [
            "(658)154-1122",
            "6581541122",
            "658-154-1122"
        ],
        "nonMatches": [
            "(658 154 1122",
            "759-1245",
            "875 (489 1568)"
        ],
        "pattern": "^\\(\\d{3}\\) ?\\d{3}( |-)?\\d{4}|^\\d{3}( |-)?\\d{3}( |-)?\\d{4}",
        "title": "Test"
    },
    {
        "description": "Time in 24 hours format with optional seconds",
        "matches": [
            "12:15",
            "10:26:59",
            "22:01:15"
        ],
        "nonMatches": [
            "24:10:25",
            "13:2:60"
        ],
        "pattern": "^(([0-1]?[0-9])|([2][0-3])):([0-5]?[0-9])(:([0-5]?[0-9]))?$",
        "title": "Test"
    },
    {
        "description": "This is a simple expression to check a US street address entered on either one or two lines. Being short it does not check that the road qualifer is \"valid\" (eg. drive, avenue, etc), but it does allow for the extended zip code. A word of warning, the multiline mode can be picky about ending the first line with extra space.",
        "matches": [
            "123 Anywhere Dr. apt #99 Somewhere, ST 55789",
            "123 Anywhere Dr. Somewhere, ST 55789",
            "123 Anywhere D"
        ],
        "nonMatches": [
            "123 Anywhere Drive #99 Somewhere, ST 55789 - 1234",
            "123 Anywhere Dr. apt. #99 Somewhere, ST 55789",
            ""
        ],
        "pattern": "^[ \\w]{3,}([A-Za-z]\\.)?([ \\w]*\\#\\d+)?(\\r\\n| )[ \\w]{3,},\\x20[A-Za-z]{2}\\x20\\d{5}(-\\d{4})?$",
        "title": "Test"
    },
    {
        "description": "Well it pretty much accepts all kinds of users, about the domain i didn\u0027t write it special for any TLD so there\u0027s no length defined, ohh and it accepts some IDN stuff",
        "matches": [
            "afdaas-ddas----asddas____...@asd.asd.asd.asd.asd.com",
            "a@a.aa",
            ".@microsoft.sun.apple.com"
        ],
        "nonMatches": [
            "aaaaaaa@.-com",
            "aaaaaaa@adf.-com",
            "aaaaaaa@"
        ],
        "pattern": "^[\\.\\w\u0026#230;\u0026#248;\u0026#229;-]+@([a-z\u0026#230;\u0026#248;\u0026#229;0-9]+([\\.-]{0,1}[a-z\u0026#230;\u0026#248;\u0026#229;0-9]+|[a-z\u0026#230;\u0026#248;\u0026#229;0-9]?))+\\.[a-z]{2,6}$",
        "title": "Test"
    },
    {
        "description": "Matches month, requires that months 1-9 have a leading 0",
        "matches": [
            "01",
            "02",
            "12"
        ],
        "nonMatches": [
            "1",
            "2",
            "13"
        ],
        "pattern": "^((0[1-9])|(1[0-2]))$",
        "title": "Test"
    },
    {
        "description": "This pattern matches a Valid Civil ID Number in Kuwait.",
        "matches": [
            "175123112345",
            "279020412345"
        ],
        "nonMatches": [
            "479020412345",
            "275043112345"
        ],
        "pattern": "^(1|2|3)((\\d{2}((0[13578]|1[02])(0[1-9]|[12]\\d|3[01])|(0[13456789]|1[012])(0[1-9]|[12]\\d|30)|02(0[1-9]|1\\d|2[0-8])))|([02468][048]|[13579][26])0229)(\\d{5})$",
        "title": "Test"
    },
    {
        "description": "Matches numbers 0 through 99.9 Allows only one preceding zero and does not require the decimal point",
        "matches": [
            "1",
            "1.1",
            "0.1"
        ],
        "nonMatches": [
            "01",
            "01.1",
            "0.10"
        ],
        "pattern": "^([1-9]{0,1})([0-9]{1})(\\.[0-9])?$",
        "title": "Test"
    },
    {
        "description": "regex to validate unix device names (linux). useful for scripts using ifconfig or stuff",
        "matches": [
            "eth0",
            "eth0:4",
            "eth4:9"
        ],
        "nonMatches": [
            "eth0:",
            "eth0:0",
            "eth0:1d"
        ],
        "pattern": "^(eth[0-9]$)|(^eth[0-9]:[1-9]$)",
        "title": "Test"
    },
    {
        "description": "It validates Indian Vehicle Registration Number",
        "matches": [
            "mh 12 bj 1780",
            "mmx 1234"
        ],
        "nonMatches": [
            "mmm 123 1234",
            "mm 12 bj 345",
            "mm 12345"
        ],
        "pattern": "^([A-Z|a-z]{2}\\s{1}\\d{2}\\s{1}[A-Z|a-z]{1,2}\\s{1}\\d{1,4})?([A-Z|a-z]{3}\\s{1}\\d{1,4})?$",
        "title": "Test"
    },
    {
        "description": "This is just a very simple matcher for real numbers.",
        "matches": [
            "123.456",
            ".123",
            "123"
        ],
        "nonMatches": [
            ".",
            "apple",
            "pear"
        ],
        "pattern": "([0-9]+\\.[0-9]*)|([0-9]*\\.[0-9]+)|([0-9]+)",
        "title": "Test"
    },
    {
        "description": "Matches full and compressed IPv6 addresses as defined in RFC 2373 (http://www.faqs.org/rfcs/rfc2373.html). No useful captures. Various implementations require different terminators. (i.e. ^-$ or \\b-\\b)",
        "matches": [
            "FEDC:BA98:7654:3210:FEDC:BA98:7654:3210",
            "1080::8:800:200C:417A",
            "::FFFF:129.144.52.38"
        ],
        "nonMatches": [
            "FEDC::7654:3210::BA98:7654:3210",
            "FEDC:BA98:7654:3210",
            "::"
        ],
        "pattern": "^((([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}:[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){5}:([0-9A-Fa-f]{1,4}:)?[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){4}:([0-9A-Fa-f]{1,4}:){0,2}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){3}:([0-9A-Fa-f]{1,4}:){0,3}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){2}:([0-9A-Fa-f]{1,4}:){0,4}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}((\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b)\\.){3}(\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b))|(([0-9A-Fa-f]{1,4}:){0,5}:((\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b)\\.){3}(\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b))|(::([0-9A-Fa-f]{1,4}:){0,5}((\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b)\\.){3}(\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b))|([0-9A-Fa-f]{1,4}::([0-9A-Fa-f]{1,4}:){0,5}[0-9A-Fa-f]{1,4})|(::([0-9A-Fa-f]{1,4}:){0,6}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){1,7}:))$",
        "title": "Test"
    },
    {
        "description": "DDD Brasileiro no Formato de 2 digitos n\u0026#227;o \u0026#233; aceito zero na primeira casa",
        "matches": [
            "11",
            "12",
            "19"
        ],
        "nonMatches": [
            "01",
            "00"
        ],
        "pattern": "[1-9][0-9]",
        "title": "Test"
    },
    {
        "description": "Combine Michael Ash\u0027s US Dollar amount and Bri Gipson\u0027s eliminating zero input to create this RE to accept Optional leading dollar sign, optional well-formed comma separator dollar amount with no zero amount allowed. *** Correction: Remove the \"+\" otherwise it will incorrectly matches 4 leading digits like 1234,345,678.00 03-03-2005",
        "matches": [
            "$1,234,567.89",
            "1234567.89",
            "$9.99"
        ],
        "nonMatches": [
            "$1,2345,67.89",
            "$1234,345,678.0",
            "0"
        ],
        "pattern": "^(\\$|)([1-9]\\d{0,2}(\\,\\d{3})*|([1-9]\\d*))(\\.\\d{2})?$",
        "title": "Test"
    },
    {
        "description": "Match the full names of the four main characters of The Flintstones.",
        "matches": [
            "Fred Flintstone",
            "Barney Rubble",
            "Betty Rubble"
        ],
        "nonMatches": [
            "The Great Gazoo",
            "Mr. Slate",
            "Dino"
        ],
        "pattern": "^((Fred|Wilma)\\s+Flintstone|(Barney|Betty)\\s+Rubble)$",
        "title": "Test"
    },
    {
        "description": "this will accept multiple email ids separated only by semi-colons (anyway u can change it).",
        "matches": [
            "te_s-t@ts.co.in;te_s-t@ts.co.in;te_s-t@ts.co.in"
        ],
        "nonMatches": [
            "nospace@between.mailids.in ; only@semi.colons.com"
        ],
        "pattern": "^(([a-zA-Z0-9_\\-\\.]+)@([a-zA-Z0-9_\\-\\.]+)\\.([a-zA-Z]{2,5}){1,25})+([;.](([a-zA-Z0-9_\\-\\.]+)@([a-zA-Z0-9_\\-\\.]+)\\.([a-zA-Z]{2,5}){1,25})+)*$",
        "title": "Test"
    },
    {
        "description": "Very simple expression to validate time on a 12 hour clock, this expression is valid for client-side script validations (RegularExpressionValidator - ASP.NET).",
        "matches": [
            "08:00AM",
            "10:00am",
            "7:00pm"
        ],
        "nonMatches": [
            "13:00pm",
            "12:65am"
        ],
        "pattern": "^([1-9]|1[0-2]|0[1-9]){1}(:[0-5][0-9][aApP][mM]){1}$",
        "title": "Test"
    },
    {
        "description": "A short and sweet email address validator. Checks that the username starts and ends with an alphanumeric character, allows a few non-repeating \u0027special characters\u0027 (namely -, ., _, +, &) and checks for a sensible domain name (2-6 character TLD required). Some unconventional, yet technically valid, addresses will not be matched, but this is only a simple expression ;-)",
        "matches": [
            "test@test.com",
            "nerdy.one@science.museum",
            "ready&set@go.com.au"
        ],
        "nonMatches": [
            ".test.@test.com",
            "spammer@[203.12.145.68]",
            "bla@bla"
        ],
        "pattern": "^([0-9a-zA-Z]+[-._+&])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,6}$",
        "title": "Test"
    },
    {
        "description": "it will check for alphanumeric (Alpha Numeric) values.",
        "matches": [
            "adad1213",
            "1231dfadfa",
            "dfad123dfasdfs"
        ],
        "nonMatches": [
            "dfa@#12313",
            "*(*sdfasdfadfd",
            "$fffsdg121ddd#$f1q"
        ],
        "pattern": "^[a-zA-Z0-9]+$",
        "title": "Test"
    },
    {
        "description": "This will find URLs in plain text. With or without protocol. It matches against all toplevel domains to find the URL in the text.",
        "matches": [
            "http://www.website.com/index.html",
            "www.website.com",
            "website.com"
        ],
        "nonMatches": [
            "Works in all my tests. Does not capture protocol."
        ],
        "pattern": "([\\d\\w-.]+?\\.(a[cdefgilmnoqrstuwz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvxyz]|d[ejkmnoz]|e[ceghrst]|f[ijkmnor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eouw]|s[abcdeghijklmnortuvyz]|t[cdfghjkmnoprtvwz]|u[augkmsyz]|v[aceginu]|w[fs]|y[etu]|z[amw]|aero|arpa|biz|com|coop|edu|info|int|gov|mil|museum|name|net|org|pro)(\\b|\\W(?\u003C!\u0026|=)(?!\\.\\s|\\.{3}).*?))(\\s|$)",
        "title": "Test"
    },
    {
        "description": "Litle regexp for my portal engie. Only cut the {CHBLOCK:\u0027modulename\u0027} item",
        "matches": [
            "{CHBLOCK:sdgs}",
            "{CHBLOCK:sdgs}sdg{CHBLOCK:sdgs}"
        ],
        "nonMatches": [
            "{CHBLOCK}",
            "{CHBLOCK:sdgs"
        ],
        "pattern": "\\{CHBLOCK\\:(.*?\\})",
        "title": "Test"
    },
    {
        "description": "dd/MM/yyyy with leap years 100% integrated Valid years : from 1900 to 9999. As usual, many tests have been made. This was requested by a user : http://www.regexlib.com/REDetails.aspx?regexp_id=409",
        "matches": [
            "29/02/2000",
            "30/04/2003",
            "01/01/2003"
        ],
        "nonMatches": [
            "29/02/2001",
            "30-04-2003",
            "1/1/1899"
        ],
        "pattern": "^(((0[1-9]|[12]\\d|3[01])\\/(0[13578]|1[02])\\/((19|[2-9]\\d)\\d{2}))|((0[1-9]|[12]\\d|30)\\/(0[13456789]|1[012])\\/((19|[2-9]\\d)\\d{2}))|((0[1-9]|1\\d|2[0-8])\\/02\\/((19|[2-9]\\d)\\d{2}))|(29\\/02\\/((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))$",
        "title": "Test"
    },
    {
        "description": "This is my attempt to find out valid german postal codes (PLZ or Postleitzahlen). After the German Unification the numbers were changed to a five digit system. The postal codes starts with the two digit \"Leitzahl\". This is a number between 00 and 99 excluding the not yet used numbers: 00, 05, 43 and 62! After that follows directly a three digit number, 000-999. Comments welcome. This works for me, however I think it could be written more compact, but could not figure out how ;-) For more information on german postal codes see: http://de.wikipedia.org/wiki/Liste_der_Postleitbereiche_Deutschland http://de.wikipedia.org/wiki/Postleitzahl_%28Deutschland%29 http://en.wikipedia.org/wiki/List_of_postal_codes_in_Germany",
        "matches": [
            "12556",
            "01550",
            "80796"
        ],
        "nonMatches": [
            "05234",
            "8973",
            "62980"
        ],
        "pattern": "\\b((?:0[1-46-9]\\d{3})|(?:[1-357-9]\\d{4})|(?:[4][0-24-9]\\d{3})|(?:[6][013-9]\\d{3}))\\b",
        "title": "Test"
    },
    {
        "description": "This regular expression allows you to match all image tags",
        "matches": [
            "<img src=\"immy.jpg\" alt=\"Image\">",
            "<img src=\"immy.jpg\" alt=\u0026q"
        ],
        "nonMatches": [
            "< img >"
        ],
        "pattern": "<(\\/{0,1})img(.*?)(\\/{0,1})\\>",
        "title": "Test"
    },
    {
        "description": "Used to match windows filenames. Fails if there is leading or trailing spaces. Fails if the input contains /\\:*?\"<>| . Fails if the input begins or ends with \u0027.\u0027",
        "matches": [
            "Test.txt",
            "T est.txt",
            "Rosco\u0027s.Test.txt"
        ],
        "nonMatches": [
            "\\Folder\\Test.txt",
            "T*est.txt",
            "Test."
        ],
        "pattern": "\\A([A-Za-z0-9\u0027~\u0060!@#$%&^_+=\\(\\){},\\-\\[\\]\\;])+?([ A-Za-z0-9\u0027~\u0060 !@#$%&^_+=\\(\\){},\\-\\[\\];]|([.]))*?(?(3)(([ A-Za-z0-9\u0027~\u0060!@#$ %&^_+=\\(\\){},\\-\\[\\]\\;]*?)([A-Za-z0-9\u0027~\u0060!@#$%&^_+=\\(\\){},\\-\\[ \\];])+\\z)|(\\z))",
        "title": "Test"
    },
    {
        "description": "Simple American date format mm-dd-yyyy or mm-dd-yy, no time. Date range is 1900 --> 2099. Is enough for my purposes. Incorectly validates 02-29-1900. I created this to validate dates on a web form where the likely range will be 2000-->2020. Seperators can be \u0027.\u0027,\u0027/\u0027 or \u0027-\u0027 Anyone know the rules for operator precedence for regex syntax?",
        "matches": [
            "02-29-2004",
            "1/31/1997",
            "1-2-03"
        ],
        "nonMatches": [
            "02-29-2003",
            "04-31-2003",
            "31-03-05"
        ],
        "pattern": "^(((((((0?[13578])|(1[02]))[\\.\\-/]?((0?[1-9])|([12]\\d)|(3[01])))|(((0?[469])|(11))[\\.\\-/]?((0?[1-9])|([12]\\d)|(30)))|((0?2)[\\.\\-/]?((0?[1-9])|(1\\d)|(2[0-8]))))[\\.\\-/]?(((19)|(20))?([\\d][\\d]))))|((0?2)[\\.\\-/]?(29)[\\.\\-/]?(((19)|(20))?(([02468][048])|([13579][26])))))$",
        "title": "Test"
    },
    {
        "description": "Validation of a Folder Name. Excludes all forbidden characters",
        "matches": [
            "321321321 dasds"
        ],
        "nonMatches": [
            "/\\3fsdfsd"
        ],
        "pattern": "^[^\\\\\\/\\?\\*\\\"\\\u0027\\>\\<\\:\\|]*$",
        "title": "Test"
    },
    {
        "description": "yyyyMMdd with leap year validation, starting from year 2000 only. The length of the expression is minimized, but still validates all entries. If you want it with years like 1600 or separators, just ask :)",
        "matches": [
            "20000101",
            "20051231",
            "20040229"
        ],
        "nonMatches": [
            "19990101",
            "20053112",
            "20050229"
        ],
        "pattern": "^([2-9]\\d{3}((0[1-9]|1[012])(0[1-9]|1\\d|2[0-8])|(0[13456789]|1[012])(29|30)|(0[13578]|1[02])31)|(([2-9]\\d)(0[48]|[2468][048]|[13579][26])|(([2468][048]|[3579][26])00))0229)$",
        "title": "Test"
    },
    {
        "description": "yyMMdd with leap years. Minimized expression. As we have only 2 numbers for the years, dates 1600, 2000, etc are still validated.",
        "matches": [
            "001231",
            "000229",
            "040229"
        ],
        "nonMatches": [
            "003112",
            "000431",
            "010229"
        ],
        "pattern": "^(\\d{2}((0[1-9]|1[012])(0[1-9]|1\\d|2[0-8])|(0[13456789]|1[012])(29|30)|(0[13578]|1[02])31)|([02468][048]|[13579][26])0229)$",
        "title": "Test"
    },
    {
        "description": "HHmmss without any separators. Hours in 24h format.",
        "matches": [
            "235959",
            "000000",
            "012345"
        ],
        "nonMatches": [
            "240000",
            "23:59:59",
            "236060"
        ],
        "pattern": "^([01]\\d|2[0123])([0-5]\\d){2}$",
        "title": "Test"
    },
    {
        "description": "This matches all positive decimal values. There was one here already which claimed to but would fail on value 0.00 which is positive AFAIK...",
        "matches": [
            "0.00",
            "1.23",
            "4.56"
        ],
        "nonMatches": [
            "-1.03",
            "-0.01",
            "-0.00"
        ],
        "pattern": "(^\\d*\\.?\\d*[0-9]+\\d*$)|(^[0-9]+\\d*\\.\\d*$)",
        "title": "Test"
    },
    {
        "description": "MM/dd/yyyy with 100% leap year validation starting from year 2000. If this one doesn\u0027t fit your needs, just tell me. Sorry for starting \"only\" from year 2000, this is so simple to change this, please ask if needed. Enjoy",
        "matches": [
            "02/29/2000",
            "02/29/2004",
            "12/31/2001"
        ],
        "nonMatches": [
            "02/29/2100",
            "02/29/2001",
            "1/1/2001"
        ],
        "pattern": "^(((0[1-9]|1[012])/(0[1-9]|1\\d|2[0-8])|(0[13456789]|1[012])/(29|30)|(0[13578]|1[02])/31)/[2-9]\\d{3}|02/29/(([2-9]\\d)(0[48]|[2468][048]|[13579][26])|(([2468][048]|[3579][26])00)))$",
        "title": "Test"
    },
    {
        "description": "Url matching",
        "matches": [
            "http://210.50.2.215/sd_new/WebBuilder.cgi?RegID=7449046&First=Ok&Upt=Ok&EditPage=3&S"
        ],
        "nonMatches": [
            "Hmmmm"
        ],
        "pattern": "\\b([\\d\\w\\.\\/\\+\\-\\?\\:]*)((ht|f)tp(s|)\\:\\/\\/|[\\d\\d\\d|\\d\\d]\\.[\\d\\d\\d|\\d\\d]\\.|www\\.|\\.tv|\\.ac|\\.com|\\.edu|\\.gov|\\.int|\\.mil|\\.net|\\.org|\\.biz|\\.info|\\.name|\\.pro|\\.museum|\\.co)([\\d\\w\\.\\/\\%\\+\\-\\=\\&\\?\\:\\\\\\\"\\\u0027\\,\\|\\~\\;]*)\\b",
        "title": "Test"
    },
    {
        "description": "This regular expression accepts SEDOL (Stock Exchange Daily Official List number, a code used by the London Stock Exchange to identify foreign stocks). To be more exact - it accepts POTENTIAL SEDOL\u0027s, since the last, 7th digit of a sedol is a kind of check-sum digit and this reg-ex doesn\u2019t check\u2019s its correctness. Also, despite following to the formal SEDOL definition - its first character should be a consonant character \u2013 there are actual sedol\u2019s with the first character, which is a number (e.g. 0067340 for BAA) and they are accepted by this reg-ex.",
        "matches": [
            "0067340",
            "B01HL06",
            "4155586"
        ],
        "nonMatches": [
            "12345",
            "34A56B7",
            "456VGHY"
        ],
        "pattern": "(?\u003CSedol\u003E[B-Db-dF-Hf-hJ-Nj-nP-Tp-tV-Xv-xYyZz\\d]{6}\\d)",
        "title": "Test"
    },
    {
        "description": "Here it is, the monster UK Postcode regular expression that should prevent the majority of miskeying. Unlike an most other regexes it only permits valid combinations of letters, e.g. BN works, BM does not. Spaces between the first and second parts are optional. I have tested this against a file of 7,500 valid postcodes, and also against a real-world list of about 12,000 which had some bad data. Manually checking a sample of the rejected ones showed it was working correctly (and how poor the data was!!). I originally started by trying to adapt the GDSC document at http://www.govtalk.gov.uk/gdsc/html/frames/PostCode.htm and specifically their XSD pattern at http://www.govtalk.gov.uk/gdsc/schemaHtml/bs7666-v2-0-xsd-PostCodeType.htm but this turned out to be rather loose. Instead I wrote this. If you find any valid postcodes being rejected by this regex please let me know.",
        "matches": [
            "W1A 1AA",
            "EC2V 1JN",
            "GIR 0AA"
        ],
        "nonMatches": [
            "TB12 1AB",
            "EC2V 1JM",
            "W2A 1AA"
        ],
        "pattern": "(((^[BEGLMNS][1-9]\\d?) | (^W[2-9] ) | ( ^( A[BL] | B[ABDHLNRST] | C[ABFHMORTVW] | D[ADEGHLNTY] | E[HNX] | F[KY] | G[LUY] | H[ADGPRSUX] | I[GMPV] | JE | K[ATWY] | L[ADELNSU] | M[EKL] | N[EGNPRW] | O[LX] | P[AEHLOR] | R[GHM] | S[AEGKL-PRSTWY] | T[ADFNQRSW] | UB | W[ADFNRSV] | YO | ZE ) \\d\\d?) | (^W1[A-HJKSTUW0-9]) | (( (^WC[1-2]) | (^EC[1-4]) | (^SW1) ) [ABEHMNPRVWXY] ) ) (\\s*)? ([0-9][ABD-HJLNP-UW-Z]{2})) | (^GIR\\s?0AA)",
        "title": "Test"
    },
    {
        "description": "Hopefully an all-encompassing expression to validate a URL. Supports an optional protocol, either a domain or IP address, an optional port number and an optional path.",
        "matches": [
            "this.com",
            "https://this.com:8080/this/this.htm",
            "ftp://255.255.255.255/"
        ],
        "nonMatches": [
            ".this.com",
            "https://this.com:/",
            "ftps://255.256.255.255/"
        ],
        "pattern": "^(((ht|f)tp(s?))\\://)?((([a-zA-Z0-9_\\-]{2,}\\.)+[a-zA-Z]{2,})|((?:(?:25[0-5]|2[0-4]\\d|[01]\\d\\d|\\d?\\d)(?(\\.?\\d)\\.)){4}))(:[a-zA-Z0-9]+)?(/[a-zA-Z0-9\\-\\._\\?\\,\\\u0027/\\\\\\+&%\\$#\\=~]*)?$",
        "title": "Test"
    },
    {
        "description": "Modified Joe Lynwood\u0027s to allow zero amounts. Handles US Dollars including zero dollars.",
        "matches": [
            "$1,234,567.89",
            "1234567.89",
            "$0.00"
        ],
        "nonMatches": [
            "$1,2345,67.89",
            "$1234,345,678.0"
        ],
        "pattern": "^(\\$)?(([1-9]\\d{0,2}(\\,\\d{3})*)|([1-9]\\d*)|(0))(\\.\\d{2})?$",
        "title": "Test"
    },
    {
        "description": "Matchs comma delimited numbers. Easily changed to allow for other delimiters. (Edit \",\") Does not allow a leading 0 Does not allow groups of numbers with less than 3 numbers, exculding the first group.",
        "matches": [
            "123,123,123,123",
            "100,120,000,010,011",
            "1,123,123,123"
        ],
        "nonMatches": [
            "012,123,123,123",
            "12343,1244,4,12",
            ",123,123,123"
        ],
        "pattern": "^([1-9]{1}(([0-9])?){2})+(,[0-9]{1}[0-9]{2})*$",
        "title": "Test"
    },
    {
        "description": "Airway bill no that allows only the format 999-99999998 and does not allow the last digit to be 7,8,9.",
        "matches": [
            "999-99999995",
            "123-47859683",
            "156-78965422"
        ],
        "nonMatches": [
            "123-47859689",
            "9999999999",
            "9588-58964"
        ],
        "pattern": "^\\d{3}-\\d{7}[0-6]{1}$",
        "title": "Test"
    },
    {
        "description": "Positive real number greater than zero.",
        "matches": [
            "0.01",
            "010001.011010",
            ".234"
        ],
        "nonMatches": [
            "0.00 OR .",
            "010001.011010E",
            "1.234.5"
        ],
        "pattern": "(^[0-9]*[1-9]+[0-9]*\\.[0-9]*$)|(^[0-9]*\\.[0-9]*[1-9]+[0-9]*$)|(^[0-9]*[1-9]+[0-9]*$)",
        "title": "Test"
    },
    {
        "description": "For the terminally hard of thinking, a version of my UK postcode validator without WHITESPACE. Unlike most validators on regexlib, this knows valid postcode combinations, e.g. W1A is permitted, W1 is not, but W2 is. It should catch between 95-98% of invalid postcodes.",
        "matches": [
            "W1A 1AA",
            "EC1V1JN",
            "N7 8BQ"
        ],
        "nonMatches": [
            "W1A 1AM",
            "BM1 1AB",
            "EC1 1AA"
        ],
        "pattern": "(((^[BEGLMNS][1-9]\\d?)|(^W[2-9])|(^(A[BL]|B[ABDHLNRST]|C[ABFHMORTVW]|D[ADEGHLNTY]|E[HNX]|F[KY]|G[LUY]|H[ADGPRSUX]|I[GMPV]|JE|K[ATWY]|L[ADELNSU]|M[EKL]|N[EGNPRW]|O[LX]|P[AEHLOR]|R[GHM]|S[AEGKL-PRSTWY]|T[ADFNQRSW]|UB|W[ADFNRSV]|YO|ZE)\\d\\d?)|(^W1[A-HJKSTUW0-9])|(((^WC[1-2])|(^EC[1-4])|(^SW1))[ABEHMNPRVWXY]))(\\s*)?([0-9][ABD-HJLNP-UW-Z]{2}))$|(^GIR\\s?0AA$)",
        "title": "Test"
    },
    {
        "description": "Registro Federal de Contribuyentes (RFC) , used in Mexico as a unique set of caracters for a person or corporation registration . Registro Federal de Contribuyentes utilizado en Mexico para el registro en hacienda.",
        "matches": [
            "ABCD790419",
            "ABC790419aa1",
            "ABCD790419AB1"
        ],
        "nonMatches": [
            "AB790419",
            "A12790419",
            "ABC791332"
        ],
        "pattern": "^([A-Z|a-z|&]{3}\\d{2}((0[1-9]|1[012])(0[1-9]|1\\d|2[0-8])|(0[13456789]|1[012])(29|30)|(0[13578]|1[02])31)|([02468][048]|[13579][26])0229)(\\w{2})([A|a|0-9]{1})$|^([A-Z|a-z]{4}\\d{2}((0[1-9]|1[012])(0[1-9]|1\\d|2[0-8])|(0[13456789]|1[012])(29|30)|(0[13578]|1[02])31)|([02468][048]|[13579][26])0229)((\\w{2})([A|a|0-9]{1})){0,3}$",
        "title": "Test"
    },
    {
        "description": "This regexp matches all existing TLDs (Top-Level Domains) according to IANA specifications as of 14/07/2007.",
        "matches": [
            "all ccTLDs (Country-Code Top-Level Domains)",
            "all gTLDs (Generic Top-Level Domains)",
            ".arpa"
        ],
        "nonMatches": [
            "n.o.n - e.x.i.s.t.i.n.g T.L.D.s"
        ],
        "pattern": "(a(?:[cdefgilmnoqrstuwxz]|ero|(?:rp|si)a)|b(?:[abdefghijmnorstvwyz]iz)|c(?:[acdfghiklmnoruvxyz]|at|o(?:m|op))|d[ejkmoz]|e(?:[ceghrstu]|du)|f[ijkmor]|g(?:[abdefghilmnpqrstuwy]|ov)|h[kmnrtu]|i(?:[delmnoqrst]|n(?:fo|t))|j(?:[emop]|obs)|k[eghimnprwyz]|l[abcikrstuvy]|m(?:[acdeghklmnopqrstuvwxyz]|il|obi|useum)|n(?:[acefgilopruz]|ame|et)|o(?:m|rg)|p(?:[aefghklmnrstwy]|ro)|qa|r[eosuw]|s[abcdeghijklmnortuvyz]|t(?:[cdfghjklmnoprtvwz]|(?:rav)?el)|u[agkmsyz]|v[aceginu]|w[fs]|y[etu]|z[amw])",
        "title": "Test"
    },
    {
        "description": "Validates email addresses according to the RFC 822 specification. The only exception is the exclusion of control characters, which should be sufficient for human input from a keyboard.",
        "matches": [
            "Trais.Gray@domain.biz",
            "\u0022Funny email\u0022.notfunny@glxs.biz",
            "ok@[funny domain].co.za"
        ],
        "nonMatches": [
            "\u0022TravisGray\u0022extra@ domain.biz"
        ],
        "pattern": "(?\u003Cuser\u003E(?:(?:[^ \\t\\(\\)\\\u003C\\\u003E@,;\\:\\\\\\\u0022\\.\\[\\]\\r\\n]+)|(?:\\\u0022(?:(?:[^\\\u0022\\\\\\r\\n])|(?:\\\\.))*\\\u0022))(?:\\.(?:(?:[^ \\t\\(\\)\\\u003C\\\u003E@,;\\:\\\\\\\u0022\\.\\[\\]\\r\\n]+)|(?:\\\u0022(?:(?:[^\\\u0022\\\\\\r\\n])|(?:\\\\.))*\\\u0022)))*)@(?\u003Cdomain\u003E(?:(?:[^ \\t\\(\\)\\\u003C\\\u003E@,;\\:\\\\\\\u0022\\.\\[\\]\\r\\n]+)|(?:\\[(?:(?:[^\\[\\]\\\\\\r\\n])|(?:\\\\.))*\\]))(?:\\.(?:(?:[^ \\t\\(\\)\\\u003C\\\u003E@,;\\:\\\\\\\u0022\\.\\[\\]\\r\\n]+)|(?:\\[(?:(?:[^\\[\\]\\\\\\r\\n])|(?:\\\\.))*\\])))*)",
        "title": "Test"
    },
    {
        "description": "MM/dd/yyyy with 100% leap years. Valid since year 1900. MM and DD could have 1 or 2 digits : M/d/yyyy or MM/d/yyyy or M/dd/yyyy This was a request from a user in http://www.regexlib.com/REDetails.aspx?regexp_id=1038",
        "matches": [
            "01/31/1905",
            "1/9/1900",
            "2/29/1904"
        ],
        "nonMatches": [
            "31/01/2005",
            "02/29/2005",
            "2/29/2005"
        ],
        "pattern": "^(((0?[1-9]|1[012])/(0?[1-9]|1\\d|2[0-8])|(0?[13456789]|1[012])/(29|30)|(0?[13578]|1[02])/31)/(19|[2-9]\\d)\\d{2}|0?2/29/((19|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|(([2468][048]|[3579][26])00)))$",
        "title": "Test"
    },
    {
        "description": "it matches dutch zip codes (postcode)",
        "matches": [
            "1234 ab",
            "1234ab",
            "1234AB",
            "1234 AB"
        ],
        "nonMatches": [
            "12341av",
            "1234",
            "123ab",
            "1234a",
            "as"
        ],
        "pattern": "^[1-9]{1}[0-9]{3}\\s?[a-zA-Z]{2}$",
        "title": "Test"
    },
    {
        "description": "This one matches all strings except \"FirstString\" and \"SecondString\"",
        "matches": [
            "AlmostAnything"
        ],
        "nonMatches": [
            "FirstString",
            "SecondString"
        ],
        "pattern": "^(?(FirstString|SecondString)yes|.*)$",
        "title": "Test"
    },
    {
        "description": "Validador de CPF ou CNPJ brasileiro. Utilizado em campos que podem receber os dois valores, como um campo de busca, que pode buscar por CPF ou CNPJ, como era o meu caso. [00.000.000/0000-00], [123.456.789-98],[00000000000000] e [12345678998] Enjoy! =)",
        "matches": [
            "00.000.000/0000-00",
            "123.456.789-98",
            "12345678901234"
        ],
        "nonMatches": [
            "12.123.123.0001.12",
            "123.456.789.89"
        ],
        "pattern": "(^(\\d{2}.\\d{3}.\\d{3}/\\d{4}-\\d{2})|(\\d{14})$)|(^(\\d{3}.\\d{3}.\\d{3}-\\d{2})|(\\d{11})$)",
        "title": "Test"
    },
    {
        "description": "Numera\u0026#231;\u0026#227;o usar para valores moeda brasileira e de outras regi\u0026#245;es. Dinheiro, money... Enjoy! =)",
        "matches": [
            "123,02",
            "123.456,02",
            "123.456.789,02"
        ],
        "nonMatches": [
            "123,003",
            "123,123.02"
        ],
        "pattern": "^([1-9]{1}[\\d]{0,2}(\\.[\\d]{3})*(\\,[\\d]{0,2})?|[1-9]{1}[\\d]{0,}(\\,[\\d]{0,2})?|0(\\,[\\d]{0,2})?|(\\,[\\d]{1,2})?)$",
        "title": "Test"
    },
    {
        "description": "Regex to match valid folder paths. can be local, UNC with server name, or UNC with IP address",
        "matches": [
            "c:\\ds\\dsfsdf",
            "\\\\192.168.14.118\\23423",
            "\\\\fsdf\\23423"
        ],
        "nonMatches": [
            "c:\\",
            "\\\\192.168.12.114",
            "\\\\fff"
        ],
        "pattern": "^((([a-zA-Z]:)|(\\\\{2}\\w+)|(\\\\{2}(?:(?:25[0-5]|2[0-4]\\d|[01]\\d\\d|\\d?\\d)(?(?=\\.?\\d)\\.)){4}))(\\\\(\\w[\\w ]*)))",
        "title": "Test"
    },
    {
        "description": "This regular expression match can be used for validating strong password. It expects atleast 1 small-case letter, 1 Capital letter, 1 digit, 1 special character and the length should be between 6-10 characters. The sequence of the characters is not important. This expression follows the above 4 norms specified by microsoft for a strong password.",
        "matches": [
            "1A2a$5",
            "1234567Tt#",
            "Tsd677%"
        ],
        "nonMatches": [
            "Tt122",
            "1tdfy34564646T*"
        ],
        "pattern": "(?=^.{6,10}$)(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&*()_+}{\":;\u0027?/>.<,])(?!.*\\s).*$",
        "title": "Test"
    },
    {
        "description": "Pattern for Indian Postal Code.",
        "matches": [
            "234 234",
            "234675"
        ],
        "nonMatches": [
            "asd343",
            "4567889",
            "3454 23"
        ],
        "pattern": "^[1-9]{3}\\s{0,1}[0-9]{3}$",
        "title": "Test"
    },
    {
        "description": "Port Numbers: Dynamic and/or Private Ports: 49152 through 65535. Matches numbers in range of 49152 through 65535.",
        "matches": [
            "49152",
            "65535",
            "50000"
        ],
        "nonMatches": [
            "49151",
            "65536",
            "66000"
        ],
        "pattern": "^(6553[0-5]|655[0-2]\\d|65[0-4]\\d\\d|6[0-4]\\d{3}|5\\d{4}|49[2-9]\\d\\d|491[6-9]\\d|4915[2-9])$",
        "title": "Test"
    },
    {
        "description": "Port Numbers: Well Known Ports & Registered Ports: 0 through 49151. Matches numbers in range of 0 through 49151.",
        "matches": [
            "0",
            "1023",
            "49151"
        ],
        "nonMatches": [
            "49152",
            "50000",
            "60000"
        ],
        "pattern": "^(4915[0-1]|491[0-4]\\d|490\\d\\d|4[0-8]\\d{3}|[1-3]\\d{4}|[1-9]\\d{0,3}|0)$",
        "title": "Test"
    },
    {
        "description": "Port Numbers: Well Known Ports, Registered Ports & Dynamic and/or Private Ports: 0 through 65536. Matches numbers in range of 0 through 65536.",
        "matches": [
            "1023",
            "49151",
            "65535"
        ],
        "nonMatches": [
            "65536",
            "66000",
            "67000"
        ],
        "pattern": "^(6553[0-5]|655[0-2]\\d|65[0-4]\\d\\d|6[0-4]\\d{3}|[1-5]\\d{4}|[1-9]\\d{0,3}|0)$",
        "title": "Test"
    },
    {
        "description": "This expression matches only valid html anchors. Those are anchors with an attribute name=. Such anchor can be closed either with </a> or with />. If someone can help - one thing still missing is not matching html tags with parameter href, becazse such should be considered as non valid anchors.",
        "matches": [
            "<a name=\"anchorName\">Anchor</a>",
            "<a name=anchorName />"
        ],
        "nonMatches": [
            "<a href=\"somewhere\">",
            "<a href>",
            "<a name />"
        ],
        "pattern": "<a[a-zA-Z0-9 =\"\u0027.:;?]*(name=){1}[a-zA-Z0-9 =\"\u0027.:;?]*\\s*((/>)|(>[a-zA-Z0-9 =\"\u0027<>.:;?]*</a>))",
        "title": "Test"
    },
    {
        "description": "An expression that matches all XHTML valid hrefs (links). It even alows spaces like href = \"href...\", dough this is not quite XHTML valid. It finds only hrefs but not for instance anchors. If you need to find only anchors, replace \"href\" within expression with \"name\" and thats it.",
        "matches": [
            "<a href=\"www.google.com\">Google</a>",
            "<a href=www.google.com />",
            "<a"
        ],
        "nonMatches": [
            "<a name=\"anchor\">Anchor</a>",
            "<img src=\"image.gif\">"
        ],
        "pattern": "<a[a-zA-Z0-9 =\"\u0027.?_/]*(href\\s*=\\s*){1}[a-zA-Z0-9 =\"\u0027.?_/]*\\s*((/>)|(>[a-zA-Z0-9 =\"\u0027<>.?_/]*</a>))",
        "title": "Test"
    },
    {
        "description": "Dutch licenceplate check also including scooters# ABC123# 12-AB-AB# 12-ABC-1# 1-ABC-12# A-123-AB#",
        "matches": [
            "ABC123",
            "12-AB-AB",
            "12-ABC-1"
        ],
        "nonMatches": [
            "12ABAB",
            "12ABC1",
            "1ABC12"
        ],
        "pattern": "(([a-zA-Z]{3}[0-9]{3})|(\\w{2}-\\w{2}-\\w{2})|([0-9]{2}-[a-zA-Z]{3}-[0-9]{1})|([0-9]{1}-[a-zA-Z]{3}-[0-9]{2})|([a-zA-Z]{1}-[0-9]{3}-[a-zA-Z]{2}))",
        "title": "Test"
    },
    {
        "description": "This pattern will match any multi-line or single line comments in TSQL (Stored Procedures or SPROC\u0027s) in MS SQL Server.",
        "matches": [
            "/* My Comment */",
            "-- A single line comment"
        ],
        "nonMatches": [
            "*/ Won\u0027t work /*",
            "// Not likely",
            "- uh uh"
        ],
        "pattern": "(\\/\\*(\\s*|.*?)*\\*\\/)|(--.*)",
        "title": "Test"
    },
    {
        "description": "This regular expression will find the highest level groups within recursive tokens. For instance, if I have \"This is [just [an] example] of the [expression]\", it\u0027ll find [just [an] example] and [expression], and nothing else. It will also not find an escaped bracket expression. If you want to replace the bracket with curly braces or parenthesis, be careful. As an example, curly braces will be: (?<!\\\\)\\{(\\\\\\{|\\\\\\}|[^\\{\\}]|(?<!\\\\)\\{.*(?<!\\\\)\\})*(?<!\\\\)\\}",
        "matches": [
            "[just]",
            "[just [an] example]"
        ],
        "nonMatches": [
            "\\[just]"
        ],
        "pattern": "(?\u003C!\\\\)\\[(\\\\\\[|\\\\\\]|[^\\[\\]]|(?\u003C!\\\\)\\[.*(?\u003C!\\\\)\\])*(?\u003C!\\\\)\\]",
        "title": "Test"
    },
    {
        "description": "validates a simple ip v4 address. including 0.0.0.0 or 255.255.255.255. leading 0 is and numbers above 255 are forbitten.",
        "matches": [
            "0.0.0.0",
            "255.255.255.255",
            "168.129.2.255"
        ],
        "nonMatches": [
            "02.234.2.1",
            "168.192.0.256",
            "1233.0.0.1"
        ],
        "pattern": "^((\\d|[1-9]\\d|2[0-4]\\d|25[0-5]|1\\d\\d)(?:\\.(\\d|[1-9]\\d|2[0-4]\\d|25[0-5]|1\\d\\d)){3})$",
        "title": "Test"
    },
    {
        "description": "Simply matches a telephone number. Not meant to be extremly accurate but more for q uick match or extracting from a body of text. Does not support extensions",
        "matches": [
            "555 5555",
            "(555) 555-5555",
            "+555 5555555"
        ],
        "nonMatches": [
            "+ 55 5555",
            "() 555 5555"
        ],
        "pattern": "^\\+?\\(?\\d+\\)?(\\s|\\-|\\.)?\\d{1,3}(\\s|\\-|\\.)?\\d{4}$",
        "title": "Test"
    },
    {
        "description": "Allows only positive numbers, greater than zero",
        "matches": [
            "1",
            "10",
            "135"
        ],
        "nonMatches": [
            "0",
            "-1",
            "aaa"
        ],
        "pattern": "^[1-9]+[0-9]*$",
        "title": "Test"
    },
    {
        "description": "This expression was originally developed for user names. Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters: ! @ # $ % ^ & * - . _ ?",
        "matches": [
            "aB!@#%&^$.?*-0123456789Yz",
            "user@somedomain.com",
            "Excla!Us_er"
        ],
        "nonMatches": [
            "1234567890",
            "aB1()[]{};:\u0027\",<>/\\_=0Yz",
            "!exclaUser"
        ],
        "pattern": "(?=^.{6,51}$)([A-Za-z]{1})([A-Za-z0-9!@#$%_\\^\\&\\*\\-\\.\\?]{5,49})$",
        "title": "Test"
    },
    {
        "description": "Matches the 24 clock",
        "matches": [
            "00:00",
            "12:30",
            "23:59"
        ],
        "nonMatches": [
            "24:00",
            "1:00",
            "25:00"
        ],
        "pattern": "^(?([0-1])[0-1][0-9]|2[0-3])\\:[0-5][0-9]$",
        "title": "Test"
    },
    {
        "description": "Matches any positive integer (and blank) between 1 and 100 useful for validating input of a percentage, or nothing.",
        "matches": [
            "100",
            "0",
            "99"
        ],
        "nonMatches": [
            "101",
            "1x",
            "-1"
        ],
        "pattern": "^((100)|(\\d{0,2}))$",
        "title": "Test"
    },
    {
        "description": "This is an extension of already existing expression submitted. It checks for characters, hyphen and single quotes. Single quote and hyphen cannot appear at the beginning or at the end.",
        "matches": [
            "D\u0027Souza",
            "D-Souza",
            "Dsouza"
        ],
        "nonMatches": [
            "\u0027Dsouza",
            "-Dsouza"
        ],
        "pattern": "^[a-zA-Z]+((\\s|\\-|\\\u0027)[a-zA-Z]+)?$",
        "title": "Test"
    },
    {
        "description": "Expression to test for valid postcodes for azerbaijan",
        "matches": [
            "AZ 1234",
            "AZ1234"
        ],
        "nonMatches": [
            "12 abcd",
            "AB 1234"
        ],
        "pattern": "^[A][Z](.?)[0-9]{4}$",
        "title": "Test"
    },
    {
        "description": "This Pattern matches a HTML like tag and its closing tag without any childtags, that was identified by an attribute or anything identifiable (?) mark inside the opening tag. Look for A as Tag and 1 ans identifier. A greedy expression woulds usualy end at the A 2 closing tag, non-greedy will probably end at the A 3 end tag. e.g.: <A 1> <A 2> <A 2>dfgdfg</A> </A> <Z></Z> </A> <A 3> </A> Returns: 0 Full Match 1 Whole starttag 2 Content inside the tag 3 Whole endtag P.S.: I use it in a parser, to find tags and add code to them, without to know the code, the content or any further infomation.",
        "matches": [
            "\u003Ctag name=\u0022identify_by\u0022\u003Ejskdfjkfb\u003C/tag\u003E"
        ],
        "nonMatches": [
            "have a look at the description."
        ],
        "pattern": "(\u003C[^\u003E]*?tag[^\u003E]*?(?:identify_by)[^\u003E]*\u003E)((?:.*?(?:\u003C[ \\r\\t]*tag[^\u003E]*\u003E?.*?(?:\u003C.*?/.*?tag.*?\u003E)?)*)*)(\u003C[^\u003E]*?/[^\u003E]*?tag[^\u003E]*?\u003E)",
        "title": "Test"
    },
    {
        "description": "for getting cdata from and xml document. cdata returns in $1. it\u0027s not perfect as you can see from the non-matching examples. improvements needed - but this works for most scenario\u0027s.",
        "matches": [
            "<![CDATA[ gobbledy gook ]]>",
            "<![CDATA[ gobbledy & more gook ]]>"
        ],
        "nonMatches": [
            "<![CDATA[ gobbledy ] gook ]]>",
            "<![CDATA[ gobbledy ]] gook ]]>"
        ],
        "pattern": "<!\\[CDATA\\[([^\\]]*)\\]\\]>",
        "title": "Test"
    },
    {
        "description": "Returns the three most important attributes from an HTML <input> tag: \u0027type\u0027, \u0027name\u0027 and \u0027value\u0027. Supports attribute values that are double- or single-quoted or unquoted. Returns four references, the first being the name of the attribute, and the other three being the value, of which only one will be populated based on the way the value was quoted.",
        "matches": [
            "<input type=\"text\" value=\u0027somevalue\u0027 name=fred>"
        ],
        "nonMatches": [
            "Any attributes that aren\u0027t \"type\", \"name\", or \"value\""
        ],
        "pattern": "\\s(type|name|value)=(?:(\\w+)|(?:\"(.*?)\")|(?:\\\u0027(.*)\\\u0027))",
        "title": "Test"
    },
    {
        "description": "Very simple (but very useful!) regex to split CSV files. It does not drop the commas - you have to do that manually. Quotes are dealt with properly and escaped quotes are ignored. Matches from sample:this is ;a;\u0022line,\\\u0022in\\\u0022a\u0022;csv;file",
        "matches": [
            "this is ,a,\u0022line,\\\u0022in\\\u0022,a\u0022,csv,file"
        ],
        "nonMatches": [
            "\u0022"
        ],
        "pattern": "((?:[^\u0022,]|(?:\u0022(?:\\\\{2}|\\\\\u0022|[^\u0022])*?\u0022))*)",
        "title": "Test"
    },
    {
        "description": "Telephone number validation. Validates a telephone number which contains either 0-9,(,),+,- and space. Let me know if it works for you. :)",
        "matches": [
            "+(044)-222222",
            "22222",
            "+44 22222"
        ],
        "nonMatches": [
            "A1234",
            "[22222]"
        ],
        "pattern": "^[0-9\\s\\(\\)\\+\\-]+$",
        "title": "Test"
    },
    {
        "description": "Credit Card Matching - Matches Switch, Solo, Visa, MasterCard and Discover. Matches length and valid prefix. Accepts input optional spaces and dashes between number groups",
        "matches": [
            "5154-1234-1234-1342",
            "4444333322221111",
            "6767 1111 1111 1111"
        ],
        "nonMatches": [
            "1234123412341234",
            "1111111",
            "987654321"
        ],
        "pattern": "^((67\\d{2})|(4\\d{3})|(5[1-5]\\d{2})|(6011))-?\\s?\\d{4}-?\\s?\\d{4}-?\\s?\\d{4}|3[4,7]\\d{13}$",
        "title": "Test"
    },
    {
        "description": "Credit Card Validation. Matches Switch/Solo, Visa, MasterCard and Discover in 4-4-4-4/4 4 4 4/4444 format and Amex in 4-6-5/4 6 5/465 format. Includes checks for prefixes, (67 for switch/solo, 4 for visa, 51-55 for MasterCard, 37/34 for Amex and 6011 for Discover. Matches all major UK debit and credit cards with spaces dashes or as a continous number",
        "matches": [
            "4234 1234 1234 1234",
            "5434123412341234",
            "3712 123456 12345"
        ],
        "nonMatches": [
            "1234123412341234",
            "1111111",
            "987654321"
        ],
        "pattern": "^((67\\d{2})|(4\\d{3})|(5[1-5]\\d{2})|(6011))(-?\\s?\\d{4}){3}|(3[4,7])\\d{2}-?\\s?\\d{6}-?\\s?\\d{5}$",
        "title": "Test"
    },
    {
        "description": "Matches Names - written for credit card matching. Optional Prefix that can contain a fullstop, one or more forenames that can contain hyphens and apostrophes followed by a surname that can contain hyphens and apostrophes",
        "matches": [
            "Miss H Ryan",
            "Miss Ryan",
            "Miss Hazel Joanne Ryan"
        ],
        "nonMatches": [
            "Hazel",
            "Hazel Ryan"
        ],
        "pattern": "^[a-z\\.]*\\s?([a-z\\-\\\u0027]+\\s)+[a-z\\-\\\u0027]+$",
        "title": "Test"
    },
    {
        "description": "This Pattern matches HTML attributes with quoted quotes or other non-word characters correctly. I used it in an parser-engine. Replace the quotes in this RX to match other boundaries.",
        "matches": [
            "\u003CHTMLTAG onClick=\u0022jsfunc(\\\u0022foo\\\u0022)\u0022\u003E"
        ],
        "nonMatches": [
            "\u003CHTMLTAG onClick sometext\u003E"
        ],
        "pattern": "(?:[\\w]*) *= *\u0022(?:(?:(?:(?:(?:\\\\\\W)*\\\\\\W)*[^\u0022]*)\\\\\\W)*[^\u0022]*\u0022)",
        "title": "Test"
    },
    {
        "description": "I don\u0027t give a f*** to the RFC, fix it yourself for RFC, I just need a valid webresource location. So add forbidden characters as you need them in the character classes or use it as it is. This RegEx is not for searching valid URLs, just for validating. Look at the trailing $.",
        "matches": [
            "http://www.test.org",
            "http://www.test.org/page1",
            "http://www.test.org/folder/subfolder/page.html?get"
        ],
        "nonMatches": [
            "http://www.test.org%",
            "http://www.test.org/hgh(s/",
            "http://www.test.org/hehe/notallowed\u0026/page1.h"
        ],
        "pattern": "(?:(?:http|https)://(?:(?:[^/\u0026=()/\u00A7, ]*?)*\\.)+(?:\\w{2,3})+?)(?:/+[^ ?,\u0027\u00A7$\u0026()={\\[\\]}]*)*(?:\\?+.*)?$",
        "title": "Test"
    },
    {
        "description": "Here is my first regexp. I hope you like it! It parses quite a few different urls, although it\u0027s not a high-quality regexp. Http, Ftp protocols are supported, parameters and anchors too.",
        "matches": [
            "www.yahoo.com",
            "ftp://user:pass@host.com:123",
            "http://localhost/page2.php?a=b&c=d#hello"
        ],
        "nonMatches": [
            "website.net"
        ],
        "pattern": "((http|ftp|https):\\/\\/w{3}[\\d]*.|(http|ftp|https):\\/\\/|w{3}[\\d]*.)([\\w\\d\\._\\-#\\(\\)\\[\\]\\\\,;:]+@[\\w\\d\\._\\-#\\(\\)\\[\\]\\\\,;:])?([a-z0-9]+.)*[a-z\\-0-9]+.([a-z]{2,3})?[a-z]{2,6}(:[0-9]+)?(\\/[\\/a-z0-9\\._\\-,]+)*[a-z0-9\\-_\\.\\s\\%]+(\\?[a-z0-9=%&\\.\\-,#]+)?",
        "title": "Test"
    },
    {
        "description": "Matches the XSD schema duration built in type as defined by http://www.w3.org/TR/xmlschema-2/#duration",
        "matches": [
            "P12Y03M12D",
            "-P4343D",
            "-PT343H23M2323.232S"
        ],
        "nonMatches": [
            "34Y3434M23D",
            "P2323DT"
        ],
        "pattern": "^[-]?P(?!$)(?:\\d+Y)?(?:\\d+M)?(?:\\d+D)?(?:T(?!$)(?:\\d+H)?(?:\\d+M)?(?:\\d+(?:\\.\\d+)?S)?)?$",
        "title": "Test"
    },
    {
        "description": "International Bank Account Number (IBAN) Germany. Identify Bank account in Germany.",
        "matches": [
            "DE89 3704 0044 0532 0130 00",
            "DE89370400440532013000"
        ],
        "nonMatches": [
            "DE89-3704-0044-0532-0130-00"
        ],
        "pattern": "DE\\d{2}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}[ ]\\d{2}|DE\\d{20}",
        "title": "Test"
    },
    {
        "description": "International Bank Account Number (IBAN) Poland. Identify Bank account in Poland.",
        "matches": [
            "PL27 1140 2004 0000 3002 0135 5387",
            "PL27114020040000300201355387"
        ],
        "nonMatches": [
            "PL27-1140-2004-0000-3002-0135-5387"
        ],
        "pattern": "PL\\d{2}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}|PL\\d{26}",
        "title": "Test"
    },
    {
        "description": "Validation of a directory (not file) in UNC format Checks for \\\\server\\share\\subdir, where subdirs are optional. Share may have a $, but only at the end. Shares and subdir may have embedded spaces. String may optionally have a trailing slash.",
        "matches": [
            "\\\\server\\my share\\my subdir",
            "\\\\server\\my share$\\",
            "\\\\server\\my share\\subdir1\\subdir2\\"
        ],
        "nonMatches": [
            "c:\\subdir",
            "\\\\my server\\share$",
            "\\\\myserver\\share\\subdir\\file.ext"
        ],
        "pattern": "^\\\\\\\\[\\w-]+\\\\(([\\w()-][\\w\\s()-]*[\\w()-]+)|([\\w()-]+))\\$?(\\\\(([\\w()-][\\w\\s()-]*[\\w()-]+)|([\\w()-]+)))*\\\\?$",
        "title": "Test"
    },
    {
        "description": "This regexp matches string which represents a fraction. This fraction can be in these forms:\u003Cbr /\u003E 1. # or -# (not -0)\u003Cbr /\u003E 2. #/# or -#/# (not -0/#)\u003Cbr /\u003E 3. # #/# or -# #/# (not -0 #/#)",
        "matches": [
            "-1, 1, -1/2, 1/2, -1 2/3, 1 2/3",
            "0, 0/1, 1/0, 1 0/2, 1 2/0"
        ],
        "nonMatches": [
            "letters",
            "negative zero",
            "/",
            "#/",
            "/#",
            "# /",
            "# #/",
            "# /#"
        ],
        "pattern": "(?:-(?!0))?\\d+(?:(?: \\d+)?/\\d+)?",
        "title": "Test"
    },
    {
        "description": "Matches TCP port numbers from 0 to 65535. Other than \u00270\u0027, no leading 0\u0027s are accepted.",
        "matches": [
            "0",
            "1000",
            "65535"
        ],
        "nonMatches": [
            "65536",
            "99999",
            "0123"
        ],
        "pattern": "^(0|([1-9]\\d{0,3}|[1-5]\\d{4}|[6][0-5][0-5]([0-2]\\d|[3][0-5])))$",
        "title": "Test"
    },
    {
        "description": "This Regular Expression matches all valid ip-patterns. 01.02.03.04 is not matched, as leading zeros is not valid a ip-pattern. 255.255.255.0 is not matched, as 255 is a broadcast identifier, and as such not allowed in ip-patterns.",
        "matches": [
            "192.168.10.4",
            "130.225.56.40",
            "127.0.0.1"
        ],
        "nonMatches": [
            "01.02.03.04",
            "255.255.255.0",
            "abc.def.ghi.jkl"
        ],
        "pattern": "^((25[0-4]|(2[0-4]|1[0-9]|[1-9]?)[0-9]\\.){3}(25[0-4]|(2[0-4]|1[0-9]|[1-9]?)[0-9]))$",
        "title": "Test"
    },
    {
        "description": "Path of files HTML and HTM",
        "matches": [
            "c:\\arquivo.html",
            "\\\\home\\arquivo232.HTML",
            "Z:\\teste.htm"
        ],
        "nonMatches": [
            "c:\\arquivo.png",
            "arquivo232.HTML",
            "Z:\\teste"
        ],
        "pattern": "^(([a-zA-Z]:)|(\\\\{2}\\w+)\\$?)(\\\\(\\w[\\w ]*.*))+\\.((html|HTML)|(htm|HTM))$",
        "title": "Test"
    },
    {
        "description": "used to match standard province codes in upper case.",
        "matches": [
            "ON"
        ],
        "nonMatches": [
            "ONT"
        ],
        "pattern": "^(^N[BLSTU]$)|(^[AMN]B$)|(^[BQ]C$)|(^ON$)|(^PE$)|(^SK$)$",
        "title": "Test"
    },
    {
        "description": "Matches Canadian provincial codes. Similar to the one already posted but smaller, faster, and will correctly return the results in one match group rather than using several so it\u0027s much friendlier.",
        "matches": [
            "ON",
            "PE",
            "NB"
        ],
        "nonMatches": [
            "OB",
            "NM"
        ],
        "pattern": "^(N[BLSTU]|[AMN]B|[BQ]C|ON|PE|SK)$",
        "title": "Test"
    },
    {
        "description": "Australian mobile phone number",
        "matches": [
            "0412345678"
        ],
        "nonMatches": [
            "0299999999"
        ],
        "pattern": "^04[0-9]{8}",
        "title": "Test"
    },
    {
        "description": "An expression to look for numbers that repeat 3 or more times in succession.",
        "matches": [
            "122234567",
            "1234444444",
            "12345999"
        ],
        "nonMatches": [
            "123456",
            "1335855",
            "1983464"
        ],
        "pattern": "0{3,}|1{3,}|2{3,}|3{3,}|4{3,}|5{3,}|6{3,}|7{3,}|8{3,}|9{3,}",
        "title": "Test"
    },
    {
        "description": "match valid ip",
        "matches": [
            "192.168.0.1",
            "10.0.0.255",
            "211.100.0.0"
        ],
        "nonMatches": [
            "192.256.0.1",
            "10.0.0.256",
            "211.100.0.1000"
        ],
        "pattern": "\\b(((?!\\d\\d\\d)\\d+|1\\d\\d|2[0-4]\\d|25[0-5])(\\b|\\.)){4}",
        "title": "Test"
    },
    {
        "description": "Substitute that regex with null to clean up emails witch got replied 1000 times and are Fed up with a lot of >\u0027s first i wanted to make a class out of (\\n|^) (something like [\\n^] - but that doesnt work :( )",
        "matches": [
            "\u003E"
        ],
        "nonMatches": [
            "\u003C"
        ],
        "pattern": "(?\u003C=(\\n|^))(\u003E\\s*)+",
        "title": "Test"
    },
    {
        "description": "Parse html tags to extract tag names and parameters with parameter name/value pairs.",
        "matches": [
            "\u003Ctd valign=\u0022top\u0022 align=\u0022left\u0022 colspan=\u00222\u0022\u003E"
        ],
        "nonMatches": [
            "\u003C!--dynamic_content GlobalID=49113--\u003E"
        ],
        "pattern": "(?\u003CTAG\u003E\\s*\u003C(?\u003CTAG_NAME\u003E\\w*)\\s+(?\u003CPARAMETERS\u003E(?\u003CPARAMETER\u003E(?\u003CPARAMETER_NAME\u003E\\w*)(=[\u0022\u0027]?)(?\u003CVALUE\u003E[\\w\\W\\d]*?)[\u0022\u0027]?)+)\\s*/?\u003E)",
        "title": "Test"
    },
    {
        "description": "I just couldn\u0027t find any simple expression to check if an entered value is a jp(e)g. If you\u0027re using this to check for e.g. mp3, just use the following: (.*\\mp3|.*\\.MP3) This expression is not really stable, cause it will also match file.jpg.mp3 or stuff like that.",
        "matches": [
            "*.JPG",
            "*.jpeg"
        ],
        "nonMatches": [
            ".gif"
        ],
        "pattern": "(.*\\.jpe?g|.*\\.JPE?G)",
        "title": "Test"
    },
    {
        "description": "validate comma separated key/value pair",
        "matches": [
            "foo=bar",
            "foo1=bar1,foo2=bar2",
            "foo1=bar1,foo2=bar2,"
        ],
        "nonMatches": [
            "foo=",
            "foo1=bar1 foo2=bar2",
            "foo1=bar1foo2=bar2"
        ],
        "pattern": "^(\\w+=[^\\s,=]+,)*(\\w+=[^\\s,=]+,?)?$",
        "title": "Test"
    },
    {
        "description": "Patr\u0026#243;n para el esquema de las galas de los Oscars.",
        "matches": [
            "atuvwdxyzadkbcefdghijd"
        ],
        "nonMatches": [
            "wz"
        ],
        "pattern": "^(atuvwdxyzad|abcefdghijd|almnodpqrsd|a\u00DF?ded???\u00B5d?p?sd)(ktuvwdxyzad|kbcefdghijd|klmnodpqrsd|k\u00DF?ded???\u00B5d?p?sd)*",
        "title": "Test"
    },
    {
        "description": "For credit card numbers from MC, Visa, Amex, Diners/CarteBlanche, Discover/Novus, Enroute, and JCB. Does as much as I feel is possible using regex (doesn\u0027t do MOD 10). Javascript safe.",
        "matches": [
            "341-1111-1111-1111",
            "5431-1111-1111-1111",
            "30569309025904"
        ],
        "nonMatches": [
            "30-5693-0902-5904",
            "5631-1111-1111-1111",
            "31169309025904"
        ],
        "pattern": "^3(?:[47]\\d([ -]?)\\d{4}(?:\\1\\d{4}){2}|0[0-5]\\d{11}|[68]\\d{12})$|^4(?:\\d\\d\\d)?([ -]?)\\d{4}(?:\\2\\d{4}){2}$|^6011([ -]?)\\d{4}(?:\\3\\d{4}){2}$|^5[1-5]\\d\\d([ -]?)\\d{4}(?:\\4\\d{4}){2}$|^2014\\d{11}$|^2149\\d{11}$|^2131\\d{11}$|^1800\\d{11}$|^3\\d{15}$",
        "title": "Test"
    },
    {
        "description": "Accurate IP address verification... Each numeric part of an IP address must be between 0 and 255. All patterns I have seen on the net cover this range but they allow leading zeros. The valid cases are: * 0 * 1, 10-19 and 100-199 aka 1[0-9]{0,2} * 2 and 20-29 aka 2[0-9]? * 200-249 aka 2[0-4][0-9] * 250-255 aka 25[0-5] * 3-9 and 30-99 aka [3-9][0-9]?",
        "matches": [
            "10.0.0.0",
            "195.167.1.119",
            "255.255.255.255"
        ],
        "nonMatches": [
            "010.0.0.0",
            "195.167.01.119",
            "256.20.55.23"
        ],
        "pattern": "((0|1[0-9]{0,2}|2[0-9]?|2[0-4][0-9]|25[0-5]|[3-9][0-9]?)\\.){3}(0|1[0-9]{0,2}|2[0-9]?|2[0-4][0-9]|25[0-5]|[3-9][0-9]?)",
        "title": "Test"
    },
    {
        "description": "Accurate Australian postal code verification. Australia has 4-digit numeric postal codes with the following state based specific ranges. ACT: 0200-0299 and 2600-2639. NSW: 1000-1999, 2000-2599 and 2640-2914. NT: 0900-0999 and 0800-0899. QLD: 9000-9999 and 4000-4999. SA: 5000-5999. TAS: 7800-7999 and 7000-7499. VIC: 8000-8999 and 3000-3999. WA: 6800-6999 and 6000-6799.",
        "matches": [
            "0200",
            "7312",
            "2415"
        ],
        "nonMatches": [
            "0300",
            "7612",
            "2915"
        ],
        "pattern": "(0[289][0-9]{2})|([1345689][0-9]{3})|(2[0-8][0-9]{2})|(290[0-9])|(291[0-4])|(7[0-4][0-9]{2})|(7[8-9][0-9]{2})",
        "title": "Test"
    },
    {
        "description": "Accurate Canadian postal code format verification. The format of a Canadian postal code is LDL DLD where L are alpha characters and D are numeric digits. But there are some exceptions. The letters D, F, I, O, Q and U never appear in a postal code because of their visual similarity to 0, E, 1, 0, 0, and V respectively. In addition to avoiding the six \"forbidden\" letters W and Z also do not appear as the first letter of a postal code (at least not at present).",
        "matches": [
            "M1R 4B0",
            "L0R 1B1",
            "L0R1B9"
        ],
        "nonMatches": [
            "W1R 4B0",
            "L0R 1D1",
            "LOR1B9"
        ],
        "pattern": "([ABCEGHJKLMNPRSTVXY][0-9][ABCEGHJKLMNPRSTVWXYZ])\\ ?([0-9][ABCEGHJKLMNPRSTVWXYZ][0-9])",
        "title": "Test"
    },
    {
        "description": "Accurate German postal code verification. Germany has 5-digit numeric postal codes. The expression evaluates a postal code within state based specific ranges.",
        "matches": [
            "01125"
        ],
        "nonMatches": [
            "34125"
        ],
        "pattern": "((0[13-7]|1[1235789]|[257][0-9]|3[0-35-9]|4[0124-9]|6[013-79]|8[0124-9]|9[0-5789])[0-9]{3}|10([2-9][0-9]{2}|1([2-9][0-9]|11[5-9]))|14([01][0-9]{2}|715))",
        "title": "Test"
    },
    {
        "description": "Accurate UK postal code format verification. UK postal codes have two parts. The right part is formatted as DLL (L:letter D:digit) and the left part has six alternative formats: LD, LDL, LDD, LLD, LLDL and LLDD. There is only one exception to these formats: GIR 0AA.",
        "matches": [
            "M2 5BQ",
            "EC1A 1HQ",
            "GIR 0AA"
        ],
        "nonMatches": [
            "M2 BQ5",
            "E31A 1HQ",
            "GIR0AA"
        ],
        "pattern": "(([A-Z]{1,2}[0-9][0-9A-Z]?)\\ ([0-9][A-Z]{2}))|(GIR\\ 0AA)",
        "title": "Test"
    },
    {
        "description": "VAT Numbers format verification (Estonia, Germany, Greece, Portugal) with support for optional member state definition.",
        "matches": [
            "DE123456789",
            "224466880"
        ],
        "nonMatches": [
            "DE12345678",
            "22446688B"
        ],
        "pattern": "((EE|EL|DE|PT)-?)?[0-9]{9}",
        "title": "Test"
    },
    {
        "description": "VAT Numbers format verification (Finland, Hungary, Luxemburg, Malta, Slovenia) with support for optional member state definition.",
        "matches": [
            "HU12345678",
            "22446688"
        ],
        "nonMatches": [
            "HU1234567",
            "224466BB"
        ],
        "pattern": "((FI|HU|LU|MT|SI)-?)?[0-9]{8}",
        "title": "Test"
    },
    {
        "description": "VAT Numbers format verification (Poland, Slovakia) with support for optional member state definition.",
        "matches": [
            "PL1234567890",
            "1234567890"
        ],
        "nonMatches": [
            "PL123456789",
            "123456789O"
        ],
        "pattern": "((PL|SK)-?)?[0-9]{10}",
        "title": "Test"
    },
    {
        "description": "VAT Numbers format verification (Italy, Latvia) with support for optional member state definition.",
        "matches": [
            "IT12345678901",
            "12345678901"
        ],
        "nonMatches": [
            "IT1234567890",
            "1234567890I"
        ],
        "pattern": "((IT|LV)-?)?[0-9]{11}",
        "title": "Test"
    },
    {
        "description": "VAT Numbers format verification (Sweden) with support for optional member state definition.",
        "matches": [
            "SE123456789012",
            "123456789012"
        ],
        "nonMatches": [
            "SE12345678901",
            "123456789O12"
        ],
        "pattern": "(SE-?)?[0-9]{12}",
        "title": "Test"
    },
    {
        "description": "VAT Numbers format verification (Belgium) with support for optional member state definition.",
        "matches": [
            "BE123456789",
            "0123456789"
        ],
        "nonMatches": [
            "BE12345678",
            "O123456789"
        ],
        "pattern": "(BE-?)?0?[0-9]{9}",
        "title": "Test"
    },
    {
        "description": "VAT Numbers format verification (Cyprus) with support for optional member state definition.",
        "matches": [
            "CY12345678A",
            "12345678A"
        ],
        "nonMatches": [
            "CY1234567A",
            "123456789"
        ],
        "pattern": "(CY-?)?[0-9]{8}[A-Z]",
        "title": "Test"
    },
    {
        "description": "VAT Numbers format verification (Czech Republic) with support for optional member state definition.",
        "matches": [
            "CZ12345678",
            "1234567890"
        ],
        "nonMatches": [
            "CZ1234567",
            "12345678901"
        ],
        "pattern": "(CZ-?)?[0-9]{8,10}",
        "title": "Test"
    },
    {
        "description": "VAT Numbers format verification (Denmark) with support for optional member state definition.",
        "matches": [
            "DK11 22 33 44"
        ],
        "nonMatches": [
            "DK11223344"
        ],
        "pattern": "(DK-?)?([0-9]{2}\\ ?){3}[0-9]{2}",
        "title": "Test"
    },
    {
        "description": "VAT Numbers format verification (Spain) with support for optional member state definition.",
        "matches": [
            "ES01234567A",
            "A12345678"
        ],
        "nonMatches": [
            "ES012345678",
            "AB2345678"
        ],
        "pattern": "(ES-?)?([0-9A-Z][0-9]{7}[A-Z])|([A-Z][0-9]{7}[0-9A-Z])",
        "title": "Test"
    },
    {
        "description": "VAT Numbers format verification (France) with support for optional member state definition.",
        "matches": [
            "FRAB 123456789",
            "L7 123456789"
        ],
        "nonMatches": [
            "FRAB123456789",
            "L7 L23456789"
        ],
        "pattern": "(FR-?)?[0-9A-Z]{2}\\ ?[0-9]{9}",
        "title": "Test"
    },
    {
        "description": "VAT Numbers format verification (United Kingdom) with support for optional member state definition.",
        "matches": [
            "GB123 1234 12",
            "GBGD123",
            "123 1234 12 123"
        ],
        "nonMatches": [
            "GB123123412",
            "GBGD1234",
            "023 1234 12 123"
        ],
        "pattern": "(GB-?)?([1-9][0-9]{2}\\ ?[0-9]{4}\\ ?[0-9]{2})|([1-9][0-9]{2}\\ ?[0-9]{4}\\ ?[0-9]{2}\\ ?[0-9]{3})|((GD|HA)[0-9]{3})",
        "title": "Test"
    },
    {
        "description": "VAT Numbers format verification (Ireland) with support for optional member state definition.",
        "matches": [
            "IE4*12345Z",
            "0012345K"
        ],
        "nonMatches": [
            "IE4-12345Z",
            "00123456"
        ],
        "pattern": "(IE-?)?[0-9][0-9A-Z\\+\\*][0-9]{5}[A-Z]",
        "title": "Test"
    },
    {
        "description": "VAT Numbers format verification (Lithuania) with support for optional member state definition.",
        "matches": [
            "LT123456789",
            "123456789012"
        ],
        "nonMatches": [
            "LX123456789",
            "123466789O12"
        ],
        "pattern": "(LT-?)?([0-9]{9}|[0-9]{12})",
        "title": "Test"
    },
    {
        "description": "VAT Numbers format verification (The Netherlands) with support for optional member state definition.",
        "matches": [
            "NL123456789B12"
        ],
        "nonMatches": [
            "NL123456789012"
        ],
        "pattern": "(NL-?)?[0-9]{9}B[0-9]{2}",
        "title": "Test"
    },
    {
        "description": "US 10-Digit Phone number matching. *Requires Area Code *Brackets optional, supports: () and [] *seperators optional, supports: - and . *whitespace optional",
        "matches": [
            "6105551515",
            "(610) 555 - 1212",
            "[610]555.1212"
        ],
        "nonMatches": [
            "1 (610) 555-1212",
            "(610) 555-1212 ext*"
        ],
        "pattern": "^\\s*([\\(]?)\\[?\\s*\\d{3}\\s*\\]?[\\)]?\\s*[\\-]?[\\.]?\\s*\\d{3}\\s*[\\-]?[\\.]?\\s*\\d{4}$",
        "title": "Test"
    },
    {
        "description": "this Expression use conditional expression to eveluate parameter after \"HREF\" and executes the yes/no part of the expression. this expression finds <A> TAG and returns value of \"HREF\" and the value hold in between <a></a> tags. the expression returns maximum 3 sub matches. the first match returns the \"HREF\" tag value and rest of two holds the value of the tag alternativly. so after executing the expression you need to itarate through all the submatches and need to find out non NULL tags to get value. the output of the above matching expamples would be like this : 1: \"/url?sa=p&pref=ig&pval=2&q=http://www.google.co.in/ig%3Fhl%3Den\" 2:[Personalized Home] 3:[] or NULL the output of the second matching example would be like this. 1:/advanced_search?hl=en 2:[] or NULL 3:[Advanced Search]",
        "matches": [
            "<a href=\"/url?sa=p&pref=ig&pval=2&q=http://www.google.co.in/ig%3Fhl%3Den\" o"
        ],
        "nonMatches": [
            "none"
        ],
        "pattern": "<a.*?href=(.*?)(?((?:\\s.*?)>.*?</a>)(?:(?:\\s.*?)>(.*?)</a>)|(?:>(.*?)</a>))",
        "title": "Test"
    },
    {
        "description": "Checks domain names. This will match all of the valid domains. It will accept TLD\u0027s that are from 2 to 6 characters. You can not have more then one dash or period next to each other. Also it will not let you have dashes at end of the words.",
        "matches": [
            "www.domain.com",
            "your-domain.com",
            "www.sub-domain.your-domain.museum"
        ],
        "nonMatches": [
            ".domain.com",
            "your---domain.com",
            "www.-sub-.com"
        ],
        "pattern": "^(([a-zA-Z0-9]+([\\-])?[a-zA-Z0-9]+)+(\\.)?)+[a-zA-Z]{2,6}$",
        "title": "Test"
    },
    {
        "description": "Matches standard rgb syntax for web colors",
        "matches": [
            "rgb(255,255,255)",
            "rgb(0,0,0)",
            "rgb(50,50,50)"
        ],
        "nonMatches": [
            "rgb(0,0,)",
            "(0,0,0)",
            "rgb(255,10%,100)"
        ],
        "pattern": "^rgb\\(([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\,([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\,([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\)$ #Matches standard web rgb pattern",
        "title": "Test"
    },
    {
        "description": "Matches the HTML \"target\" attribute. I had an editor that edited pages but whe wysiwyg editor would break on link that had a target to say \"_top\" or another window. So I needed an expression to match the target attribute on links in HTML.",
        "matches": [
            "target = \"_top\"",
            "target = _top",
            "target = \"foo\""
        ],
        "nonMatches": [
            "target foo",
            "target \"foo\"",
            "target = \"\""
        ],
        "pattern": "target[ ]*[=]([ ]*)([\"]|[\u0027])*([_])*([A-Za-z0-9])+([\"])*",
        "title": "Test"
    },
    {
        "description": "Password validator that validates the password contains 1 letter (regardless of case) and 1 number",
        "matches": [
            "Password1",
            "1Password",
            "1Password1"
        ],
        "nonMatches": [
            "*Password1",
            "*1Password*",
            "*1Password1*"
        ],
        "pattern": "^(([a-zA-Z]+\\d+)|(\\d+[a-zA-Z]+))[a-zA-Z0-9]*$",
        "title": "Test"
    },
    {
        "description": "uri",
        "matches": [
            "www.itera.ws",
            "http://www.webmaster-tool-collection.com:80/te-.stit&a=1"
        ],
        "nonMatches": [
            "192.168.1.1"
        ],
        "pattern": "((((http[s]?|ftp)[:]//)([a-zA-Z0-9.-]+([:][a-zA-Z0-9.&%$-]+)*@)?[a-zA-Z][a-zA-Z0-9.-]+|[a-zA-Z][a-zA-Z0-9]+[.][a-zA-Z][a-zA-Z0-9.-]+)[.](com|edu|gov|mil|net|org|biz|pro|info|name|museum|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|az|ax|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cs|cu|cv|cx|cy|cz|de|dj|dk|dm|do|dz|ec|ee|eg|eh|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ro|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|st|sv|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|um|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|yu|za|zm|zw)([:][0-9]+)*(/[a-zA-Z0-9.,;?\u0027\\\\+&%$#=~_-]+)*)",
        "title": "Test"
    },
    {
        "description": "This Regular Expression allows the user to enter a value to represent the imperial measurement of Inches. The expression won\u0027t allow and value of 12 or above (otherwise it would be a foot!), and has the option of having a decimal value upto 2 decimal places. My first Regular Expression so go easy on me!! :)",
        "matches": [
            "11.99",
            "05.5",
            "5"
        ],
        "nonMatches": [
            "12",
            "12.00",
            "2.587"
        ],
        "pattern": "^((0?[1-9])|((1)[0-1]))?((\\.[0-9]{0,2})?|0(\\.[0-9]{0,2}))$",
        "title": "Test"
    },
    {
        "description": "retrieve any tag and its content",
        "matches": [
            "\u003Cbalise\u003Etoto\u003C/balise\u003E"
        ],
        "nonMatches": [
            "\u003Cbalise\u003Etoto"
        ],
        "pattern": "(\u003C *balise[ *\u003E|:(.|\\n)*\u003E| (.|\\n)*\u003E](.|\\n)*\u003C/balise *\u003E)",
        "title": "Test"
    },
    {
        "description": "Basically I didn\u0027t like any of the regular expressions that were available because they all failed at parsing them into variables correctly... This regular expression gives you the full match and then the 3 sections of digits seperately.",
        "matches": [
            "(000) 000-0000, 0000000000, 000.000.0000"
        ],
        "nonMatches": [
            "000/000/0000, 00a.000.000, +000.000.0000"
        ],
        "pattern": "^\\(?([0-9]{3})\\)?[\\s\\.\\-]*([0-9]{3})[\\s\\.\\-]*([0-9]{4})$",
        "title": "Test"
    },
    {
        "description": "This will match any valid RFC2822 e-mail address typed into web forms. If does not support comments, display name, or line folding. It does support quoted-strings in the local-part and domains by the RFC 1035 and proper ip addresses. It does relax the RFC1035 rule of not allowing numbers as the first character of a domain name (since they do exist in real life)",
        "matches": [
            "six@yahoo.com",
            "six.\u0022Hello\\ There\u0022@yahoo.com",
            "six@192.168.0.1",
            "Most any valid e-mail"
        ],
        "nonMatches": [
            "Don\u0027t know any"
        ],
        "pattern": "^([A-Za-z0-9\\!\\#\\$\\%\\\u0026\\\u0027\\*\\+\\-\\/\\=\\?\\^\\_\\\u0060\\{\\}\\|\\~]+|\u0022([\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x21\\x23-\\x5B\\x5D-\\x7F]|\\\\[\\x0-\\x7F])*\u0022)(\\.([A-Za-z0-9\\!\\#\\$\\%\\\u0026\\\u0027\\*\\+\\-\\/\\=\\?\\^\\_\\\u0060\\{\\}\\|\\~]+|\u0022([\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x21\\x23-\\x5B\\x5D-\\x7F]|\\\\[\\x0-\\x7F])*\u0022))*@([A-Za-z0-9]([A-Za-z0-9\\-]*[A-Za-z0-9])?(\\.[A-Za-z0-9]([A-Za-z0-9\\-]*[A-Za-z0-9])?)*|(1[0-9]{0,2}|2([0-4][0-9]?|5[0-4]?|[6-9])?|[3-9][0-9]?)(\\.(0|1[0-9]{0,2}|2([0-4][0-9]?|5[0-5]?|[6-9])?|[3-9][0-9]?)){2}\\.(1[0-9]{0,2}|2([0-4][0-9]?|5[0-4]?|[6-9])?|[3-9][0-9]?))$",
        "title": "Test"
    },
    {
        "description": "this spam kontrol Fw[number] blocked.",
        "matches": [
            "Fw[9]",
            "Re[8]",
            "re[12]",
            "fw[3]"
        ],
        "nonMatches": [
            "Fw:",
            "abc",
            "tuncay"
        ],
        "pattern": "^[a-zA-Z]{1,3}\\[([0-9]{1,3})\\]",
        "title": "Test"
    },
    {
        "description": "i\u00E7inde @ isareti ve en az 1 tane \u0022.\u0022 olmayanlar kabul edilmez.",
        "matches": [
            "abc@abc.com",
            "aa@aa.com.tr gibi"
        ],
        "nonMatches": [
            "abc.com",
            "abc@aa"
        ],
        "pattern": "([a-zA-Z0-9._-]+@[a-zA-Z0-9._-]+\\.[a-zA-Z0-9._-]+)",
        "title": "Test"
    },
    {
        "description": "I needed a regex for validating URLs, couldn\u0027t find a suitable one, so wrote this, with comments! It matches any valid web URL (Address or IP, with or without protocol), including optional port number, directory path, filname.extension and any paramater pairs. Hope it helps, even if just to understand expressions easier!",
        "matches": [
            "www.test.com",
            "http://www.test.com",
            "234.232.12.23:8080",
            "sub.test.com/dir/file.ext?param=val\u0026param2=val2"
        ],
        "nonMatches": [
            "/file.htm",
            "256.0.0.0"
        ],
        "pattern": "(?#WebOrIP)((?#protocol)((http|https):\\/\\/)?(?#subDomain)(([a-zA-Z0-9]+\\.(?#domain)[a-zA-Z0-9\\-]+(?#TLD)(\\.[a-zA-Z]+){1,2})|(?#IPAddress)((25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[0-9])))+(?#Port)(:[1-9][0-9]*)?)+(?#Path)((\\/((?#dirOrFileName)[a-zA-Z0-9_\\-\\%\\~\\+]+)?)*)?(?#extension)(\\.([a-zA-Z0-9_]+))?(?#parameters)(\\?([a-zA-Z0-9_\\-]+\\=[a-z-A-Z0-9_\\-\\%\\~\\+]+)?(?#additionalParameters)(\\\u0026([a-zA-Z0-9_\\-]+\\=[a-z-A-Z0-9_\\-\\%\\~\\+]+)?)*)?",
        "title": "Test"
    },
    {
        "description": "Matches any legal java class (inclusive package name).",
        "matches": [
            "java.lang.Object paCKage.myClass99"
        ],
        "nonMatches": [
            "package.5Class"
        ],
        "pattern": "^[a-zA-Z]([a-zA-Z0-9])*([\\.][a-zA-Z]([a-zA-Z0-9])*)*$",
        "title": "Test"
    },
    {
        "description": "I needed a regex to parse PHP functions, so I made it and here it is. It will not validate with array variables as the function arguments.",
        "matches": [
            "myfunction(\u0027string\u0027, \u0022another\u0022, 123 ,$var2, CONSTANT )"
        ],
        "nonMatches": [
            "my=function(\u0027str\u0027ing\u0027, $1var, 133t,$array[2] )"
        ],
        "pattern": "^\\s*\\w+\\s*\\((\\s*((\u0022|\u0027)([^\\3]+|\\\\\\3)\\3|\\$?[a-zA-Z_\\x7f-\\xff][a-zA-Z0-9_\\x7f-\\xff]|[0-9]*)\\s*,?)*\\s*\\)",
        "title": "Test"
    },
    {
        "description": "A pretty decent URL matching expression. I\u0027ve followed most RFC guidelines, so it\u0027ll match most anything ya throw at it (And wont match what it\u0027s not supposed to). If you see any problems with it, please email me so I can make the appropriate changes :)",
        "matches": [
            "http://www.domain.com",
            "http://domain.com",
            "http://domain.com",
            "https://domain.com",
            "https://sub.domain-name.com:8080",
            "http://domain.com/dir%201/dir_2/program.ext?var1=x\u0026var2=my%20value",
            "domain.com/index.html#bookmark"
        ],
        "nonMatches": [
            "Normal Text.",
            "http://a.com",
            "http://www.domain-.com"
        ],
        "pattern": "(([\\w]+:)?//)?(([\\d\\w]|%[a-fA-f\\d]{2,2})+(:([\\d\\w]|%[a-fA-f\\d]{2,2})+)?@)?([\\d\\w][-\\d\\w]{0,253}[\\d\\w]\\.)+[\\w]{2,4}(:[\\d]+)?(/([-+_~.\\d\\w]|%[a-fA-f\\d]{2,2})*)*(\\?(\u0026?([-+_~.\\d\\w]|%[a-fA-f\\d]{2,2})=?)*)?(#([-+_~.\\d\\w]|%[a-fA-f\\d]{2,2})*)?",
        "title": "Test"
    },
    {
        "description": "Simple regular expression for creating an IRC client. This will parse the raw octet stream into message segments and groups that make it easy to build a client.",
        "matches": [
            ":irc.server.com 001 someguy :welcome to the IRC server"
        ],
        "nonMatches": [
            "*** : Connecting to server"
        ],
        "pattern": "(?\u003Craw_message\u003E\\:(?\u003Csource\u003E((?\u003Cnick\u003E[^!]+)![~]{0,1}(?\u003Cuser\u003E[^@]+)@)?(?\u003Chost\u003E[^\\s]+)) (?\u003Ccommand\u003E[^\\s]+)( )?(?\u003Cparameters\u003E[^:]+){0,1}(:)?(?\u003Ctext\u003E[^\\r^\\n]+)?)",
        "title": "Test"
    },
    {
        "description": "\u003Cb\u003EMAC Address Validator\u003C/b\u003E\u003Cbr\u003E\u003Cbr\u003EWorks with \u0022:\u0022 linux style separator or \u0022-\u0022 windows style separator and groups each octet to the corresponding group.\u003Cbr\u003EQuite extensive, but functional.\u003Cbr\u003E\u003Cbr\u003EAny suggestions, feel free to comment.\u003Cbr\u003E\u003Cbr\u003E",
        "matches": [
            "00-00-00-00-00-00"
        ],
        "nonMatches": [
            "00-00-00-00-00-GG"
        ],
        "pattern": "^(?:(?\u00271\u0027[0-9a-fA-F]{2})(?:\\:)(?\u00272\u0027[0-9a-fA-F]{2})(?:\\:)(?\u00273\u0027[0-9a-fA-F]{2})(?:\\:)(?\u00274\u0027[0-9a-fA-F]{2})(?:\\:)(?\u00275\u0027[0-9a-fA-F]{2})(?:\\:)(?\u00276\u0027[0-9a-fA-F]{2}))$|^(?:(?\u00271\u0027[0-9a-fA-F]{2})(?:\\-)(?\u00272\u0027[0-9a-fA-F]{2})(?:\\-)(?\u00273\u0027[0-9a-fA-F]{2})(?:\\-)(?\u00274\u0027[0-9a-fA-F]{2})(?:\\-)(?\u00275\u0027[0-9a-fA-F]{2})(?:\\-)(?\u00276\u0027[0-9a-fA-F]{2}))$",
        "title": "Test"
    },
    {
        "description": "This is useful for finding contact numbers, or mobile numbers or phone numbers while crawling websites.",
        "matches": [
            "123-12-1233",
            "(02717)230464",
            "+919427237800",
            "+9427237800",
            "02717-230464"
        ],
        "nonMatches": [
            "23046",
            "123456780123456790000"
        ],
        "pattern": "[\\+]{0,1}(\\d{10,13}|[\\(][\\+]{0,1}\\d{2,}[\\13)]*\\d{5,13}|\\d{2,6}[\\-]{1}\\d{2,13}[\\-]*\\d{3,13})",
        "title": "Test"
    },
    {
        "description": "This pattern is a slight modification in pattern submitted by Jacek Sompel. Using this tag one can also match anchor tags not having \u0027 (single quote) or \u0022 (double quote) in href. This is useful for web crawler for crawling all links in a web page.",
        "matches": [
            "<a href=\u0027http://www.regexlib.com\u0027>Text</a>",
            "<a href=\u0022...\u0022>Text</a>",
            "<a href=http://www.regexlib.com>Text</a>"
        ],
        "nonMatches": [
            "all other html tags"
        ],
        "pattern": "\u003Ca[\\s]+[^\u003E]*?href[\\s]?=[\\s\\\u0022\\\u0027]*(.*?)[\\\u0022\\\u0027]*.*?\u003E([^\u003C]+|.*?)?\u003C\\/a\u003E",
        "title": "Test"
    },
    {
        "description": "This will find any XML within a string starting with the \u003C?xml header and ending with the closing root tag. Replace \u003C/note\u003E with your closing root tag. (use singleline and case insensitive) - I use this to pull xml written in a web document.",
        "matches": [
            "\u003C?xml version=\u00221.0\u0022 encoding=\u0022ISO-8859-1\u0022?\u003E\u003Cnote\u003E\u003Cto\u003ETove\u003C/to\u003E\u003Cfrom\u003EJani\u003C/from\u003E\u003Cheading\u003EReminder\u003C/heading\u003E\u003Cbody\u003EDon\u0027t forget me this weekend!\u003C/body\u003E\u003C/note\u003E"
        ],
        "nonMatches": [
            "\u003C?xml version=\u00221.0\u0022 encoding=\u0022ISO-8859-1\u0022?\u003E\u003Cnote\u003E\u003Cto\u003ETove\u003C/to\u003E\u003Cfrom\u003EJani\u003C/from\u003E\u003Cheading\u003EReminder\u003C/heading\u003E\u003Cbody\u003EDon\u0027t forget me this weekend!\u003C/body\u003E\u003C/BADnote\u003E"
        ],
        "pattern": "\u003C\\?xml.*\u003C/note\u003E",
        "title": "Test"
    },
    {
        "description": "This pattern can be used to validate a numeric week (between 01 and 52) and four digit year (valid years between 1000 and 2999) separated by a slash in the form of WW/YYYY.",
        "matches": [
            "47/2006"
        ],
        "nonMatches": [
            "00/3005"
        ],
        "pattern": "^(([1-4][0-9])|(0[1-9])|(5[0-2]))\\/[1-2]\\d{3}$",
        "title": "Test"
    },
    {
        "description": "Maximum 2 digits followed by an optional comma and a valid quarter to be used in time calculations. I wasn\u0027t satisfied with the quarter regex posted earlier by Bob Kranson.",
        "matches": [
            "1,25 3,75 4,5 7 9,0"
        ],
        "nonMatches": [
            "1.25 1,4 100,50"
        ],
        "pattern": "^\\d{1,2}((,)|(,25)|(,50)|(,5)|(,75)|(,0)|(,00))?$",
        "title": "Test"
    },
    {
        "description": "This was made for use in javascript to detect MMDDYYYY formatted text. It tests all valid dates, including 31 vs 30 days in a month and the 28 vs 29 leap year rules which exclude centennial years not divisible by 400 and years not divisible by 4.",
        "matches": [
            "02292000"
        ],
        "nonMatches": [
            "02291700"
        ],
        "pattern": "^((((((0[13578])|(1[02]))[\\s\\.\\-\\/\\\\]?((0[1-9])|([12][0-9])|(3[01])))|(((0[469])|(11))[\\s\\.\\-\\/\\\\]?((0[1-9])|([12][0-9])|(30)))|((02)[\\s\\.\\-\\/\\\\]?((0[1-9])|(1[0-9])|(2[0-8]))))[\\s\\.\\-\\/\\\\]?(((([2468][^048])|([13579][^26]))00)|(\\d\\d\\d[13579])|(\\d\\d[02468][^048])|(\\d\\d[13579][^26])))|(((((0[13578])|(1[02]))[\\s\\.\\-\\/\\\\]?((0[1-9])|([12][0-9])|(3[01])))|(((0[469])|(11))[\\s\\.\\-\\/\\\\]?((0[1-9])|([12][0-9])|(30)))|((02)[\\s\\.\\-\\/\\\\]?((0[1-9])|([12][0-9]))))[\\s\\.\\-\\/\\\\]?(((([2468][048])|([13579][26]))00)|(\\d\\d[2468][048])|(\\d\\d[13579][26])|(\\d\\d0[48]))))$",
        "title": "Test"
    },
    {
        "description": "Regex to match the ISO Date Format. The time part is optional, including the seconds, as are all of the delimiters (although they must be non-numeric). Each part of the date will be returned as a selection e.g. \\1 will contain the Year, \\2 will contain the Month.",
        "matches": [
            "2006-12-31 17:58:00",
            "20061231175800",
            "2006-12-31"
        ],
        "nonMatches": [
            "2006-13-36 25:61:62"
        ],
        "pattern": "^(\\d{4})\\D?(0[1-9]|1[0-2])\\D?([12]\\d|0[1-9]|3[01])(\\D?([01]\\d|2[0-3])\\D?([0-5]\\d)\\D?([0-5]\\d)?)?$",
        "title": "Test"
    },
    {
        "description": "Should match prices with or without a dollar sign.",
        "matches": [
            "4.42",
            "$4.42"
        ],
        "nonMatches": [
            "asdf"
        ],
        "pattern": "^[$]?[0-9]*(\\.)?[0-9]?[0-9]?$",
        "title": "Test"
    },
    {
        "description": "Validates an RFC 2822 email address, except does not allow most punctuation and non-ascii alphanumeric characters. Also does not take length requirements into account. Allows domain name and IP addresses, but ensures that the IP address entered is valid.",
        "matches": [
            "user@domain.com",
            "user@127.0.0.1",
            "user@[127.0.0.1]",
            "user.id@domain-name.extension",
            "\u0022user\u0022@domain.com"
        ],
        "nonMatches": [
            "userdomain.com",
            "user@300.0.0.1",
            "user@[127.0.0.1",
            ".user@-domain-.com",
            "user@\u0022domain.com\u0022"
        ],
        "pattern": "^(?:(?#local-part)(?#quoted)\u0022[^\\\u0022]*\u0022|(?#non-quoted)[a-z0-9\u0026+_-](?:\\.?[a-z0-9\u0026+_-]+)*)@(?:(?#domain)(?#domain-name)[a-z0-9](?:[a-z0-9-]*[a-z0-9])*(?:\\.[a-z0-9](?:[a-z0-9-]*[a-z0-9])*)*|(?#ip)(\\[)?(?:[01]?\\d?\\d|2[0-4]\\d|25[0-5])(?:\\.(?:[01]?\\d?\\d|2[0-4]\\d|25[0-5])){3}(?(1)\\]|))$",
        "title": "Test"
    },
    {
        "description": "Matches any unsigned floating point number/numeric string.",
        "matches": [
            "123",
            "3.14159"
        ],
        "nonMatches": [
            "abc",
            "-3.14159",
            "3.4.2",
            ".234",
            "."
        ],
        "pattern": "^\\d+(\\.\\d+)?$",
        "title": "Test"
    },
    {
        "description": "A regular expression which allows me to find strings of text floating around in free text that are in fact URLs. I need to tag these as <url>www.bmj.com/advice</url>. The problem has been allowing special characters in the url, but not mixing them up with genuine punctuation marks at the end of the url in the text-e.g. \u0027.\u0027 or \u0027?\u0027 or ) or \u0027;\u0027 etc)",
        "matches": [
            "www.bmjpg.com/advice\u0026search=?light+dark"
        ],
        "nonMatches": [
            "www.bmjpg.com/advice\u0026search=?light+dark?"
        ],
        "pattern": "((www|http)(\\W+\\S+[^).,:;?\\]\\} \\r\\n$]+))",
        "title": "Test"
    },
    {
        "description": "UK phone number formats with optional international prefix, optional spaces, dashes and brackets. Brackets mandatory for regional/capital leading zero if included in international form. Based on \u0022Mh\u0022 UK London \u0026 Regional. (Thanks Mh for the groundwork). New to Regex so I\u0027m sure it can be done more elegantly... but it works.",
        "matches": [
            "0208-123-4567",
            "01234-567890",
            "(01234) 567890",
            "+44 (0)1234 567890",
            "+044(0)1234567890"
        ],
        "nonMatches": [
            "208-123-4567",
            "012345-67890",
            "(1234) 567890",
            "44 (0)1234 567890",
            "+034(0)1234567890"
        ],
        "pattern": "^\\s*\\(?((\\+0?44)?\\)?[ \\-]?(\\(0\\))|0)((20[7,8]{1}\\)?[ \\-]?[1-9]{1}[0-9]{2}[ \\-]?[0-9]{4})|([1-8]{1}[0-9]{3}\\)?[ \\-]?[1-9]{1}[0-9]{2}[ \\-]?[0-9]{3}))\\s*$",
        "title": "Test"
    },
    {
        "description": "Matches any valid e-mail... Kind of large, but worth it to those who really care............email, e-mail, e mail",
        "matches": [
            "Any Valid E-Mail"
        ],
        "nonMatches": [
            "Any Non-Valid E-Mail"
        ],
        "pattern": "/^([a-z0-9])(([\\-.]|[_]+)?([a-z0-9]+))*(@)([a-z0-9])((([-]+)?([a-z0-9]+))?)*((.[a-z]{2,3})?(.[a-z]{2,6}))$/i",
        "title": "Test"
    },
    {
        "description": "Checks that the input is a positive integer in the range 0-32767",
        "matches": [
            "32767",
            "0",
            "999"
        ],
        "nonMatches": [
            "99999",
            "-1",
            "abc"
        ],
        "pattern": "^(3276[0-7]|327[0-5]\\d|32[0-6]\\d{2}|3[01]\\d{3}|[12]\\d{4}|[1-9]\\d{3}|[1-9]\\d{2}|[1-9]\\d|\\d)$",
        "title": "Test"
    },
    {
        "description": "This pattern matches the password from a SQL Server connection string.",
        "matches": [
            "server=(local);password=\u0027O\u0027\u0027Brian\u0027;"
        ],
        "nonMatches": [
            "invalid connection strings"
        ],
        "pattern": "(pwd|password)\\s*=\\s*(?\u003Cpwd\u003E(\u0027(([^\u0027])|(\u0027\u0027))+\u0027|[^\u0027;]+))",
        "title": "Test"
    },
    {
        "description": "Matches all IPV6 and IPV4 addresses. Doesn\u0027t limit IPV4 to just values of 255. Doesn\u0027t allow IPV6 compression.",
        "matches": [
            "0:123:af00:ffff:0C67:0:0:8787",
            "0:0:0:0:0:0:0:1",
            "0.0.0.1",
            "999.999.999.999"
        ],
        "nonMatches": [
            "::1"
        ],
        "pattern": "([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4}|(\\d{1,3}\\.){3}\\d{1,3}",
        "title": "Test"
    },
    {
        "description": "This pattern can intercept img like \u003C img src=\u0022src1\u0022 alt=\u0022alt1\u0022\u003E or \u003C img alt=\u0022alt1\u0022 src=\u0022src1\u0022\u003E or \u003C img src=\u0022src1\u0022\u003E or \u003C img src=\u0022src1\u0022 width=3 height=4\u003E then values of src can be found in $5 or $8, the value of tag alt can be found in $3 or $10.",
        "matches": [
            "\u003C img src=\u0022src 1\u0022 alt=\u0022alt 1\u0022\u003E or \u003C img src=\u0022src 2\u0022\u003E or \u003C img src=\u0022src 3\u0022 alt=\u0022alt 3\u0022 width=2 height=3\u003E"
        ],
        "nonMatches": [
            "any other tag"
        ],
        "pattern": "\u003Cimg[\\s]+[^\u003E]*?((alt*?[\\s]?=[\\s\\\u0022\\\u0027]+(.*?)[\\\u0022\\\u0027]+.*?)|(src*?[\\s]?=[\\s\\\u0022\\\u0027]+(.*?)[\\\u0022\\\u0027]+.*?))((src*?[\\s]?=[\\s\\\u0022\\\u0027]+(.*?)[\\\u0022\\\u0027]+.*?\u003E)|(alt*?[\\s]?=[\\s\\\u0022\\\u0027]+(.*?)[\\\u0022\\\u0027]+.*?\u003E)|\u003E)",
        "title": "Test"
    },
    {
        "description": "Matches the app relative path of a file. This will work for relative paths of URLs. Not very complicated but will work to do basic validation.",
        "matches": [
            "~/myPage.htm",
            "~/123._aBc2",
            "~/Hello_World-Page.aspx"
        ],
        "nonMatches": [
            "mybadPage.htm",
            "~/.Not",
            "~/Very.",
            "~/Good"
        ],
        "pattern": "^~/[0-9a-zA-Z_][0-9a-zA-Z/_-]*\\.[0-9a-zA-Z_-]+$",
        "title": "Test"
    },
    {
        "description": "This pattern could intercept the value of the tag title in every web pages, it could be found in $1.",
        "matches": [
            "\u003Ctitle\u003Ethis title\u003C/title\u003E"
        ],
        "nonMatches": [
            "any other tags"
        ],
        "pattern": "\u003Ctitle\u003E+(.*?)\u003C/title\u003E",
        "title": "Test"
    },
    {
        "description": "This pattern intercept meta tags, the name can be found in $1 the content value in $2.",
        "matches": [
            "\u003Cmeta name=\u0022Author\u0022 content=\u0022xxxxxx\u0022\u003E\u003Cmeta name=\u0022description\u0022 content=\u0022xxxxxxxxx\u0022\u003E\u003Cmeta name=\u0022keywords\u0022 content=\u0022xxxxxxxxx\u0022\u003E\u003Cmeta name=\u0022country\u0022 content=\u0022IT\u0022\u003E"
        ],
        "nonMatches": [
            "any other tags"
        ],
        "pattern": "\u003Cmeta[\\s]+[^\u003E]*?name[\\s]?=[\\s\\\u0022\\\u0027]+(.*?)[\\s\\\u0022\\\u0027]+content[\\s]?=[\\s\\\u0022\\\u0027]+(.*?)[\\\u0022\\\u0027]+.*?\u003E",
        "title": "Test"
    },
    {
        "description": "The goal of my regular expression is to allow me to break apart IP Table log files so that I can build a basic web front-end to allow me to view the traffic on the network. The MAC address is optional, because the way that this firewall works, is by providing the MAC address when the outbound address is not available.",
        "matches": [
            "Jul 20 13:05:08 123.123.123.123 kernel: Shorewall:loc2net:REJECT:IN=eth0 OUT=eth1 SRC=444.333.222.111 DST=111.222.333.444 LEN=59 TOS=0x00 PREC=0x00 TTL=127 ID=12267 PROTO=UDP SPT=2121 DPT=53 LEN=39"
        ],
        "nonMatches": [
            "Anything Else"
        ],
        "pattern": "^(?\u003CDate\u003E.+\\s\\d+\\s\\d+\\:\\d+\\:\\d+).+\\:.+\\:(?\u003CTraffic\u003E.+)\\:(?\u003CRule\u003E.+)\\:IN\\=(?\u003CInboundInterface\u003E.+)\\sOUT\\=(?\u003COutboundIntercace\u003E.*?)\\s(?:MAC\\=(?\u003CMacAddress\u003E.+)\\s|)SRC\\=(?\u003CSource\u003E.+)\\sDST\\=(?\u003CDestination\u003E.+)\\sLEN\\=.+TOS\\=.+PROTO\\=(?\u003CProtocol\u003E.+)\\sSPT\\=(?\u003CSourcePort\u003E.+)\\sDPT\\=(?\u003CDestinationPort\u003E.+)\\s.+$",
        "title": "Test"
    },
    {
        "description": "This regex find valid \u003Ch1-6\u003E html tags",
        "matches": [
            "\u003Ch2\u003Etest2\u003C/h2\u003E\u003Ch3\u003Etest3\u003C/h3\u003E"
        ],
        "nonMatches": [
            "\u003Ch\u003Etest1\u003C/h\u003E"
        ],
        "pattern": "\u003Ch([1-6])\u003E([^\u003C]*)\u003C/h([1-6])\u003E",
        "title": "Test"
    },
    {
        "description": "This is a robust email validation: the username part conforms with RFC 2822 (for instance, emails with tags (\u0022+\u0022) are validated). The host part is checked for valid subdomains and its TLD is checked against all the 243 countries codes and the 14 ICANN\u0027sTLDs. The host part also accepts IP with or without brackets.",
        "matches": [
            "john+nospam@house.comjohn-doe@room.house.combill@[207.46.130.108] bill@204.46.130.108john@mycountry-is.fr"
        ],
        "nonMatches": [
            "john-doe@room.house-.combill@[207.46.130.108 bill@204.46.130.108.241john@fakecountry.zz"
        ],
        "pattern": "^((([a-z]|[0-9]|!|#|$|%|\u0026|\u0027|\\*|\\+|\\-|/|=|\\?|\\^|_|\u0060|\\{|\\||\\}|~)+(\\.([a-z]|[0-9]|!|#|$|%|\u0026|\u0027|\\*|\\+|\\-|/|=|\\?|\\^|_|\u0060|\\{|\\||\\}|~)+)*)@((((([a-z]|[0-9])([a-z]|[0-9]|\\-){0,61}([a-z]|[0-9])\\.))*([a-z]|[0-9])([a-z]|[0-9]|\\-){0,61}([a-z]|[0-9])\\.(af|ax|al|dz|as|ad|ao|ai|aq|ag|ar|am|aw|au|at|az|bs|bh|bd|bb|by|be|bz|bj|bm|bt|bo|ba|bw|bv|br|io|bn|bg|bf|bi|kh|cm|ca|cv|ky|cf|td|cl|cn|cx|cc|co|km|cg|cd|ck|cr|ci|hr|cu|cy|cz|dk|dj|dm|do|ec|eg|sv|gq|er|ee|et|fk|fo|fj|fi|fr|gf|pf|tf|ga|gm|ge|de|gh|gi|gr|gl|gd|gp|gu|gt| gg|gn|gw|gy|ht|hm|va|hn|hk|hu|is|in|id|ir|iq|ie|im|il|it|jm|jp|je|jo|kz|ke|ki|kp|kr|kw|kg|la|lv|lb|ls|lr|ly|li|lt|lu|mo|mk|mg|mw|my|mv|ml|mt|mh|mq|mr|mu|yt|mx|fm|md|mc|mn|ms|ma|mz|mm|na|nr|np|nl|an|nc|nz|ni|ne|ng|nu|nf|mp|no|om|pk|pw|ps|pa|pg|py|pe|ph|pn|pl|pt|pr|qa|re|ro|ru|rw|sh|kn|lc|pm|vc|ws|sm|st|sa|sn|cs|sc|sl|sg|sk|si|sb|so|za|gs|es|lk|sd|sr|sj|sz|se|ch|sy|tw|tj|tz|th|tl|tg|tk|to|tt|tn|tr|tm|tc|tv|ug|ua|ae|gb|us|um|uy|uz|vu|ve|vn|vg|vi|wf|eh|ye|zm|zw|com|edu|gov|int|mil|net|org|biz|info|name|pro|aero|coop|museum|arpa))|(((([0-9]){1,3}\\.){3}([0-9]){1,3}))|(\\[((([0-9]){1,3}\\.){3}([0-9]){1,3})\\])))$",
        "title": "Test"
    },
    {
        "description": "This is a more robust regex for matching Chemical Abstract Service (CAS) Numbers. This distinguishes between CAS numbers and other identifiers (e.g. EC number).",
        "matches": [
            "50-00-0"
        ],
        "nonMatches": [
            "200-001-8"
        ],
        "pattern": "\\b[1-9]{1}[0-9]{1,5}-\\d{2}-\\d\\b",
        "title": "Test"
    },
    {
        "description": "CEP do Brasil com separa\u00E7\u00E3o ex: 99999-999",
        "matches": [
            "99999-999"
        ],
        "nonMatches": [
            "999999-99"
        ],
        "pattern": "^\\d{5}(\\-)(\\d{3})?$",
        "title": "Test"
    },
    {
        "description": "US Phone number with optional leading 1, optional area code, and optional delimiters (hyphen, space or period)",
        "matches": [
            "18005551212 1.800.555.1212 1-800-555-1212 (800)555-1212 8005551212 800-555-1212 800.555.1212 5551212 555-1212 555.1212"
        ],
        "nonMatches": [
            "2-800-555-1212 55-51212 551212 15551212"
        ],
        "pattern": "^1?[-\\. ]?(\\(\\d{3}\\)?[-\\. ]?|\\d{3}?[-\\. ]?)?\\d{3}?[-\\. ]?\\d{4}$",
        "title": "Test"
    },
    {
        "description": "It matches an IP address only in the correct format. There was a previous regex send which matches 192.168.01.2 but this code won\u0027t match preceeding 0\u0027s",
        "matches": [
            "192.168.1.2",
            "127.0.0.1"
        ],
        "nonMatches": [
            "192.168.01.2",
            "1921.68.1.2"
        ],
        "pattern": "/^(?:(?:1\\d?\\d|[1-9]?\\d|2[0-4]\\d|25[0-5])\\.){3}(?:1\\d?\\d|[1-9]?\\d|2[0-4]\\d|25[0-5])$/",
        "title": "Test"
    },
    {
        "description": "Had to handle both \u0022,\u0022 and \u0022.\u0022 as separator in a validationscript where values are between 0.0 and 2.0 like in results of Swedish H\u00F6gskoleprov (SAT).",
        "matches": [
            "0,0",
            "0.0",
            "1,9",
            "2.0"
        ],
        "nonMatches": [
            "2,1",
            "1",
            "3",
            "a"
        ],
        "pattern": "^([0-1](?:\\.\\d)|[0-1](?:\\,\\d)|(2\\.0)|(2\\,0))$",
        "title": "Test"
    },
    {
        "description": "Percent regulaar expression.",
        "matches": [
            "100 1.25 25,8%"
        ],
        "nonMatches": [
            "456 -8 7r ,"
        ],
        "pattern": "^100$|^\\s*(\\d{0,2})((\\.|\\,)(\\d*))?\\s*\\%?\\s*$",
        "title": "Test"
    },
    {
        "description": "Very flexible US phone number entry. -- There are many valid ways to enter a phone number, and often there is other data that a restrictive Regex pattern will not abide. -- This pattern accepts any number of letters, commas, pound signs, slashes, spaces, periods, parenthesis, hyphens, plus signs, and asterisks... but amongst it scans for a minimum of 10 digits, the first and fourth of which cannot be 0 or 1 (per US phone number standards in 2006). -- Data in excess of the 10 required digits is allowed.",
        "matches": [
            "987-654-3210",
            "(555) 555-1212",
            "(555) 487-1391 x652",
            "phn (555) 987-6743 ext. 21012"
        ],
        "nonMatches": [
            "123 456-7890",
            "(555) 000-1111"
        ],
        "pattern": "^([a-zA-Z,#/ \\.\\(\\)\\-\\+\\*]*[2-9])([a-zA-Z,#/ \\.\\(\\)\\-\\+\\*]*[0-9]){2}([a-zA-Z,#/ \\.\\(\\)\\-\\+\\*]*[2-9])([a-zA-Z,#/ \\.\\(\\)\\-\\+\\*]*[0-9]){6}[0-9a-zA-Z,#/ \\.\\(\\)\\-\\+\\*]*$",
        "title": "Test"
    },
    {
        "description": "The alphanumeric patterns I have seen here are unnecessarily long. This is all you need.",
        "matches": [
            "abcdefghijklmnopqrstuvwxyz1234567890"
        ],
        "nonMatches": [
            "!@#$%^\u0026*()_+=-?\u003E\u003C,./:\u0022;\u0027[]\\{}",
            ""
        ],
        "pattern": "^[\\w ]{0,}$",
        "title": "Test"
    },
    {
        "description": "Valida\u00E7\u00E3o de CEP Brasileiro. Aceita n\u00FAmero com tra\u00E7o ou sem tra\u00E7o.",
        "matches": [
            "12345-678",
            "12345678"
        ],
        "nonMatches": [
            "12345*678",
            "12345-67",
            "1234567"
        ],
        "pattern": "^\\d{5}-\\d{3}$|^\\d{8}$",
        "title": "Test"
    },
    {
        "description": "This Pattern is to Validate Mobile Number with 10 digit Number and Countrycode as Optional.",
        "matches": [
            "+91-9822345654,9822345654"
        ],
        "nonMatches": [
            "+923-9855777897,6463466"
        ],
        "pattern": "^((\\+)?(\\d{2}[-]))?(\\d{10}){1}?$",
        "title": "Test"
    },
    {
        "description": "This is a fairly forgiving phone number match. It\u0027s original purpose was to extract phone numbers from the details field in our database and into their own phone number table. It worked brilliantly. Enjoy!",
        "matches": [
            "14165551212, 4165551212, (416)5551212, 416 555 1212, 416-555-1212, (416)-555-1212, (416) 555 1212, 1-900-888-1212"
        ],
        "nonMatches": [
            "456-444-45464, 416-SEX-POOP, 4!6-777-#232"
        ],
        "pattern": "^(1?)(-| ?)(\\()?([0-9]{3})(\\)|-| |\\)-|\\) )?([0-9]{3})(-| )?([0-9]{4}|[0-9]{4})$",
        "title": "Test"
    },
    {
        "description": "This expression matches all VBScript or VB code. Line comments (with \u0027) and strings are inlcuded in named groups. Strings with double quotes (i.e. \u0022this is my \u0022\u0022string\u0022\u0022.\u0022) is supported. Expression is only tested with RegEx for .net 2.0.",
        "matches": [
            "Response.Write \u0022my \u0022\u0022quoted\u0022\u0022 string\u0022\u0027 some comment"
        ],
        "nonMatches": [
            ".."
        ],
        "pattern": "(?\u003CCode\u003E[\\s\\S]*?)(?\u003CNonCode\u003E\u0027.*?\\r?\\n|(?\u003Cquot\u003E\u0022|\u0027)(?:(?:(?!\\\u003Cquot\u003E).|\\\u003Cquot\u003E{2})*)(?:\\\u003Cquot\u003E))",
        "title": "Test"
    },
    {
        "description": "It will allow for alphanumeric characters only, with the exception of spacing.",
        "matches": [
            "Website Users"
        ],
        "nonMatches": [
            "Website Users!"
        ],
        "pattern": "^[a-zA-Z0-9\\040]+$",
        "title": "Test"
    },
    {
        "description": "An expression for .NET regular expression validation controls intended to facilitate the entry of percentage values both a whole numbers or as their decimal representations. Also compatible with the default US format for string formatting for percentages. Recommend that if you intended accept a value passing this express that you strip the percentage signs and take measures to ensure that any whole values are converted to percentages.",
        "matches": [
            "123",
            "256.89",
            "2%",
            "0.2%",
            "25%",
            "0.1",
            "0",
            "+1.9%",
            "-2"
        ],
        "nonMatches": [
            ".1",
            "%1",
            "1.0",
            "2,345"
        ],
        "pattern": "^[+-]?\\d+(\\.\\d{1,4})? *%?$",
        "title": "Test"
    },
    {
        "description": "This expressions parses one line from a CSV file which has been written with Excel. It does cover all variants: simple value, value masked by double quotes (including semicolons between double quotes which don\u0027t count) and double quotes masked by double quotes (\u0022\u0022). Replace all semicolons within the regex to change the separator character.",
        "matches": [
            "abc;efg;\u0022Column with ;\u0022;\u0022Column with ; and \u0022\u0022double quotes\u0022\u0022\u0022;;ijk;"
        ],
        "nonMatches": [
            "abc,efg,\u0027test\u0027,ijk"
        ],
        "pattern": ";?(?:(?:\u0022((?:[^\u0022]|\u0022\u0022)*)\u0022)|([^;]*))",
        "title": "Test"
    },
    {
        "description": "Matches Brazilian phone numbers, includes DDD (long-distance call) with or without 0. Accepts characters -, . and [space] as separators.",
        "matches": [
            "011 5555-1234",
            "(011) 5555 1234",
            "(11) 5555.1234",
            "1155551234"
        ],
        "nonMatches": [
            "(011 5555-1234",
            "(01) 5555 1234",
            "(11) 0555.1234",
            "(11) 5555 abcd"
        ],
        "pattern": "^((\\(0?[1-9][0-9]\\))|(0?[1-9][0-9]))[ -.]?([1-9][0-9]{3})[ -.]?([0-9]{4})$",
        "title": "Test"
    },
    {
        "description": "This will match an entire HTML tag and will capture the href portion into the named capture \u0022url\u0022. It will match any anchor tag with any number of attributes.",
        "matches": [
            "The entire <a href=\u0022\u0022></a> tag"
        ],
        "nonMatches": [
            "Links that include any html within the tag."
        ],
        "pattern": "\u003Ca\\s+(?:(?:\\w+\\s*=\\s*)(?:\\w+|\u0022[^\u0022]*\u0022|\u0027[^\u0027]*\u0027))*?\\s*href\\s*=\\s*(?\u003Curl\u003E\\w+|\u0022[^\u0022]*\u0022|\u0027[^\u0027]*\u0027)(?:(?:\\s+\\w+\\s*=\\s*)(?:\\w+|\u0022[^\u0022]*\u0022|\u0027[^\u0027]*\u0027))*?\u003E[^\u003C]+\u003C/a\u003E",
        "title": "Test"
    },
    {
        "description": "Mach with constant string in SQL style.",
        "matches": [
            "\u0027\u0027\u0027abc\u0027",
            "\u0027abc\u0027",
            "\u0027a\u0027\u0027bc\u0027",
            "\u0027abc\u0027\u0027\u0027",
            "\u0027\u0027\u0027\u0027"
        ],
        "nonMatches": [
            "abc",
            "\u0027abc",
            "\u0027\u0027\u0027ab"
        ],
        "pattern": "\u0027(\u0027{2})*([^\u0027\\r\\n]*)(\u0027{2})*([^\u0027\\r\\n]*)(\u0027{2})*\u0027",
        "title": "Test"
    },
    {
        "description": "I was inspired by this regexp - Matches a whole number between 1 and 20 inclusively - because it was doing something I could not find elsewhere so this is how I expanded it to validate lat values",
        "matches": [
            "90.0,-90.9,1.0,-23.343342"
        ],
        "nonMatches": [
            "90, 91.0, -945.0,-90.3422309"
        ],
        "pattern": "^-?([1-8]?[1-9]|[1-9]0)\\.{1}\\d{1,6}",
        "title": "Test"
    },
    {
        "description": "Longitude validation (similiar to Latitude Validation) and inspired by the same code",
        "matches": [
            "180.0, -180.0, 98.092391"
        ],
        "nonMatches": [
            "181, 180, -98.0923913"
        ],
        "pattern": "^-?([1]?[1-7][1-9]|[1]?[1-8][0]|[1-9]?[0-9])\\.{1}\\d{1,6}",
        "title": "Test"
    },
    {
        "description": "This will match true if the string contians at least one HTML tag.",
        "matches": [
            "This containt <HTML> tags. <B> Bold! </B>"
        ],
        "nonMatches": [
            "This text does not contain HTML."
        ],
        "pattern": "[\\w*|\\W*]*\u003C[[\\w*|\\W*]*|/[\\w*|\\W*]]\u003E[\\w*|\\W*]*",
        "title": "Test"
    },
    {
        "description": "Matches whole numbers only, including comma separated. Does not allow leading zeros. To match comma separated numbers only, change \u0022\\d{0,}\u0022 to \u0022\\d{0,2}\u0022. To match 0, add \u0022|([0])\u0022 before \u0022)$\u0022. If you want to use it with Java\u0027s regexp match(), remove \u0022^(\u0022 and \u0022)$\u0022 since they are not needed.",
        "matches": [
            "10",
            "1000",
            "1,000",
            "10,000,000"
        ],
        "nonMatches": [
            "01",
            "001,000",
            "1000,000"
        ],
        "pattern": "^(([1-9]{1}\\d{0,2},(\\d{3},)*\\d{3})|([1-9]{1}\\d{0,}))$",
        "title": "Test"
    },
    {
        "description": "This matches the modifiers section of a properly formed PCRE RegEx (at least in PHP). This of course assumes that the delimiters are not any of the modifiers letters, if that\u0027s even possible.",
        "matches": [
            "/asher/is",
            "/(a",
            "the)\\spattern/imxe"
        ],
        "nonMatches": [
            "/pattern/mjhlk"
        ],
        "pattern": "/[^imsxeADSUXu]([imsxeADSUXu]*)$/",
        "title": "Test"
    },
    {
        "description": "Express\u00E3o para datas no formato ddMMM obrigando dois d\u00EDgitos para o dia e tr\u00EAs letras para o m\u00EAs (em ingl\u00EAs). Regex for dates at ddMMM format mandatory two digits for days and three letters for the months.",
        "matches": [
            "12jan",
            "23dec"
        ],
        "nonMatches": [
            "4jul",
            "40sep"
        ],
        "pattern": "[0-3]{1}[0-9]{1}(jan|JAN|feb|FEB|mar|MAR|apr|APR|may|MAY|jun|JUN|jul|JUL|aug|AUG|sep|SEP|oct|OCT|nov|NOV|dec|DEC){1}",
        "title": "Test"
    },
    {
        "description": "any north american us phone number",
        "matches": [
            "+1-(718)-699-0005"
        ],
        "nonMatches": [
            "+1-(123)-768-678"
        ],
        "pattern": "(?:(?:(?:\\+)?1[\\-\\s\\.])?(?:\\s?\\()?(?:[2-9][0-8][0-9])(?:\\))?(?:[\\s|\\-|\\.])?)(?:(?:(?:[2-9][0-9|A-Z][0-9|A-Z])(?:[\\s|\\-|\\.])?)(?:[0-9|A-Z][0-9|A-Z][0-9|A-Z][0-9|A-Z]))",
        "title": "Test"
    },
    {
        "description": "In java using this.getClass().getResource(\u0022\u0022); will result in a jar:file:/ etc url ending with yourjarfile.jar!/internal/package/path/ this regular expression matches the directory before the internal jar path declaration returning the physical directory the file resides in. should work in both posix and windows machines (untested for posix*)",
        "matches": [
            "jar:file:/C:/installation/path/jarfile.jar!/com/regexlib/example"
        ],
        "nonMatches": [
            "Any text not using internal jar file url"
        ],
        "pattern": "jar:file:/(([A-Z]:)?/([A-Z 0-9 * ( ) + \\- \u0026 $ # @ _ . ! ~ /])+)(/[A-Z 0-9 _ ( ) \\[ \\] - = + _ ~]+\\.jar!)",
        "title": "Test"
    },
    {
        "description": "More advanced regular expression to get the full path to the directory from which your program is running. You may use this to detect the program installation dir whether you are just debugging or having a deployed program. Using the second group combined with the 7th group you\u0027ll have a full path to your program. Very useful if you use resources outside of the java package.",
        "matches": [
            "jar:file:/C:/installation/dir/program.jar!/com/regexlib/example/",
            "file:/install/dir/development/workspace/com/regexlib/example/"
        ],
        "nonMatches": [
            "Does not match non-java url",
            "http:/www.regexlib.com/applet.jar!/com/regexlib/example/"
        ],
        "pattern": "(jar:)?file:/(([A-Z]:)?/([A-Z0-9\\*\\()\\+\\-\\\u0026$#@_.!~\\[\\]/])+)((/[A-Z0-9_()\\[\\]\\-=\\+_~]+\\.jar!)|([^!])(/com/regexlib/example/))",
        "title": "Test"
    },
    {
        "description": "Matches a string if it is a valid time in the format of \u0022HH:MM AM\u0022 or \u0022HH:MM A\u0022.",
        "matches": [
            "1:30 AM",
            "01:20 AM",
            "10:00A",
            "11:50P"
        ],
        "nonMatches": [
            "13:00 A",
            "01:5 AM"
        ],
        "pattern": "^(([0][0-9]|[1][0-2])|[0-9]):([0-5][0-9])( *)((AM|PM)|(A|P))$",
        "title": "Test"
    },
    {
        "description": "Currency expression, accepts 4 commas and 4 groups of 3 numbers and 1 number before the first comma, this first number will have to be different from zero. It accepts a number of, two or three decimal. It accepts zero numbers after the point. You can change the number of groups and numbers accespts before and after the point.",
        "matches": [
            "1234.23",
            "1,234.245",
            "1."
        ],
        "nonMatches": [
            "12,12,0.00",
            "0,123.99"
        ],
        "pattern": "^\\$?(([1-9],)?([0-9]{3},){0,3}[0-9]{3}|[0-9]{0,16})(\\.[0-9]{0,3})?$",
        "title": "Test"
    },
    {
        "description": "This pattern is a extension of Jeremy Samuel\u0027s password pattens, I included a validation for the string not end with number",
        "matches": [
            "arielMM{3s",
            "Arielmm\u00262s"
        ],
        "nonMatches": [
            "1arielMM{3s",
            "Arielmm\u00262"
        ],
        "pattern": "^((?=[^\\d])(?=^*[^0-9]$)(?!.*\u0027)(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?!.*\\s))?(?=.*[^\\d]$).{8,15}$",
        "title": "Test"
    },
    {
        "description": "only allows valid cell phones from south african service providers. to date i havent seen a cell phone number starting 079 or 089 but i think the networks might support it...",
        "matches": [
            "0848298477",
            "084 829 8477",
            "084-829 8477"
        ],
        "nonMatches": [
            "084829 8477"
        ],
        "pattern": "(^0[87][23467]((\\d{7})|( |-)((\\d{3}))( |-)(\\d{4})|( |-)(\\d{7})))",
        "title": "Test"
    },
    {
        "description": "validates south african phone numbers",
        "matches": [
            "0333872119",
            "033 386162",
            "074 101 2850"
        ],
        "nonMatches": [
            "033386 2612"
        ],
        "pattern": "[0](\\d{9})|([0](\\d{2})( |-)((\\d{3}))( |-)(\\d{4}))|[0](\\d{2})( |-)(\\d{7})",
        "title": "Test"
    },
    {
        "description": "Validates South African ID Numbers",
        "matches": [
            "771125 5047 081",
            "771231-5046-081",
            "7712315046081"
        ],
        "nonMatches": [
            "non valid id numbers"
        ],
        "pattern": "(((\\d{2}((0[13578]|1[02])(0[1-9]|[12]\\d|3[01])|(0[13456789]|1[012])(0[1-9]|[12]\\d|30)|02(0[1-9]|1\\d|2[0-8])))|([02468][048]|[13579][26])0229))(( |-)(\\d{4})( |-)(\\d{3})|(\\d{7}))",
        "title": "Test"
    },
    {
        "description": "Just a simple US State regex. Requires valid 2 letter abbreviations.",
        "matches": [
            "CO",
            "GA",
            "TX"
        ],
        "nonMatches": [
            "A",
            "ZZ",
            "Florida"
        ],
        "pattern": "^(?:(A[KLRZ]|C[AOT]|D[CE]|FL|GA|HI|I[ADLN]|K[SY]|LA|M[ADEINOST]|N[CDEHJMVY]|O[HKR]|P[AR]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY]))$",
        "title": "Test"
    },
    {
        "description": "This regex matches fully qualified external urls (http, https, or ftp). It uses the ms specific group-naming structure to present friendly named groups back to the user.",
        "matches": [
            "http://www.myserver.mydomain.com/myfolder/mypage.aspx"
        ],
        "nonMatches": [
            "www.myserver.mydomain.com/myfolder/mypage.aspx"
        ],
        "pattern": "(?\u003Cprotocol\u003Ehttp(s)?|ftp)://(?\u003Cserver\u003E([A-Za-z0-9-]+\\.)*(?\u003Cbasedomain\u003E[A-Za-z0-9-]+\\.[A-Za-z0-9]+))+((/?)(?\u003Cpath\u003E(?\u003Cdir\u003E[A-Za-z0-9\\._\\-]+)(/){0,1}[A-Za-z0-9.-/]*)){0,1}",
        "title": "Test"
    },
    {
        "description": "use this to produce search strings in your programs that run more efficiently. use the replace of the regex class to remove the characters from the user input then use the resulting string to query the database...",
        "matches": [
            "matched words listed between the whitespace character class"
        ],
        "nonMatches": [
            "the words not included in the white space character class"
        ],
        "pattern": "[\\s]a[\\s]|[\\s]about[\\s]|[\\s]an[\\s]|[\\s]are[\\s]|[\\s]as[\\s]|[\\s]at[\\s]|[\\s]be[\\s]|[\\s]by[\\s]|[\\s]for[\\s]|[\\s]from[\\s]|[\\s]how[\\s]|[\\s]in[\\s]|[\\s]is[\\s]|[\\s]it[\\s]|[\\s]of[\\s]|[\\s]on[\\s]|[\\s]or[\\s]|[\\s]that[\\s]|[\\s]the[\\s]|[\\s]this[\\s]|[\\s]to[\\s]|[\\s]was[\\s]|[\\s]what[\\s]|[\\s]when[\\s]|[\\s]where[\\s]|[\\s]who[\\s]|[\\s]will[\\s]|[\\s]with[\\s]|[\\s]the[\\s]|[\\s]www[\\s]",
        "title": "Test"
    },
    {
        "description": "Danish social security. [ddMMyy-0000]. Validates a correct date, but does not enforce the modulus 11 check (see www.cpr.dk for more information).",
        "matches": [
            "241283-1234",
            "290204-1234"
        ],
        "nonMatches": [
            "290206-1234"
        ],
        "pattern": "^((((0[1-9]|[12][0-9]|3[01])(0[13578]|10|12)(\\d{2}))|(([0][1-9]|[12][0-9]|30)(0[469]|11)(\\d{2}))|((0[1-9]|1[0-9]|2[0-8])(02)(\\d{2}))|((29)(02)(00))|((29)(02)([2468][048]))|((29)(02)([13579][26])))[-]\\d{4})$",
        "title": "Test"
    },
    {
        "description": "This will pull the HREF values out of any HTML tag in a query and present only the HREF values. It\u0027s very versatile, it can accept a number of nonstandard formats.",
        "matches": [
            "HTML HREF values -- <a href=dir/file.php\u003E\u0026<a href=\u0022http://www.google.com\u0022 target=\u0022_blank\u0022\u003E\u0026<a target=\u0022_blank\u0022 href=\u0022otherfile.php\u0022\u003E"
        ],
        "nonMatches": [
            "Plaintext or non HREF VALUES"
        ],
        "pattern": "(?\u003C=\u003C(\\S|\\s)*)((?\u003C=(href=(\u0027|\u0022)+))|(?\u003C=(href=))[^(\u0027|\u0022)])([^\u0027\u003E\u0022\\s)]*)(?=(\u0027|\u0022|[\\S])?)",
        "title": "Test"
    },
    {
        "description": "find the body-tag of a html page",
        "matches": [
            "\u003Cbody\u003E\u003CBODY bgcolor=\u0022#ffffff\u0022 text=\u0022#000000\u0022 marginwidth=\u00220\u0022 marginheight=\u00220\u0022\u003E"
        ],
        "nonMatches": [
            "all non body tags"
        ],
        "pattern": "((\u003Cbody)|(\u003CBODY))([^\u003E]*)\u003E",
        "title": "Test"
    },
    {
        "description": "Matches U.S. military time with option leading zero and required seconds.",
        "matches": [
            "1:01:01",
            "",
            "01:01:01",
            "",
            "12:23:33:",
            "",
            "22:09:59"
        ],
        "nonMatches": [
            "1:23",
            "",
            "24:00:00"
        ],
        "pattern": "^([0]?\\d|1\\d|2[0-3]):([0-5]\\d):([0-5]\\d)$",
        "title": "Test"
    },
    {
        "description": "This pattern matches link tags in html and returns the contents of the href attribute and the text of the link.",
        "matches": [
            "\u003Ca href=\u0022http://www.google.com\u0022\u003EGoogle\u003C/a\u003E"
        ],
        "nonMatches": [
            "\u003Ca name=\u0022bookmark\u0022\u003Esomething\u003C/a\u003E"
        ],
        "pattern": "^\u003Ca[^\u003E]*(http://[^\u0022]*)[^\u003E]*\u003E([ 0-9a-zA-Z]+)\u003C/a\u003E$",
        "title": "Test"
    },
    {
        "description": "Verifica que un RUT tenga el formato 00.000.000-X, despues de comprobar el formato ser\u00E1 necesario validar su d\u00EDgito verificador.",
        "matches": [
            "12.025.365-6",
            "5.698.124-k",
            "7.999.647-K"
        ],
        "nonMatches": [
            "125.326.452-1",
            "15.336.054-H",
            "15254587k"
        ],
        "pattern": "^\\d{1,2}\\.\\d{3}\\.\\d{3}[-][0-9kK]{1}$",
        "title": "Test"
    },
    {
        "description": "This Regular Expression searches for a valid eMail address. It uses a list of all the known top-level-domains to verify that the domain is correct. Also Possible to find the IP Address",
        "matches": [
            "john.doe@texas.comjohn_doe@texas.comjohn.doe@192.168.0.1john_doe@192.168.0.1"
        ],
        "nonMatches": [
            "john.doe@123.123.123john.does@256.123.256.123"
        ],
        "pattern": "^([_a-zA-Z0-9-]+\\.[_a-zA-Z0-9-]*)\\@((([a-zA-Z0-9-]{2,255})\\.(ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cx|cy|cz|de|di|dk|dm|do|dz|ec|ee|eg|eh|er|es|et|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|in|io|iq|ir|is|it|jo|jm|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|an|nc|ne|nf|ng|ni|nl|no|np|nr|nt|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|pt|pw|py|qa|re|ro|ru|rw|sa|sb|sc|sd|se|sq|sh|si|sj|sk|sl|sm|sn|so|sr|st|su|sv|sy|sz|tc|td|tf|tg|th|tj|tk|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|um|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|yu|za|zm|zr|zw|arpa|arts|biz|com|edu|firm|gov|info|int|mil|nato|net|nom|org|rec|store|web))|((25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[0-9])))$",
        "title": "Test"
    },
    {
        "description": "used to validate form fields values for positive integer values greater than 0 without explicitly checking if the input form value is greater than 0",
        "matches": [
            "122, 9992, 000022"
        ],
        "nonMatches": [
            "0, 00000, 1.2, -3.22"
        ],
        "pattern": "^(0+[1-9]|[1-9])[0-9]*$",
        "title": "Test"
    },
    {
        "description": "This is built on an Address expression by Ross Hammer (who in turn built on an expression from Michael Ash)... and the zipcode expression from Matthew Aznoe. This one adds validation for Canadian provinces and postal codes (so it does both US and Canada)",
        "matches": [
            "any us/canadian address"
        ],
        "nonMatches": [
            "non us/candian address"
        ],
        "pattern": "^\\s*((?:(?:\\d+(?:\\x20+\\w+\\.?)+(?:(?:\\x20+STREET|ST|DRIVE|DR|AVENUE|AVE|ROAD|RD|LOOP|COURT|CT|CIRCLE|LANE|LN|BOULEVARD|BLVD)\\.?)?)|(?:(?:P\\.\\x20?O\\.|P\\x20?O)\\x20*Box\\x20+\\d+)|(?:General\\x20+Delivery)|(?:C[\\\\\\/]O\\x20+(?:\\w+\\x20*)+))\\,?\\x20*(?:(?:(?:APT|BLDG|DEPT|FL|HNGR|LOT|PIER|RM|S(?:LIP|PC|T(?:E|OP))|TRLR|UNIT|\\x23)\\.?\\x20*(?:[a-zA-Z0-9\\-]+))|(?:BSMT|FRNT|LBBY|LOWR|OFC|PH|REAR|SIDE|UPPR))?)\\,?\\s+((?:(?:\\d+(?:\\x20+\\w+\\.?)+(?:(?:\\x20+STREET|ST|DRIVE|DR|AVENUE|AVE|ROAD|RD|LOOP|COURT|CT|CIRCLE|LANE|LN|BOULEVARD|BLVD)\\.?)?)|(?:(?:P\\.\\x20?O\\.|P\\x20?O)\\x20*Box\\x20+\\d+)|(?:General\\x20+Delivery)|(?:C[\\\\\\/]O\\x20+(?:\\w+\\x20*)+))\\,?\\x20*(?:(?:(?:APT|BLDG|DEPT|FL|HNGR|LOT|PIER|RM|S(?:LIP|PC|T(?:E|OP))|TRLR|UNIT|\\x23)\\.?\\x20*(?:[a-zA-Z0-9\\-]+))|(?:BSMT|FRNT|LBBY|LOWR|OFC|PH|REAR|SIDE|UPPR))?)?\\,?\\s+((?:[A-Za-z]+\\x20*)+)\\,\\s+(A[BLKSZRAP]|BC|C[AOT]|D[EC]|F[LM]|G[AU]|HI|I[ADLN]|K[SY]|LA|M[ABDEHINOPST]|N[BCDEHJLMSTUVY]|O[HKRN]|P[AERW]|QC|RI|S[CDK]|T[NX]|UT|V[AIT]|W[AIVY]|YT)\\s+((\\d{5}-\\d{4})|(\\d{5})|([AaBbCcEeGgHhJjKkLlMmNnPpRrSsTtVvXxYy]\\d[A-Za-z]\\s?\\d[A-Za-z]\\d))\\s*$",
        "title": "Test"
    },
    {
        "description": "This expression matches all following Telephone number patterns [US Telephone, Indian Telephone, Canadian Telephone \u0026 Fax Numbers]. I tested it and its working fine. and hope this will be helpful to u people. suggestion are welcome ! +91-80-1234567 | +91 80 1234567 | +91 80-1234567 | +91-80 1234567 | +91.80.1234567 | +91.80-1234567 | +91-80.1234567 | (91)80-1234567 | (91)80 1234567 | (91)80.1234567 | +91-80-12345678 | +91 80 12345678 | +91 80-12345678 | +91-80 12345678 | +91.80.12345678 | +91.80-12345678 | +91-80.12345678 | (91)80-12345678 | (91)80 12345678 | (91)80.12345678 | +91-484-1234567 | +91 484 1234567 | +91 484-1234567 | +91-484 1234567 | +91.484.1234567 | +91.484-1234567 | +91-484.1234567 | (91)484-1234567 | (91)484 1234567 | (91)484.1234567 | +91-484-12345678 | +91 484 12345678 | +91 484-12345678 | +91-484 12345678 | +91.484.12345678 | +91.484-12345678 | +91-484.12345678 | (91)484-12345678 | (91)484 12345678 | (91)484.12345678 | +123-123-1234 | +123 123 1234 | +123 123-1234 | +123-123 1234 | +123.123.1234 | +123.123-1234 | +123-123.1234 | (123)123-1234 | (123)123 1234 | (123)123.1234 | +123-123-1234 | +123 123 1234 | +123 123-1234 | +123-123 1234 | +123.123.1234 | +123.123-1234 | +123-123.1234 | (123)123-1234 | (123)123 1234 | (123)123.1234 | 123-123-1234 | 123 123 1234 | 123 123-1234 | 123-123 1234 | 123.123.1234 | 123.123-1234 | 123-123.1234 | 123-123-1234 | (001)456-789-1234 | 001-456-789-1234 | 4841801234 | +91.1234567890 | +91-1234567890 | +91 1234567890 | 1-561-555-1212 | 1234567890 | 1234-1234567 | 123-12345678 (05)12341234 | 09886657989 - Phone , Telephone \u0022+91 80 2559 4800\u0022 and \u002291 (80) 234 65453\u0022",
        "matches": [
            "all phone numbers"
        ],
        "nonMatches": [
            "i couldnt find any"
        ],
        "pattern": "preg_match_all(\u0022/([\\(\\+])?([0-9]{1,3}([\\s])?)?([\\+|\\(|\\-|\\)|\\s])?([0-9]{2,4})([\\-|\\)|\\.|\\s]([\\s])?)?([0-9]{2,4})?([\\.|\\-|\\s])?([0-9]{4,8})/\u0022,$string, $phones);",
        "title": "Test"
    },
    {
        "description": "This simple pattern is useful for removing all HTML tags with or without atributes. It has no removing white spaces",
        "matches": [
            "\u003C html \u003E",
            "\u003C div style=\u0022title_1\u0022 class=\u0027number\u0027\u003E",
            "\u003C div style=\u0022title_1\u0022 class=\u0027number\u0027\u003E",
            "\u003C img src=\u0022img.gif\u0022 / \u003E"
        ],
        "nonMatches": [
            "Plain text"
        ],
        "pattern": "\u003C\\s*?[^\u003E]+\\s*?\u003E",
        "title": "Test"
    },
    {
        "description": "A range of numbers 0-35 optionally including a percent sign and 2 position decimal.",
        "matches": [
            "32.34%, 32.34, 32, 32%"
        ],
        "nonMatches": [
            "32.345%, 36, .34"
        ],
        "pattern": "^[0-9]%?$|^1[0-9]%?$|^2[0-9]%?$|^3[0-5]%?$|^[0-9]\\.\\d{1,2}%?$|^1[0-9]\\.\\d{1,2}%?$|^2[0-9]\\.\\d{1,2}%?$|^3[0-4]\\.\\d{1,2}%?$|^35%?$",
        "title": "Test"
    },
    {
        "description": "This pattern requires at least two lowercase letters, two uppercase letters, two digits, and two special characters. There must be a minimum of 9 characters total, and no white space characters are allowed.",
        "matches": [
            "A1!B2@cde"
        ],
        "nonMatches": [
            "ABC!@#123"
        ],
        "pattern": "^(?=.*[a-z].*[a-z])(?=.*[A-Z].*[A-Z])(?=.*\\d.*\\d)(?=.*\\W.*\\W)[a-zA-Z0-9\\S]{9,}$",
        "title": "Test"
    },
    {
        "description": "I think this is one of the website url we can validate",
        "matches": [
            "http://www.proarchitsoulutions.com"
        ],
        "nonMatches": [
            "ww.proarchitsolutions.com",
            "ftp://ftp.omega.com"
        ],
        "pattern": "(http://|)(www\\.)?([^\\.]+)\\.(\\w{2}|(com|net|org|edu|int|mil|gov|arpa|biz|aero|name|coop|info|pro|museum))$",
        "title": "Test"
    },
    {
        "description": "Useful for verifying VAT Registration Numbers",
        "matches": [
            "2001/067995/23",
            "1989/064445/73"
        ],
        "nonMatches": [
            "non-valid South African VAT Registration Numbers"
        ],
        "pattern": "((19|20)[\\d]{2}/[\\d]{6}/[\\d]{2})",
        "title": "Test"
    },
    {
        "description": "This pattern match the Italian Istat Ateco Code (Codice Istat) updated to Istat Declaration Ateco 2004",
        "matches": [
            "22.12.0",
            "18.24.C"
        ],
        "nonMatches": [
            "22.12_D",
            "12.56",
            "1A.56.1"
        ],
        "pattern": "\\d{2}[.]{1}\\d{2}[.]{1}[0-9A-Za-z]{1}",
        "title": "Test"
    },
    {
        "description": "get all css links, tags ect without http, i needed this to my web crawler, maybe somebody need this to ;)_",
        "matches": [
            "import url(\u0022some.css\u0022), import(\u0022some.css\u0022), \u003Clink rel=\u0022STYLESHEET\u0022 type=\u0022text/css\u0022 href=\u0022some.css\u0022\u003E"
        ],
        "nonMatches": [
            "import url(\u0022http://domain.com/some.css\u0022), import(\u0022http://domain.com/some.css\u0022), \u003Clink rel=\u0022STYLESHEET\u0022 type=\u0022text/css\u0022 href=\u0022http://domain.com/some.css\u0022\u003E"
        ],
        "pattern": "(href=|url|import).*[\\\u0027\u0022]([^(http:)].*css)[\\\u0027\u0022]",
        "title": "Test"
    },
    {
        "description": "Validates both ISBN 10 and ISBN 13 numbers, and confirms ISBN 13 numbers start with only 978 or 979.",
        "matches": [
            "0672317249",
            "9780672317248"
        ],
        "nonMatches": [
            "0-672-31724-9",
            "5555555555555"
        ],
        "pattern": "^(97(8|9))?\\d{9}(\\d|X)$",
        "title": "Test"
    },
    {
        "description": "This time is for C-Style Quoted String matching. So to use \u0022 in the quoted string you need to use \\\u0022 and if you wanted to use \\ in your string, use \\\\.",
        "matches": [
            "\u0022\u0022\u0022!\u0022\u0022Hello\u0022\u0022Es\\\u0022Cape\u0022\u0022Backslash \\\\\u0022"
        ],
        "nonMatches": [
            "\u0022Backslash\\\u0022, \u0022Unclosed"
        ],
        "pattern": "\u0022(\\\\.|[^\u0022])*\u0022",
        "title": "Test"
    },
    {
        "description": "Validates entry for a valid Windows folder name. Excludes all forbidden characters.",
        "matches": [
            "New Folder"
        ],
        "nonMatches": [
            "New \u0027 Folder"
        ],
        "pattern": "^[^\\\\\\/\\?\\*\\\u0022\\\u003E\\\u003C\\:\\|]*$",
        "title": "Test"
    },
    {
        "description": "This Regular Expression is used to match the Companies House 503 Reference number that is given when a customer places an online order.www.companieshouse.gov.uk",
        "matches": [
            "503-123456-123456"
        ],
        "nonMatches": [
            "abc-abcdef-abcdef"
        ],
        "pattern": "^[0-9]{3}[-|/]{1}[0-9]{6}[-|/]{1}[0-9]{6}$",
        "title": "Test"
    },
    {
        "description": "This expression can be used to check against the format of a United Kingdom Vehicle Registration plate in the new style.",
        "matches": [
            "AB06CDE or AB 06 CDE or AB06 CDE or AB 06CDE"
        ],
        "nonMatches": [
            "Anything that\u0027s not in the above format"
        ],
        "pattern": "^[A-Za-z]{2}[ ]{0,1}[0-9]{2}[ ]{0,1}[a-zA-Z]{3}$",
        "title": "Test"
    },
    {
        "description": "Dutch zipcode. The non-matching code does not match because lettercombinations SS, SA and SD are not allowed. (historic reasons ?).",
        "matches": [
            "3545CA"
        ],
        "nonMatches": [
            "3534 SS"
        ],
        "pattern": "^[1-9][0-9]{3}[ ]?(([a-rt-zA-RT-Z]{2})|([sS][^dasDAS]))$",
        "title": "Test"
    },
    {
        "description": "It validates the leap year also",
        "matches": [
            "29 Feb 2000"
        ],
        "nonMatches": [
            "29/02/2000"
        ],
        "pattern": "Date Format in dd MMM yyyy ----\u003E (^(3[01]|[12][0-9]|0?[1-9])\\s{1}(Jan|Mar|May|Jul|Aug|Oct|Dec)\\s{1}((1[8-9]\\d{2})|([2-9]\\d{3}))$)|(^(30|[12][0-9]|0?[1-9])\\s{1}(Apr|Jun|Sep|Nov)\\s{1}((1[8-9]\\d{2})|([2-9]\\d{3}))$)|(^(2[0-8]|1[0-9]|0?[1-9])\\s{1}(Feb)\\s{1}((1[8-9]\\d{2})|([2-9]\\d{3}))$)|(^(29)\\s{1}(Feb)\\s{1}([2468][048]00)$)|(^(29)\\s{1}(Feb)\\s{1}([3579][26]00)$)|(^(29)\\s{1}(Feb)\\s{1}([1][89][0][48])$)|(^(29)\\s{1}(Feb)\\s{1}([2-9][0-9][0][48])$)|(^(29)\\s{1}(Feb)\\s{1}([1][89][2468][048])$)|(^(29)\\s{1}(Feb)\\s{1}([2-9][0-9][2468][048])$)|(^(29)\\s{1}(Feb)\\s{1}([1][89][13579][26])$)|(^(29)\\s{1}(Feb)\\s{1}([/])([2-9][0-9][13579][26])$)",
        "title": "Test"
    },
    {
        "description": "I\u0027m using this to match Slovenian phone numbers. It\u0027s a bit rusty... If you have better version or updated please send it to me.",
        "matches": [
            "031 123 456",
            "031-123-456",
            "031/123/456",
            "031123456",
            "+386 31 123 456",
            "+38631 123 456",
            "+386-41-041-041",
            "+386/41/041/041",
            "386 41 041 041",
            "38641041041"
        ],
        "nonMatches": [
            "0038631123456"
        ],
        "pattern": "^(([0-9]{3})[ \\-\\/]?([0-9]{3})[ \\-\\/]?([0-9]{3}))|([0-9]{9})|([\\+]?([0-9]{3})[ \\-\\/]?([0-9]{2})[ \\-\\/]?([0-9]{3})[ \\-\\/]?([0-9]{3}))$",
        "title": "Test"
    },
    {
        "description": "Tries to find the proper nouns in a text",
        "matches": [
            "George W. Bush, al-Qaeda, VIII. Henry, United States of America, U.S. Department of Justice"
        ],
        "nonMatches": [
            "other non-proper nouns"
        ],
        "pattern": "((?!(This|It|He|She|[MTWFS][a-z]+day|[JF][a-z]+ary|March|April|May|June|July|August|[SOND][a-z]+ber))(?:[A-Z]+\\.\\s?)*(?:(?:[a-zA-Z]+-?)?[A-Z][a-zA-Z]+)(?:(\\b\\s?((?:[a-zA-Z]+-?)?[A-Z][a-zA-Z]+|[A-Z]+\\.|on|of|the|von|der|van|de|bin|and))*(?:\\s*(?:[a-zA-Z]+-?)?[A-Z][a-zA-Z]+))?)",
        "title": "Test"
    },
    {
        "description": "The date field takes all values with slashes. Leap year is taken care of Year has to be specified in 4digit. Time is a 12hrclock taking am n pm(case insensitive). AM or Pm has to be specified. Not suited for 24hr clock. In the format of SQL Server datetime field",
        "matches": [
            "09/10/2004 10:30am, 1/1/1999 1:32pm"
        ],
        "nonMatches": [
            "09/02/07,02/29/2001,23:00"
        ],
        "pattern": "^((((0?[1-9]|1[012])/(0?[1-9]|1\\d|2[0-8])|(0?[13456789]|1[012])/(29|30)|(0?[13578]|1[02])/31)/(19|[2-9]\\d)\\d{2}|0?2/29/((19|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|(([2468][048]|[3579][26])00))))[\\s]((([0]?[1-9]|1[0-2])(:|\\.)[0-5][0-9]((:|\\.)[0-5][0-9])?( )?(AM|am|aM|Am|PM|pm|pM|Pm))|(([0]?[0-9]|1[0-9]|2[0-3])(:|\\.)[0-5][0-9]((:|\\.)[0-5][0-9])?))$",
        "title": "Test"
    },
    {
        "description": "Checks time in 24 hours notation, however this one is shorter than the ones I found on regexplib",
        "matches": [
            "23:00",
            "12:21",
            "0:00"
        ],
        "nonMatches": [
            "24:00",
            "23:60",
            "0:60"
        ],
        "pattern": "^([0-1]?[0-9]|[2][0-3]):([0-5][0-9])$",
        "title": "Test"
    },
    {
        "description": "match web pictrue\u0027s address,must be full path,include http head.",
        "matches": [
            "http://image2.sina.com.cn/home/07index/sinahome_ws_035.gif"
        ],
        "nonMatches": [
            "img src=\u0022images/1.jpg\u0022"
        ],
        "pattern": "https?://[\\w./]+\\/[\\w./]+\\.(bmp|png|jpg|gif)",
        "title": "Test"
    },
    {
        "description": "This is very similar to my other expression, except it only matches tags that a browser would read, so if you have an extra \u0022 in the tag, it will not count it, and move onto the next possibility.",
        "matches": [
            "\u003C/a\u003E\u003Ch2 \u003E\u003C/a asdfs\u003E\u003C/h2 asfsdf\u003E\u003Ca href=\u0022abc\u003E\u003E123\u0022\u003E"
        ],
        "nonMatches": [
            "\u003C /a\u003E\u003C/h 2 asfsdf\u003E\u003Cahref=\u0022abc\u0022123\u0022\u003E"
        ],
        "pattern": "\u003C/?(a|abbr|acronym|address|applet|area|b|base|basefont|bdo|big|blockquote|body|br|button|caption|center|cite|code|col|colgroup|dd|del|dir|div|dfn|dl|dt|em|fieldset|font|form|frame|frameset|h[1-6]|head|hr|html|i|iframe|img|input|ins|isindex|kbd|label|legend|li|link|map|menu|meta|noframes|noscript|object|ol|optgroup|option|p|param|pre|q|s|samp|script|select|small|span|strike|strong|style|sub|sup|table|tbody|td|textarea|tfoot|th|thead|title|tr|tt|u|ul|var|xmp)\\b((\\\u0022[^\\\u0022]*\\\u0022|\\\u0027[^\\\u0027]*\\\u0027)*|[^\\\u0022\\\u0027\u003E])*\u003E",
        "title": "Test"
    },
    {
        "description": "This regular expression will validate most (current \u0026 future) date options. The weaknesses with this one is that it will allow the days to go up to 39 and does not account for leap year. Also, the months can go up to 19, instead of our commonly accepted 12 month year. :) I designed this expression to validate dates from the year 2000 to 2099. I do not plan on this same code being in place in 2099, so I hope this is sufficient enough...",
        "matches": [
            "2/14/2001",
            "12/29/2099",
            "19/39/2000"
        ],
        "nonMatches": [
            "12/29/1999",
            "20/40/2100"
        ],
        "pattern": "^([0-1]?[0-9]{1}/[0-3]?[0-9]{1}/20[0-9]{2})$",
        "title": "Test"
    },
    {
        "description": "Matches percentages from 0-100 inclusive with two decimal places.",
        "matches": [
            "0",
            "100",
            "100.00",
            "45.45"
        ],
        "nonMatches": [
            "101",
            "-5",
            "45.456"
        ],
        "pattern": "^100(\\.0{0,2}?)?$|^\\d{0,2}(\\.\\d{0,2})?$",
        "title": "Test"
    },
    {
        "description": "Validates MS FQDNs. 1) Entire fqdn less than 255 chars. 2) Host and domain names may contain an underscore. 3) 1st char can be a number. 4) No part can be all numbers. 5) Allows any TLD Works in C#. Based on Remi Sabourin\u0027s regex. Based on anonymous feedback I\u0027ve corrected it to no longer match domains that start or end with a hyphen.",
        "matches": [
            "host.domain.com",
            "_host.domain.com",
            "1host-2._ldap.domain.com"
        ],
        "nonMatches": [
            "33.domain.com",
            "host..com",
            "a-.com"
        ],
        "pattern": "(?=^.{1,254}$)(^(?:(?!\\d+\\.|-)[a-zA-Z0-9_\\-]{1,63}(?\u003C!-)\\.?)+(?:[a-zA-Z]{2,})$)",
        "title": "Test"
    },
    {
        "description": "This regular expressions matches dates in the format MM/DD/YYYY where MM can be 01 to 12, DD can be 01 to 31 and YYYY is always 4 digits long.",
        "matches": [
            "12/25/2007",
            "11/07/1517",
            "02/25/2727"
        ],
        "nonMatches": [
            "1/27/1977",
            "00/01/000",
            "15/07/2002"
        ],
        "pattern": "^((0[1-9])|(1[0-2]))\\/((0[1-9])|(1[0-9])|(2[0-9])|(3[0-1]))\\/(\\d{4})$",
        "title": "Test"
    },
    {
        "description": "DESCRIPTION Parses a complex number of kind \u0027a+bi\u0027 from an input string. Please remove all spaces from the input string before using this regex pattern. MATCHING EXAMPLES \u0027[]\u0027 means is an optional parameter; \u0027|\u0027 means OR; \u0027+\u0027 is the positive sign; \u0027-\u0027 is the negative sign; \u0027#\u0027 is one ore more decimal digits; \u0027E|e\u0027 are the valid exponent symbols; \u0027...\u0027 is the range for the exponent; \u0027r\u0027 means the real part of complex number; \u0027i\u0027 means the imaginary part of complex number. NOTE Has the imaginary part of the input string not a numeric value (e.g. \u00275-i\u0027 is a valid format) it should be interpreted as \u00275-1i\u0027!",
        "matches": [
            "[+",
            "-]#[.[#]]",
            "[#].#[E",
            "e[+",
            "-]0...299][r] -OR- [+",
            "-][#[.[#]]",
            "[#].#[E",
            "e[+",
            "-]0...299]]i -OR- [+",
            "-]#[.[#]]",
            "[#].#[E",
            "e[+",
            "-]0...299][r]+",
            "-[#[.[#]]",
            "[#].#[E",
            "e[+",
            "-]0...299]]i"
        ],
        "nonMatches": [
            "[+",
            "-][.][E",
            "e[+",
            "-][0...299]][r] -OR- [+",
            "-].[E",
            "e[+",
            "-][0...299]]i -OR- [+",
            "-][.][E",
            "e[+",
            "-][0...299]][r]+",
            "-[#[.[#]]",
            "[#].#[E",
            "e[+",
            "-][0...299]]]i -OR- any number with more than one sign or decimal seperator -OR- any string with non-leading signs on mantissa and on exponent"
        ],
        "pattern": "^([-+]?(\\d+\\.?\\d*|\\d*\\.?\\d+)([Ee][-+]?[0-2]?\\d{1,2})?[r]?|[-+]?((\\d+\\.?\\d*|\\d*\\.?\\d+)([Ee][-+]?[0-2]?\\d{1,2})?)?[i]|[-+]?(\\d+\\.?\\d*|\\d*\\.?\\d+)([Ee][-+]?[0-2]?\\d{1,2})?[r]?[-+]((\\d+\\.?\\d*|\\d*\\.?\\d+)([Ee][-+]?[0-2]?\\d{1,2})?)?[i])$",
        "title": "Test"
    },
    {
        "description": "For the geeks out there, you can use this to break down die rolls of multisided dice for things like role playing games. Includes support for a die multiplier and an end modifier value. Supports a multiplier up to 99, and sides and a modifier of up to 999.",
        "matches": [
            "d12",
            "2d4",
            "3D8-2",
            "99D999+999"
        ],
        "nonMatches": [
            "0d6",
            "100d4",
            "2a4",
            "3D8*3"
        ],
        "pattern": "([1-9]{1,2})?(d|D)([1-9]{1,3})((\\+|-)([1-9]{1,3}))?",
        "title": "Test"
    },
    {
        "description": "RFC2822 compliant email matching regex that doesn\u0027t assume TLDs are set for all time. Clearly this means that someone could get a 2 letter country code wrong, but since no TLD is set in stone, I prefer to match future possibilities as well. This also conforms to what traditional DNS can do w/r/t hostnames and domain names.",
        "matches": [
            "john.o\u0027malley@mail.example.org"
        ],
        "nonMatches": [
            "aoluser1"
        ],
        "pattern": "^(([-\\w$%\u0026\u0027*+\\/=?^_\u0060{|}~.]+)@(([-a-zA-Z0-9_]+\\.)*)([-a-zA-Z0-9]+\\.)([a-zA-Z0-9]{2,7}))?$",
        "title": "Test"
    },
    {
        "description": "This expresssion will validate all possible formats except if web site URL contains hyphen characters like aa@a-b-c.com. I will include this feature also in next version.",
        "matches": [
            "a@abc.com,a@abc.co.in,aa.bb@abc.com.sg,aa_bb@abc.biz,aa.C.bb@abc.com,aa_1900@abc.co.in"
        ],
        "nonMatches": [
            "@abc.com,a@abc.co.in.in,a@abc.com.in.in,a@a-b-c.com"
        ],
        "pattern": "/^([a-zA-Z0-9])(([\\-.]|[_]+)?([a-zA-Z0-9]+))*(@){1}[a-z0-9]+[.]{1}(([a-z]{2,3})|([a-z]{2,3}[.]{1}[a-z]{2,3}))$/",
        "title": "Test"
    },
    {
        "description": "Matches strings that only contain Arabic letters (no spaces). if you want to include spaces it should be ^[\\u0621-\\u064A\\040]+$",
        "matches": [
            "\u0627\u0644\u0644\u0647 \u0623\u0643\u0628\u0631"
        ],
        "nonMatches": [
            "test"
        ],
        "pattern": "^[\\u0621-\\u064A]+$",
        "title": "Test"
    },
    {
        "description": "Great for extracting out all the image src attributes.",
        "matches": [
            "\u003Cimg src=\u0022gif.gif\u0022\u003E\u003C/img\u003E",
            "\u003Cimg id=\u0022blah\u0022 src=\u0022gif\u0022\u003E\u003C/img\u003E",
            "\u003Cimg src=\u0022gif.gif\u0022 id=\u0022freaky\u0022\u003E",
            "\u003C/img\u003E",
            "\u003Cimg src=\u0022gif.gif\u0022 /\u003E",
            "\u003Cimg src=\u0022gif.gif\u0022/\u003E",
            "\u003Cimg class=\u0022FloatLeft Margin\u0022 id=\u0022calendarButton81\u0022 src=\u0022calendar.gif\u0022 alt=\u0022Calendar Button\u0022 /\u003E"
        ],
        "nonMatches": [
            "\u003Cinput id=\u0022\u0022 value=\u0022\u0022/\u003E"
        ],
        "pattern": "\u003C[iI][mM][gG][a-zA-Z0-9\\s=\u0022.]*((src)=\\s*(?:\u0022([^\u0022]*)\u0022|\u0027[^\u0027]*\u0027))[a-zA-Z0-9\\s=\u0022.]*/*\u003E(?:\u003C/[iI][mM][gG]\u003E)*",
        "title": "Test"
    },
    {
        "description": "Use this RegExp to grab SRC($1) and ALT($3) values from IMG tags in valid or invalid HTML (XHTML). SRC param must by before IMG. (thanks to mr. Mrva)",
        "matches": [
            "<img src=\u0022xxx\u0022>",
            "<img src=xxx>",
            "<img src=\u0022xxx\u0022 alt=\u0022xxx\u0022 />",
            "<img src=\u0022xxx\u0022 alt=\u0022xxx\u0022 width=\u0022N\u0022 height=\u0022N\u0022 />",
            "etc."
        ],
        "nonMatches": [
            "<img>",
            "<img />",
            "<img alt=\u0022XXX\u0022 src=\u0022XXX\u0022>"
        ],
        "pattern": "\u003Cimg[^\u003E]*src=\\\u0022?([^\\\u0022]*)\\\u0022?([^\u003E]*alt=\\\u0022?([^\\\u0022]*)\\\u0022?)?[^\u003E]*\u003E",
        "title": "Test"
    },
    {
        "description": "Get one and two numeric digits between 1 and 12 inclusive, positive numbers only (Zeros are excluded and so is values higher than 12).",
        "matches": [
            "1",
            "6",
            "12"
        ],
        "nonMatches": [
            "-1",
            "0",
            "13"
        ],
        "pattern": "^1?[1-2]$|^[1-9]$|^[1]0$",
        "title": "Test"
    },
    {
        "description": "It matches all strings that the .NET Framework API \u0022new Guid(string guid)\u0022 can recognize. A String that contains a GUID in one of the following formats (\u0027d\u0027 represents a hexadecimal digit whose case is ignored):",
        "matches": [
            "ca761232ed4211cebacd00aa0057b223",
            "CA761232-ED42-11CE-BACD-00AA0057B223",
            "{CA761232-ED42-11CE-BACD-00AA0057B223}",
            "(CA761232-ED42-11CE-BACD-00AA0057B223)",
            "{0xCA761232,0xED42,0x11CE,{0xBA,0xCD,0x00,0xAA,0x00,0x57,0xB2,0x23}}"
        ],
        "nonMatches": [
            "Invalid guids"
        ],
        "pattern": "[({]?(0x)?[0-9a-fA-F]{8}([-,]?(0x)?[0-9a-fA-F]{4}){2}((-?[0-9a-fA-F]{4}-?[0-9a-fA-F]{12})|(,\\{0x[0-9a-fA-F]{2}(,0x[0-9a-fA-F]{2}){7}\\}))[)}]?",
        "title": "Test"
    },
    {
        "description": "Validates the format of a Windows folder path ending with a backslash using the drive path or Universal Naming Convention (UNC)--without using lookaround.\u003Cbr\u003E\u003Cbr\u003EWindows folder components: \u003Cbr\u003E(I) The drive can only be one letter. \u003Cbr\u003E(II) The server name (1) can only contain letters, numbers, and hyphens. However, Windows does allow underscores--which aren\u2019t standard characters in the Request for Comments (RFC) 1035 standard--for networks using the Microsoft DNS Server. (Reference: http://support.microsoft.com/default.aspx?scid=kb;en-us;222823) or (2) can be an IP address \u003Cbr\u003E(III) The share name (also called the service name) (1) Can contain any character except ones with an ASCII code in the range of 0 (x00) through 31 (x1F) and the following: \u0022 * / : ? | \u003C\u003E \\ , ; [ ] + = (Reference: http://support.microsoft.com/default.aspx?scid=kb;en-us;236388) (2) Can begin or end with a period, but cannot contain all periods (3) Cannot begin or end with a space (4) There must be at least one character that is not a space or period if the rest of the share name contains periods and spaces or just periods. \u003Cbr\u003E(IV) The folder and subfolder names (without the drive, share, or server name) (1) Can contain any character except ones with an ASCII code in the range of 0 (x00) through 31 (x1F) and the following: \u0022 * / : ? | \u003C\u003E \\ (Reference: http://msdn2.microsoft.com/en-us/library/aa365247.aspx) (2) Cannot begin or end with a space or period.",
        "matches": [
            "d:\\, \\\\Dpk\\T c\\, E:\\reference\\h101\\, \\\\be\\projects$\\Wield\\Rff\\, \\\\70.60.44.88\\T d\\SPC2\\"
        ],
        "nonMatches": [
            "j:ohn\\, \\\\Dpk\\, G:\\GD, \\\\cae\\.. ..\\, \\\\70.60.44\\T d\\SPC2\\"
        ],
        "pattern": "^([A-Za-z]:|\\\\{2}([-\\w]+|((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))\\\\(([^\u0022*/:?|\u003C\u003E\\\\,;[\\]+=.\\x00-\\x20]|\\.[.\\x20]*[^\u0022*/:?|\u003C\u003E\\\\,;[\\]+=.\\x00-\\x20])([^\u0022*/:?|\u003C\u003E\\\\,;[\\]+=\\x00-\\x1F]*[^\u0022*/:?|\u003C\u003E\\\\,;[\\]+=\\x00-\\x20])?))\\\\([^\u0022*/:?|\u003C\u003E\\\\.\\x00-\\x20]([^\u0022*/:?|\u003C\u003E\\\\\\x00-\\x1F]*[^\u0022*/:?|\u003C\u003E\\\\.\\x00-\\x20])?\\\\)*$",
        "title": "Test"
    },
    {
        "description": "This expression is for matching the currency input. The \u00A3 is optional. e.g. \u00A312.12, \u00A3 12.12, 12.12, 12.",
        "matches": [
            "\u00A3123.00"
        ],
        "nonMatches": [
            "$123.00"
        ],
        "pattern": "^(( )*\\\u00A3{0,1}( )*)\\d*(.\\d{1,2})?$",
        "title": "Test"
    },
    {
        "description": "Australian phone number validator. Accepts all forms of Australian phone numbers in different formats (area code in brackets, no area code, spaces between 2-3 and 6-7th digits, +61 international dialing code). Checks that area codes are valid (when entered).",
        "matches": [
            "0403111111",
            "(03) 1111 1111",
            "+61403111111",
            "02 9111 1111",
            "0403 111 111",
            "91111111"
        ],
        "nonMatches": [
            "9111 11111",
            "99 1111 1111"
        ],
        "pattern": "^\\({0,1}((0|\\+61)(2|4|3|7|8)){0,1}\\){0,1}(\\ |-){0,1}[0-9]{2}(\\ |-){0,1}[0-9]{2}(\\ |-){0,1}[0-9]{1}(\\ |-){0,1}[0-9]{3}$",
        "title": "Test"
    },
    {
        "description": "This regex avoids matching typical mistakes where a sentence ends but there is no space after the full stop (period). Other regexes will think any two words with a dot in between is a URL! My regex does not require http:// and if there isn\u0027t http:// it will need to find AT LEAST two dots to guarantee its likely to be a URL and not a sentence that\u0027s missing a space like this.It will match www.test.com, http://test.com, test.com/index.htm but it will NOT match test.com. It will not match a dot or a comma at the very end which some people may type when including a URL in a sentence like this www.test.com, or this www.test.com.",
        "matches": [
            "sub.test.com"
        ],
        "nonMatches": [
            "test.com"
        ],
        "pattern": "(http(s?)://|[a-zA-Z0-9\\-]+\\.)[a-zA-Z0-9/~\\-]+\\.[a-zA-Z0-9/~\\-_,\u0026\\?\\.;]+[^\\.,\\s\u003C]",
        "title": "Test"
    },
    {
        "description": "This should help in finding european style phone numbers (without hyphens), particularly danish numbers with consist of 8 digits, and can be separated by a whitespace.",
        "matches": [
            "(+45) 35 35 35 35",
            "+45 35 35 35 35",
            "35 35 35 35",
            "35353535"
        ],
        "nonMatches": [
            "(45)35353535",
            "4535353535"
        ],
        "pattern": "^((\\(?\\+45\\)?)?)(\\s?\\d{2}\\s?\\d{2}\\s?\\d{2}\\s?\\d{2})$",
        "title": "Test"
    },
    {
        "description": "Matches a complete HTML href tag, placing the URL into a group named \u0022url\u0022 and the innerHTML into a group named \u0022innerHtml\u0022",
        "matches": [
            "\u003Ca href=\u0022http://regexplib.com\u0022\u003EInner \u003Cspan\u003Ehtml\u003C/span\u003E\u003C/a\u003E"
        ],
        "nonMatches": [
            "\u003Ca href=\u0022http://regexplib.com\u0022\u003E"
        ],
        "pattern": "(?i)(?s)\u003Ca[^\u003E]+?href=\u0022?(?\u003Curl\u003E[^\u0022]+)\u0022?\u003E(?\u003CinnerHtml\u003E.+?)\u003C/a\\s*\u003E",
        "title": "Test"
    },
    {
        "description": "Matches any range of numbers according to the format x;x-xx where \u0022x\u0022 is a number between 0 and 9, however 0 may not be a the starting digit of a multi-digit number (i.e. 001). The format specifies that a range is denoted by x-x (numbers are seperated by a hyphen) and multiple range specification or single numbers may be seperated by a semi-colon \u0022;\u0022.",
        "matches": [
            "0",
            "0-3",
            "1;2",
            "1;2-3",
            "2-3;10",
            "1-2;3-40"
        ],
        "nonMatches": [
            "1;",
            "2-3;",
            "a;1",
            "2-3;a",
            "001-3",
            "1-003"
        ],
        "pattern": "^((0|[1-9]+[0-9]*)-(0|[1-9]+[0-9]*);|(0|[1-9]+[0-9]*);)*?((0|[1-9]+[0-9]*)-(0|[1-9]+[0-9]*)|(0|[1-9]+[0-9]*)){1}$",
        "title": "Test"
    },
    {
        "description": "Validates the format of a Windows folder path ending with a backslash using the Universal Naming Convention (UNC)--without using lookaround.\u003Cbr\u003E\u003Cbr\u003EWindows UNC folder components: \u003Cbr\u003E(I) The server name can only contain letters, numbers, and hyphens. However, Windows does allow underscores--which aren\u2019t standard characters in the Request for Comments (RFC) 1035 standard--for networks using the Microsoft DNS Server. (Reference: http://support.microsoft.com/default.aspx?scid=kb;en-us;222823) \u003Cbr\u003E(II) The share name (also called the service name) (1) Can contain any character except ones with an ASCII code in the range of 0 (x00) through 31 (x1F) and the following: \u0022 * / : ? | \u003C\u003E \\ , ; [ ] + = (Reference: http://support.microsoft.com/default.aspx?scid=kb;en-us;236388) (2) Can begin or end with a period, but cannot contain all periods (3) Cannot begin or end with a space (4) There must be at least one character that is not a space or period if the rest of the share name contains periods and spaces or just periods. \u003Cbr\u003E(III) The folder and subfolder names (without the share and server names) (1) Can contain any character except ones with an ASCII code in the range of 0 (x00) through 31 (x1F) and the following: \u0022 * / : ? | \u003C\u003E \\ (Reference: http://msdn2.microsoft.com/en-us/library/aa365247.aspx) (2) Cannot begin or end with a space or period.",
        "matches": [
            "\\\\Dpk\\T c\\, \\\\be\\projects$\\Wield\\Rff\\"
        ],
        "nonMatches": [
            "j:ohn\\, \\\\Dpk\\, G:\\GD, \\\\cae\\.. ..\\, d:\\, E:\\reference\\h101\\"
        ],
        "pattern": "^\\\\{2}[-\\w]+\\\\(([^\u0022*/:?|\u003C\u003E\\\\,;[\\]+=.\\x00-\\x20]|\\.[.\\x20]*[^\u0022*/:?|\u003C\u003E\\\\,;[\\]+=.\\x00-\\x20])([^\u0022*/:?|\u003C\u003E\\\\,;[\\]+=\\x00-\\x1F]*[^\u0022*/:?|\u003C\u003E\\\\,;[\\]+=\\x00-\\x20])?)\\\\([^\u0022*/:?|\u003C\u003E\\\\.\\x00-\\x20]([^\u0022*/:?|\u003C\u003E\\\\\\x00-\\x1F]*[^\u0022*/:?|\u003C\u003E\\\\.\\x00-\\x20])?\\\\)*$",
        "title": "Test"
    },
    {
        "description": "a simplistic path/filename for windows (more restrictive than for Mac OS or *nix). Updated escaping, end of string.",
        "matches": [
            "path/to/filename.txt",
            "/prefixed.slash/value",
            "/a/single/l/e/t/t/e/r"
        ],
        "nonMatches": [
            "lead/space",
            ".hidden/folder",
            "wildcards.???"
        ],
        "pattern": "^[/]*([^/\\\\ \\:\\*\\?\u0022\\\u003C\\\u003E\\|\\.][^/\\\\\\:\\*\\?\\\u0022\\\u003C\\\u003E\\|]{0,63}/)*[^/\\\\ \\:\\*\\?\u0022\\\u003C\\\u003E\\|\\.][^/\\\\\\:\\*\\?\\\u0022\\\u003C\\\u003E\\|]{0,63}$",
        "title": "Test"
    },
    {
        "description": "Matches any single characters that don\u0027t belong to a windows new line character sequence.",
        "matches": [
            "a\\rb\\nc"
        ],
        "nonMatches": [
            "\\r\\n"
        ],
        "pattern": "[^\\r\\n]|(?:\\r(?!\\n))|(?:(?\u003C!\\r)\\n)",
        "title": "Test"
    },
    {
        "description": "A regex I came up with for validating urls, didn\u0027t test thoroughly but seems to do the trick.",
        "matches": [
            "http://sportsalert.net, https://www.sportsalert.net, http://sportsalert.net.uk, http://sportsalert.net/index.html, http://sportsalert.net/subdirectory, http://sportsalert.net?var1=param1\u0026var2=param2"
        ],
        "nonMatches": [
            "www.sportsalert.net, http://.sportsalert.net, http://sportsalert..net"
        ],
        "pattern": "^((http://)|(https://))((([a-zA-Z0-9_-]*).?([a-zA-Z0-9_-]*))|(([a-zA-Z0-9_-]*).?([a-zA-Z0-9_-]*).?([a-zA-Z0-9_-]*)))/?([a-zA-Z0-9_/?%=\u0026+#.-~]*)$",
        "title": "Test"
    },
    {
        "description": "This regex is designed to fail fast (using possessive quantifiers) while still matching a floating decimal number all the time. Won\u0027t match scientific notation or fractions. Can be combined with other patterns. Note: This site\u0027s tester does not support them. If your language does not support possessive quantifiers try the following: (?\u003E[+-]?)(?\u003E(?\u003E\\d+)(?\u003E\\.?)(?\u003E\\d*)|(?\u003E\\d*)(?\u003E\\.?)(?\u003E\\d+))",
        "matches": [
            "+7",
            "-7.7",
            ".7",
            "7.",
            "etc"
        ],
        "nonMatches": [
            "1/7",
            "7e10"
        ],
        "pattern": "[+-]?+(?\u003E\\d++\\.?+\\d*+|\\d*+\\.?+\\d++)",
        "title": "Test"
    },
    {
        "description": "Variable 1 = \u0022complete attribute and value\u0022. Variable 2 = \u0022attribute value only\u0022. For meeting compliance with W3C AA rules, I\u0027ve been using this in a simple HTML parser to convert certain background tags from the deprecated \u0027bgcolor\u0027 attribute to now using a \u0027style=background:\u0027 and the passed colour. This had to be only on hexadecimal values for my current needs. Later modifications : 1. Only for certain tags (eg. td,tr,table). 2. If matching an opening apostrophe/quotation mark, only capture variable if there is a closing one.",
        "matches": [
            "table bgcolor=\u0022#A3A3A3\u0022",
            "table bgcolor= #A3A3A3\u0022",
            "td bgcolor= #A3A3A3",
            "td bgcolor=#A3A3A3 alt=\u0022somethingelse\u0022"
        ],
        "nonMatches": [
            "tr bgcolor=\u0022\u0022 test",
            "tablebgcolor=\u0022#A3A3A3\u0022",
            "table bgcolor=\u0022test2\u0022",
            "td bgcolor=\u0022red\u0022",
            "td bgcolor=\u0022#$%skis\u0022"
        ],
        "pattern": "\u003C.*\\b(bgcolor\\s*=\\s*[\\\u0022|\\\u0027]*(\\#\\w{6})[\\\u0022|\\\u0027]*).*\u003E",
        "title": "Test"
    },
    {
        "description": "Small w is used in expression. if you\u0027ll use capital W then it is for \u0022Not Alphanumeric\u0022",
        "matches": [
            "gjh23_sdfsd45"
        ],
        "nonMatches": [
            "fg@#$234TRET"
        ],
        "pattern": "\\w*",
        "title": "Test"
    },
    {
        "description": "Matches only arabic characters",
        "matches": [
            "\u0639\u0631\u0628\u064A"
        ],
        "nonMatches": [
            "134 English"
        ],
        "pattern": "\\p{IsArabic}",
        "title": "Test"
    },
    {
        "description": "This pattern will match any positive number(Real or Integer). It will not match ZERO or any variation of zero (ie 0.00)",
        "matches": [
            "0.003",
            "34",
            "6.000",
            "7.3"
        ],
        "nonMatches": [
            "0.0",
            "-34",
            "-23.00",
            "0",
            "-0.30"
        ],
        "pattern": "(^[0][.]{1}[0-9]{0,}[1-9]+[0-9]{0,}$)|(^[1-9]+[0-9]{0,}[.]?[0-9]{0,}$)",
        "title": "Test"
    },
    {
        "description": "It is used for simple validation. This regular expression will match the all type of credit card patterns, like AMEX,VISA,MASTER, Dinnerclub, JCB, enRoute ,Discover",
        "matches": [
            "370000000000002"
        ],
        "nonMatches": [
            "270000000000002"
        ],
        "pattern": "^[3|4|5|6]([0-9]{15}$|[0-9]{12}$|[0-9]{13}$|[0-9]{14}$)",
        "title": "Test"
    },
    {
        "description": "Validates four-digit leap years after 1582 (when Pope Gregory XIII switched to the Gregorian calendar). The last recognized leap year is 9996, so no worries with the y3k bug.",
        "matches": [
            "1584, 2000, 2048"
        ],
        "nonMatches": [
            "1200, 1580, 1941, 1800"
        ],
        "pattern": "(15(8[48]|9[26]))|((1[6-9]|[2-9]\\d)(0[48]|[13579][26]|[2468][048]))|(([2468][048]|16|3579[26])00)",
        "title": "Test"
    },
    {
        "description": "This is the date validator for dates of the format DD-MMM-YYY",
        "matches": [
            "25-Nov-2005, 25-dEc-2006, 18-2004"
        ],
        "nonMatches": [
            "19-Fab-2005, 19--dec-2006"
        ],
        "pattern": "^((31(?!(\\-)((F|f)(E|e)(B|b)|(A|a)(P|p)(R|r)|(J|j)(U|u)(N|n)|(S|s)(E|e)(P|p)|(N|n)(O|o)(V|v))))|((30|29)(?!(\\-)((F|f)(E|e)(B|b))))|(29(?=(\\-)(F|f)(E|e)(B|b)(\\-)(((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))|(0?[1-9])|1\\d|2[0-8])(\\-)((J|j)(A|a)(N|n)|(F|f)(E|e)(B|b)|(M|m)(A|a)(R|r)|((M|m)(A|a)(Y|y))|(A|a)(P|p)(R|r)|(J|j)(U|u)(L|l)|(J|j)(U|u)(N|n)|(A|a)(U|u)(G|g)|(O|o)(C|c)(T|t)|(S|s)(E|e)(P|p)|(N|n)(O|o)(V|v)|(D|d)(E|e)(C|c))(\\-)((1[6-9]|[2-9]\\d)\\d{2})$",
        "title": "Test"
    },
    {
        "description": "It accepts only two integer after a decimal point. The number may be in Positive or negative.",
        "matches": [
            "+1212.14",
            "-12.13",
            "122.45"
        ],
        "nonMatches": [
            "1212.4564",
            "-11.5858",
            "12.000"
        ],
        "pattern": "^[-+]?\\d+(\\.\\d{2})?$",
        "title": "Test"
    },
    {
        "description": "This regex checks if a date is in ISO-format (yyyy-mm-dd). Leap year should be checked too. Date has to be between 1900-01-01 and 2999-12-31.",
        "matches": [
            "1900-01-01",
            "2025-03-15",
            "2999-12-31"
        ],
        "nonMatches": [
            "1890-01-01",
            "2008-19-45",
            "3000-01-01"
        ],
        "pattern": "^((((19[0-9][0-9])|(2[0-9][0-9][0-9]))([-])(0[13578]|10|12)([-])(0[1-9]|[12][0-9]|3[01]))|(((19[0-9][0-9])|(2[0-9][0-9][0-9]))([-])(0[469]|11)([-])([0][1-9]|[12][0-9]|30))|(((19[0-9][0-9])|(2[0-9][0-9][0-9]))([-])(02)([-])(0[1-9]|1[0-9]|2[0-8]))|(([02468][048]00)([-])(02)([-])(29))|(([13579][26]00)([-])(02)([-])(29))|(([0-9][0-9][0][48])([-])(02)([-])(29))|(([0-9][0-9][2468][048])([-])(02)([-])(29))|(([0-9][0-9][13579][26])([-])(02)([-])(29)))$",
        "title": "Test"
    },
    {
        "description": "This regex checks if a date is in german date format (dd.mm.yyyy). Leap year should be checked too. Date has to be between 01.01.1900 and 31.12.2999.",
        "matches": [
            "01.01.1900",
            "20.11.2009",
            "31.12.2999"
        ],
        "nonMatches": [
            "01.01.1890",
            "11.20.2009",
            "01.01.3000"
        ],
        "pattern": "^(((0[1-9]|[12][0-9]|3[01])([\\.])(0[13578]|10|12)([\\.])((19[0-9][0-9])|(2[0-9][0-9][0-9])))|(([0][1-9]|[12][0-9]|30)([\\.])(0[469]|11)([\\.])((19[0-9][0-9])|(2[0-9][0-9][0-9])))|((0[1-9]|1[0-9]|2[0-8])([\\.])(02)([\\.])((19[0-9][0-9])|(2[0-9][0-9][0-9])))|((29)([\\.])(02)([\\.])([02468][048]00))|((29)([\\.])(02)([\\.])([13579][26]00))|((29)([\\.])(02)([\\.])([0-9][0-9][0][48]))|((29)([\\.])(02)([\\.])([0-9][0-9][2468][048]))|((29)([\\.])(02)([\\.])([0-9][0-9][13579][26])))$",
        "title": "Test"
    },
    {
        "description": "When removing any whitespace from something like an excel formula, you need to strip the whitespace from around cell references or other non-quoted strings, while leaving quoted (both single and double quotes) in tact. It even works when another different quote, or double quote is embedded in the string. You can execute this with a replacement group $1 to replace the spaces with another character (or empty string to remove the spaces). Does not match if the quoted string spans multiple lines (if \\r\\n is inside the quoted string)",
        "matches": [
            "REGEX ROCKS"
        ],
        "nonMatches": [
            "\u0022SOME QUOTED STRING\u0022, \u0022REGEX\u0027S ROCKS\u0022, \u0027REGEX ROCKS\u0027"
        ],
        "pattern": "(?:\\s+)|((?:\u0022(?:.+?)\u0022)|(?:\u0027(?:.+?)\u0027))",
        "title": "Test"
    },
    {
        "description": "Removes HTML comments with ease. Based off of Chris Craft\u0027s /* ... */ comment removal.",
        "matches": [
            "<!--testcomment--\u003E, <!-- Another test comment --\u003E, <!-- <img src=\u0022test.jpg\u0022\u003E --\u003E"
        ],
        "nonMatches": [
            "<b\u003E, <a href=\u0022test.html\u0022\u003E...</a\u003E, <br\u003E"
        ],
        "pattern": "\u003C!--[\\d\\D]*?--\u003E",
        "title": "Test"
    },
    {
        "description": "A simple but powerful URL validating regex. Accepts multiple sub-domains and sub-directories. Even accept query strings. Now accept ports! Accepts HTTP or HTTPS. Also accepts optional \u0022/\u0022 on end of address.",
        "matches": [
            "http://website.com",
            "http://subdomain.web-site.com/cgi-bin/perl.cgi?key1=value1\u0026key2=value2"
        ],
        "nonMatches": [
            "http://website.com/perl.cgi?key=",
            "http://web-site.com/cgi-bin/perl.cgi?key1=value1\u0026key2"
        ],
        "pattern": "^(http(?:s)?\\:\\/\\/[a-zA-Z0-9]+(?:(?:\\.|\\-)[a-zA-Z0-9]+)+(?:\\:\\d+)?(?:\\/[\\w\\-]+)*(?:\\/?|\\/\\w+\\.[a-zA-Z]{2,4}(?:\\?[\\w]+\\=[\\w\\-]+)?)?(?:\\\u0026[\\w]+\\=[\\w\\-]+)*)$",
        "title": "Test"
    },
    {
        "description": "After reading RFC2822 (then taking two asprin) I\u0027ve come to the conclusion that I will not allow all RFC compliant email addresses to be entered in the forms on my website and will never have an issue with it. I demand a stricter tolerance for my website than RFC allows. If you\u0027re like me and only want to allow 99% of those email addresses entered into web-forms then use this little gem of an email checking regex. Also, I\u0027ve never met anyone who would submit an email address taking full advantage of RFC2822\u0027s allowances nor would I care to accommodate one who would.",
        "matches": [
            "name@email.com"
        ],
        "nonMatches": [
            "_name@.email.com"
        ],
        "pattern": "^([a-zA-Z0-9]+(?:[.-]?[a-zA-Z0-9]+)*@[a-zA-Z0-9]+(?:[.-]?[a-zA-Z0-9]+)*\\.[a-zA-Z]{2,7})$",
        "title": "Test"
    },
    {
        "description": "Validation of date (YYYY-MM-DD format) and time (HH:MM format) with one space between both blocks. I\u0027m not able (with this) to validate the correct last day of each month. Anyway, it helps :-)",
        "matches": [
            "2007-01-01 00:00"
        ],
        "nonMatches": [
            "2007-1-1 0:0"
        ],
        "pattern": "[0-9][0-9][0-9][0-9]-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])\\s{1}(0[0-9]|1[0-9]|2[0-3]):([0-5][0-9])",
        "title": "Test"
    },
    {
        "description": "[\\s0-9a-zA-Z\\;\\\u0022\\,]* match any text just add character or symbol to be matched inside[ ] like [\\\u003C] for (\u003C) symbol. if u want find between two word then just use Eg : \u003Cdiv\u003E[\\s0-9a-zA-Z\\;\\\u0022\\,]* \u003C/div\u003E it will return the content between \u003Cdiv\u003E tags. Just add all format to match all .It is better than (.*) because (.*) is difficult to end at particular part as we needed.",
        "matches": [
            "any between given two words"
        ],
        "nonMatches": [
            "not check for new line ...etc .i think it work..."
        ],
        "pattern": "[\\s0-9a-zA-Z\\;\\\u0022\\,\\\u003C\\\u003E\\\\?\\+\\=\\)\\(\\\\*\\\u0026\\%\\\\$\\#\\.]*",
        "title": "Test"
    },
    {
        "description": "I use this one to validate CURP structure. CURP is a mexican unique identifier for certain intitutions like INFONAVIT and it\u0027s very useful",
        "matches": [
            "LAZM890202MYNNGR09"
        ],
        "nonMatches": [
            "SM890202MYNNGR09"
        ],
        "pattern": "^[a-zA-Z]{4}((\\d{2}((0[13578]|1[02])(0[1-9]|[12]\\d|3[01])|(0[13456789]|1[012])(0[1-9]|[12]\\d|30)|02(0[1-9]|1\\d|2[0-8])))|([02468][048]|[13579][26])0229)(H|M)(AS|BC|BS|CC|CL|CM|CS|CH|DF|DG|GT|GR|HG|JC|MC|MN|MS|NT|NL|OC|PL|QT|QR|SP|SL|SR|TC|TS|TL|VZ|YN|ZS|SM|NE)([a-zA-Z]{3})([a-zA-Z0-9\\s]{1})\\d{1}$+",
        "title": "Test"
    },
    {
        "description": "Passwords with at least 1 letter, at least 1 non-letter, and at least 6 characters in length. It is lenthy with a repeating pattern so that I could validate all three conditions in one expression without using a lookahead, \u0022?=\u0022, which are not handled correctly in Internet Explorer.",
        "matches": [
            "12345a",
            "abcde*",
            "ABC123"
        ],
        "nonMatches": [
            "12ab",
            "abcdef",
            "123456"
        ],
        "pattern": "^(.{0,}(([a-zA-Z][^a-zA-Z])|([^a-zA-Z][a-zA-Z])).{4,})|(.{1,}(([a-zA-Z][^a-zA-Z])|([^a-zA-Z][a-zA-Z])).{3,})|(.{2,}(([a-zA-Z][^a-zA-Z])|([^a-zA-Z][a-zA-Z])).{2,})|(.{3,}(([a-zA-Z][^a-zA-Z])|([^a-zA-Z][a-zA-Z])).{1,})|(.{4,}(([a-zA-Z][^a-zA-Z])|([^a-zA-Z][a-zA-Z])).{0,})$",
        "title": "Test"
    },
    {
        "description": "Based on PJ Bijoy\u0027s regex for a US phone number, I\u0027ve added validation that the area code is a valid US Area code (first digit is greater than 2) and that the area code is not a reserved Toll Free Code (800, 822, 833, 844, 855, 866, 877, 888) and not a premium number (900). It will accept phone patterns of ###-###-#### (3 digits dash 3 digits dash 4 digits), ########## (10 digits), (###)###-#### (3 digits in parens 3 digits dash 4 digits), (###)### #### (3 digits in parens 3 digits space 4 digits), (###) ###-#### (3 digits in parens space 3 digits dash 4 digits), (###) ### #### (3 digits in parens space 3 digits space 4 digits)",
        "matches": [
            "814-###-#### - (814) ###-####"
        ],
        "nonMatches": [
            "800-###-#### - (866)-###-####"
        ],
        "pattern": "^\\((([2-7][0-9]{2})|(8(0[^0]|[^0]0|1\\d|2[^2]|[^2]2|3[^3]|[^3]3|4[^4]|[^4]4|5[^5]|[^5]5|6[^6]|[^6]6|7[^7]|[^7]7|8[^8]|[^8]8|9\\d){1})|(9(0[^0]|[^0]0|[1-9][1-9])))\\)\\s?[0-9]{3}(-|\\s)?[0-9]{4}$|^(([2-7][0-9]{2})|(8(0[^0]|[^0]0|1\\d|2[^2]|[^2]2|3[^3]|[^3]3|4[^4]|[^4]4|5[^5]|[^5]5|6[^6]|[^6]6|7[^7]|[^7]7|8[^8]|[^8]8|9\\d){1})|(9(0[^0]|[^0]0|[1-9][1-9])))-?[0-9]{3}-?[0-9]{4}$",
        "title": "Test"
    },
    {
        "description": "any email form like any_name@mail.confidential.yahoo.com, any_name@mail.yahoo.com, any_name@yahoo.com, any.name@yahoo.com, anyname@domain.com. You can replace .com with .net | .edu | .uk | .in or anything. I will work.",
        "matches": [
            "any_name@mail.domain.com or any_name@mail.conf.domain.com, any_name@mail.com"
        ],
        "nonMatches": [
            "any name@mail.com"
        ],
        "pattern": "[\\w]+\\@[\\w]+\\.?[\\w]+?\\.?[\\w]+?\\.?[\\w+]{2,4}",
        "title": "Test"
    },
    {
        "description": "Normaly US 10 digit numbers are writen as xxx.xxx.xxxx or xxx-xxx-xxxx or simply 7 digit numbers for local websites where area code is filled by default xxx.xxxx or xxx-xxxx",
        "matches": [
            "xxx.xxx.xxxx or xxx-xxx-xxxx or xxx.xxxx"
        ],
        "nonMatches": [
            "xxxx"
        ],
        "pattern": "(\\d+)?-?(\\d+)-(\\d+)",
        "title": "Test"
    },
    {
        "description": "This is a very simple regex that check the query part of a string. That is to say anything after the \u0022?\u0022 at the end of an URL.",
        "matches": [
            "?key=value",
            "?key1=value1\u0026key2=value2"
        ],
        "nonMatches": [
            "key=value",
            "?key=value\u0026"
        ],
        "pattern": "^((?:\\?[a-zA-Z0-9_]+\\=[a-zA-Z0-9_]+)?(?:\\\u0026[a-zA-Z0-9_]+\\=[a-zA-Z0-9_]+)*)$",
        "title": "Test"
    },
    {
        "description": "This is a bit shorter than the first CVV2/CVC2/CID regex found on the site. It matches any 3 or 4 character number. Now featuring change per suggestion in comments. Thanks!",
        "matches": [
            "123",
            "1234"
        ],
        "nonMatches": [
            "1",
            "12",
            "12345"
        ],
        "pattern": "^(?!000)\\d{3,4}$",
        "title": "Test"
    },
    {
        "description": "Tests if the input consists of 6 or more letters, digits, underscores and hyphens. The input must contain at least one upper case ltter, one lower case letter and one digit.",
        "matches": [
            "M0_k3y Pa-sW0rd S1mPl3"
        ],
        "nonMatches": [
            "MonKey PassWord simple"
        ],
        "pattern": "(?=[-_a-zA-Z0-9]*?[A-Z])(?=[-_a-zA-Z0-9]*?[a-z])(?=[-_a-zA-Z0-9]*?[0-9])[-_a-zA-Z0-9]{6,}",
        "title": "Test"
    },
    {
        "description": "Mathes any HTML tag with any parameters and HTML Comments. Very useful to clean HTML of a text.",
        "matches": [
            "<tr style=\u0022height: 1px; background-color: #ffffff\u0022> <td colspan=\u00224\u0022> \u0026lt!-- comment --> <!DOCTYPE html PUBLIC ... >"
        ],
        "nonMatches": [
            "Any other text outside a tag symbols < >"
        ],
        "pattern": "\u003C!*[^\u003C\u003E]*\u003E",
        "title": "Test"
    },
    {
        "description": "Matches Visa, American Express, Discover, and Mastercard only.",
        "matches": [
            "4111111111111",
            "4111111111111111",
            "5111111111111111",
            "6011111111111111",
            "341111111111111",
            "371111111111111"
        ],
        "nonMatches": [
            "411111111111",
            "51111111111111111",
            "6111111111111111",
            "321111111111111",
            "381111111111111"
        ],
        "pattern": "^((4(\\d{12}|\\d{15}))|(5\\d{15})|(6011\\d{12})|(3(4|7)\\d{13}))$",
        "title": "Test"
    },
    {
        "description": "Matches only a 32 character hex string (Eg. MD5). Based off Chris Craft\u0027s expression:-)",
        "matches": [
            "09f8814c757a00f14efdb70e45f851d1"
        ],
        "nonMatches": [
            "46345678901234567890aaaabbbbbbzj"
        ],
        "pattern": "^\\{?[a-fA-F\\d]{32}\\}?$",
        "title": "Test"
    },
    {
        "description": "No idea whether anyone would ever need this, but I had to work half a day on this pattern, so I decided to share it. :) It was never meant for productive use at all; it was rather to filter out all that annoying event handling stuff to find a bug in my DHTML table-generating script. Give it a try with this string (see details): \u003Cdiv id=\u0022TSelect_TD_value_911\u0022 class=\u0022TSel\u0022 onpaste=\u0022\u0022 onblur=\u0022TSelectClose(this);\u0022 onClick=\u0022TSelectOpen(this);\u0022 style=\u0022width:250px; padding:2px;\u0022\u003E",
        "matches": [
            "onPaste onBlur onClick ... ; onblur onclick onpaste ..."
        ],
        "nonMatches": [
            "\u003Cdiv id=\u0022TSelect_TD_value_911\u0022 class=\u0022TSel\u0022 style=\u0022width:250px; padding:2px;\u0022\u003E"
        ],
        "pattern": "(\\s(\\bon[a-zA-Z][a-z]+)\\s?\\=\\s?[\\\u0027\\\u0022]?(javascript\\:)?[\\w\\(\\),\\\u0027 ]*;?[\\\u0027\\\u0022]?)+",
        "title": "Test"
    },
    {
        "description": "Finds those pesky ascii characters that can be entered with the alt-numeric pad",
        "matches": [
            "\u03B1",
            "\u00DF",
            "\u255D",
            "\u00F2"
        ],
        "nonMatches": [
            "a",
            "B",
            "%",
            "\u0026"
        ],
        "pattern": "[\\x80-\\xFF]",
        "title": "Test"
    },
    {
        "description": "Croatian phone numbers (old style). Area code and phone number, area code optional. Area code in $2 (if specified) phone number is in $4 or $5+$6+$7 or $8+$9.",
        "matches": [
            "01/4444-555, 01/44-55-66, 042/333-999, 0800/556677, 1234567"
        ],
        "nonMatches": [
            "(01) 3344556, 012233445, 042555666"
        ],
        "pattern": "^((\\d{2,4})/)?((\\d{6,8})|(\\d{2})-(\\d{2})-(\\d{2,4})|(\\d{3,4})-(\\d{3,4}))$",
        "title": "Test"
    },
    {
        "description": "This will validate multiple email addresses that are comma delimited. You can change it to use commas or semilcolons. If you have to worry about a lot of special characters, you may have to edit it a little bit. It allows white space before and after the comma.",
        "matches": [
            "Test@host.com",
            "email1@host.com,email2@host.com,email3@host.com",
            "email1@host.com, email2@host.com , email3@host.com"
        ],
        "nonMatches": [
            "test@test",
            "test@host.com,test@",
            "test@ host.com"
        ],
        "pattern": "^((\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*)\\s*[,]{0,1}\\s*)+$",
        "title": "Test"
    },
    {
        "description": "This regular expression can be used for validating a strong password. It expects at least 1 lowercase letter, 1 uppercase letter, and 1 digit. It will also allow for some special characters. The length should be greater than 8 characters. The sequence of the characters is not important.",
        "matches": [
            "Password1",
            "1Passwor",
            "passworD1",
            "2passWord",
            "Pass2Word",
            "pa1SS2word",
            "!1qAzxsw2"
        ],
        "nonMatches": [
            "q3w4e5er",
            "asdfg",
            "asdfghjkl;",
            "ag asg ag",
            "d36234724",
            "mko)+OKM1"
        ],
        "pattern": "(?=^.{8,}$)(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?!.*\\s)[0-9a-zA-Z!@#$%^\u0026*()]*$",
        "title": "Test"
    },
    {
        "description": "This expression validates dates in the mm/dd/yyyy format and ya..expression will take care of the leap year dates",
        "matches": [
            "01/01/1901, 10/31/2007"
        ],
        "nonMatches": [
            "02/31/1901, 04/31/2007"
        ],
        "pattern": "^(?:(?:(?:0?[13578]|1[02])(\\/|-)31)|(?:(?:0?[1,3-9]|1[0-2])(\\/|-)(?:29|30)))(\\/|-)(?:[1-9]\\d\\d\\d|\\d[1-9]\\d\\d|\\d\\d[1-9]\\d|\\d\\d\\d[1-9])$|^(?:(?:0?[1-9]|1[0-2])(\\/|-)(?:0?[1-9]|1\\d|2[0-8]))(\\/|-)(?:[1-9]\\d\\d\\d|\\d[1-9]\\d\\d|\\d\\d[1-9]\\d|\\d\\d\\d[1-9])$|^(0?2(\\/|-)29)(\\/|-)(?:(?:0[48]00|[13579][26]00|[2468][048]00)|(?:\\d\\d)?(?:0[48]|[2468][048]|[13579][26]))$",
        "title": "Test"
    },
    {
        "description": "For all of you who have Blue Cross Blue Shield insurance coverage (not Federal, though)- check out your insurance cards! It ALWAYS begins with 3 letters (called the alpha prefix) and a series of alpha-numeric characters ranging from 8 to 12 digits.",
        "matches": [
            "XOF800108019 MRT10829939W WHWXZA130299"
        ],
        "nonMatches": [
            "XQM100X 129-22-5898 R12345678"
        ],
        "pattern": "^[A-Z]{3}(\\d|[A-Z]){8,12}$",
        "title": "Test"
    },
    {
        "description": "match US currency",
        "matches": [
            "most"
        ],
        "nonMatches": [
            "not known"
        ],
        "pattern": "^((\\d{1,3}((,\\d{3})*|\\d*)(\\.{0,1})\\d+)|\\d+)$",
        "title": "Test"
    },
    {
        "description": "That is just an improved expression for handling capitalized names. Improvement #1 - Allowed using names consisting of 3 parts. Improvement #2 - Introduced restriction that the name must start from capital character.",
        "matches": [
            "Rana Mohsin Ali"
        ],
        "nonMatches": [
            "rana Mohsin Ali"
        ],
        "pattern": "^([A-Z]+[a-zA-Z]*)(\\s|\\-)?([A-Z]+[a-zA-Z]*)?(\\s|\\-)?([A-Z]+[a-zA-Z]*)?$",
        "title": "Test"
    },
    {
        "description": "Brazilian ID document, known in Brazil as RG (Registro Geral).",
        "matches": [
            "12.123.123",
            "12.123.123-1"
        ],
        "nonMatches": [
            "12123123",
            "12.12.123",
            "12.123.12",
            "12.123.123-",
            "12.123.123-12"
        ],
        "pattern": "(^(\\d{2}\\x2E\\d{3}\\x2E\\d{3}[-]\\d{1})$|^(\\d{2}\\x2E\\d{3}\\x2E\\d{3})$)",
        "title": "Test"
    },
    {
        "description": "it matches percentage from 1 to 100%. It ignores 0 or 0%. It only support integer matching.",
        "matches": [
            "1%",
            "99%",
            "00099%",
            "99"
        ],
        "nonMatches": [
            "101%",
            "0%"
        ],
        "pattern": "^[0]*?(?\u003CPercentage\u003E[1-9][0-9]?|100)%?$",
        "title": "Test"
    },
    {
        "description": "This expression matches a US phone number with or without the leading 1.",
        "matches": [
            "1 555 765-1234",
            "555 765-1234"
        ],
        "nonMatches": [
            "765-1234",
            "123 456 9876"
        ],
        "pattern": "(1 )?\\d{3} \\d{3}-\\d{4}",
        "title": "Test"
    },
    {
        "description": "Allows \u0022words\u0022 with alphanumeric characters, including the underscore _ character. Disallows leading or trailing spaces, also doubled-up spaces within the text. If you want to disallow the underscore character, you can replace the two occurrences of \\w with a-zA-Z",
        "matches": [
            "Test 000"
        ],
        "nonMatches": [
            "Punctuation! Or doubled up, leading or trailing spaces"
        ],
        "pattern": "^[\\w0-9]+( [\\w0-9]+)*$",
        "title": "Test"
    },
    {
        "description": "RFC2822 compliant. Includes all special characters, except for allowance of quoted local-part. Also disallows \u0027.\u0027 (period) to be at the front or end of local-part, or occurr more than once consecutively. It does allow for optional infinite number of sub-domains. The following standards are not enforced, due to RegExp limitations (unable to check for group string length): As per RFC2821 the local-part may have a maximum length of 64 characters, while the domain name may have a maximum length of 255 characters. Each domain label must be between 1 and 63 characters long, while the total length of the domain name may not exceed 255 characters.",
        "matches": [
            "my.sub.test.server@sub.host.server.uk.co"
        ],
        "nonMatches": [
            ".stubs@com",
            ".me@server.com",
            "my..name@server.com"
        ],
        "pattern": "^(?i:(?\u003Clocal_part\u003E[a-z0-9!#$%^\u0026*{}\u0027\u0060+=-_|/?]+(?:\\.[a-z0-9!#$%^\u0026*{}\u0027\u0060+=-_|/?]+)*)@(?\u003Clabels\u003E[a-z0-9]+\\z?.*[a-z0-9-_]+)*(?\u003Ctld\u003E\\.[a-z0-9]{2,}))$",
        "title": "Test"
    },
    {
        "description": "This RegularExpression is used to validate the US - SSN. This regular expression wont allow characters as well as all zeros",
        "matches": [
            "123-45-6789"
        ],
        "nonMatches": [
            "000-00-0000"
        ],
        "pattern": "(^(?!000)\\d{3}) ([- ]?) ((?!00)\\d{2}) ([- ]?) ((?!0000)\\d{4})",
        "title": "Test"
    },
    {
        "description": "Validates an German area dial code and telephone number.",
        "matches": [
            "0049891567",
            "+49891234567",
            "0891234567"
        ],
        "nonMatches": [
            "004312345678",
            "4912345678",
            "(+49)1234567"
        ],
        "pattern": "^((00|\\+)49)?(0?[2-9][0-9]{1,})$",
        "title": "Test"
    },
    {
        "description": "Let\u0027s say that you have a series of characters \u0022abcde\u0022 and you want to match all strings that could be comprised of those characters with each character used exactly once. This could loosely be termed an anagram matcher, although if the string contains duplicate letters it would require modification of this pattern. In the example case we have a string \u0022abcde\u0022 and we want to match any permutation of \u0022abcde\u0022. Note that the \u00225\u0022 used in the pattern indicates the number of characters specified in the character set \u0022abcde\u0022, \u00225\u0022 would still be used if \u0022abcde\u0022 would be replaced with \u0022a-e\u0022 since there would still be 5 characters in the series. If you are curious about how to require duplicates in the pattern (to match all permutations of \u0022apple\u0022 for example) I would use (?=^.*p.*p$)(?!.*([ale]).*\\1)^[aple]{5}$",
        "matches": [
            "abcde",
            "dbcae",
            "edcba"
        ],
        "nonMatches": [
            "abcbe"
        ],
        "pattern": "(?!.*([abcde]).*\\1)^[abcde]{5}$",
        "title": "Test"
    },
    {
        "description": "Matches quoted strings. Do not use anchors or it will not work as expected",
        "matches": [
            "\u0022\u0022",
            "\u0022\\\\\u0022",
            "\u0022\\\u0022\u0022",
            "\u0022abcd\u0022",
            "\u0022ab\\\u0022cd\u0022",
            "\u0022abcd\\\\\u0022"
        ],
        "nonMatches": [
            "\u0022ab",
            "ab\u0022",
            "\u0022ab\\\u0022",
            "\\\u0022ab\u0022",
            "\\\u0022ab\\\u0022cd\u0022"
        ],
        "pattern": "(?\u003C!\\\\)\\\u0022(?:[^\\\u0022]*(?\u003C!\\\\)\\\\\\\u0022)*[^\\\u0022]*\\\u0022",
        "title": "Test"
    },
    {
        "description": "This matches a standard set of plus minus letter grades. A A- B+ B B- C+ C C- D+ D D- F SF NF W (SF - Stopped Attending F) (NF - Never Attended F) (W - Withdraw)",
        "matches": [
            "A",
            "C+",
            "SF"
        ],
        "nonMatches": [
            "A+",
            "F-",
            "Z"
        ],
        "pattern": "^A-?|[BCD][+-]?|[SN]?F|W$",
        "title": "Test"
    },
    {
        "description": "Format when entering page ranges in Print dialogs.",
        "matches": [
            "1-2,4,5",
            "10, 11-12"
        ],
        "nonMatches": [
            "1a",
            "2b"
        ],
        "pattern": "(\\d+(-\\d+)*)+(,\\d+(-\\d+)*)*",
        "title": "Test"
    },
    {
        "description": "This will validate any date (does not check for number of days in month, just 31 days or less) in almost any format as long as the order follows month, day, year, hour, minute, and each part has at least 2 digits.",
        "matches": [
            "01/15/07 1745",
            "011507 1745",
            "01/15/2007 17:45",
            "0115071745"
        ],
        "nonMatches": [
            "13/15/07 1745",
            "013207 1745",
            "01/15/2007 25:45",
            "0115071762"
        ],
        "pattern": "^(((0[1-9]{1})|(1[0-2]{1}))\\/?(([0-2]{1}[1-9]{1})|(3[0-1]{1}))\\/?(([12]{1}[0-9]{1})?[0-9]{2}) ?(([01]{1}[0-9]{1})|(2[0-4]{1}))\\:?([0-5]{1}[0-9]{1}))$",
        "title": "Test"
    },
    {
        "description": "Validate if server and port is valid.",
        "matches": [
            "MyServer:8080"
        ],
        "nonMatches": [
            "1Server:A1",
            "Server:AAA"
        ],
        "pattern": "^(([A-Z])([a-zA-Z0-9]+)?)(\\:)(\\d+)$",
        "title": "Test"
    },
    {
        "description": "this is about land line number in AP .",
        "matches": [
            "040-244648"
        ],
        "nonMatches": [
            "04-2446474"
        ],
        "pattern": "\\d{3}-\\d{6}",
        "title": "Test"
    },
    {
        "description": "This expression will match almost all variations of PO Box.",
        "matches": [
            "P.O. Box, Po Box, Post Office Box, Box, P0 Box"
        ],
        "nonMatches": [
            "Controller\u0027s Office"
        ],
        "pattern": "\\b[P|p]*(OST|ost)*\\.*\\s*[O|o|0]*(ffice|FFICE)*\\.*\\s*[B|b][O|o|0][X|x]\\b",
        "title": "Test"
    },
    {
        "description": "If you want to check for positive and nonzero real numbers (both integer and decimal are supported).",
        "matches": [
            "1.234",
            "1234",
            "0.123",
            "01.2345"
        ],
        "nonMatches": [
            "0",
            "0.0",
            "-123.45",
            "-12345",
            "abc123",
            "12..34"
        ],
        "pattern": "(^([0-9]*[.][0-9]*[1-9]+[0-9]*)$)|(^([0-9]*[1-9]+[0-9]*[.][0-9]+)$)|(^([1-9]+[0-9]*)$)",
        "title": "Test"
    },
    {
        "description": "Matches almost all Israel phone numbers (without 1800). Generic means it doesn\u0027t have a list of allowed prefix (i.e 050,03) because it changes frequently. Instead it accepts any 2-3 digits prefix, with or without hyphen.",
        "matches": [
            "03-1234567",
            "050-1234567",
            "0771234567"
        ],
        "nonMatches": [
            "1-800-1234567",
            "04-123456",
            "9-1234567",
            "1234567"
        ],
        "pattern": "^\\b\\d{2,3}-*\\d{7}\\b$",
        "title": "Test"
    },
    {
        "description": "Matches decimal numbers (english or german writing) followed by metric or time units (mm, cm, dm, m, km, s, min and h) in labels surrounded by any digit.",
        "matches": [
            "345,3m, 345.m, 345m, 345,5 m"
        ],
        "nonMatches": [
            "abc, ABC, 0-9"
        ],
        "pattern": "(?\u003CNbr\u003E[\\+-]?((\\d*\\,\\d+)|(\\d*\\.\\d+)|\\d+))\\s*(?\u003CUnit\u003Emm|cm|dm|min|km|s|m|h)",
        "title": "Test"
    },
    {
        "description": "Intended to validate Australian Phone Numbers. Very loosely based on Bill Hely\u0027s regex, but allows for further options for Country code, (un)bracketed Area code, spaced/hyphenated 8-digit/ Mobile/1X00*/13*.",
        "matches": [
            "+61 02 9123 1234",
            "+61 3 8123 1234",
            "+61 7 9123 1234",
            "+61-04-9123-1234",
            "+61-2-9123-1234",
            "+61-8-9123-1234",
            "+61-7-9123-1234",
            "+61-(03)-9123-1234",
            "+61 (03) 9123-1234",
            "02 9123 1234",
            "03-9123-1234",
            "(03) 9123 1234",
            "(07) 9123 1234",
            "(03) 9123-1234",
            "1900-123-322",
            "1900 322 232",
            "1900322132",
            "1902222032",
            "1800-132 322",
            "1 800 322 222",
            "1300232322",
            "13 73 23",
            "132 221",
            "0400 111 222",
            "0400111222",
            "+61 400 111 222",
            "+61 (0)3 1234 4566",
            "+61 (0)411222333",
            "+61 (0)400-000-000"
        ],
        "nonMatches": [
            "+61-05-9123-1234",
            "+61-6-9123-1234",
            "19021234567"
        ],
        "pattern": "^(\\+\\d{2}[ \\-]{0,1}){0,1}(((\\({0,1}[ \\-]{0,1})0{0,1}\\){0,1}[2|3|7|8]{1}\\){0,1}[ \\-]*(\\d{4}[ \\-]{0,1}\\d{4}))|(1[ \\-]{0,1}(300|800|900|902)[ \\-]{0,1}((\\d{6})|(\\d{3}[ \\-]{0,1}\\d{3})))|(13[ \\-]{0,1}([\\d \\-]{5})|((\\({0,1}[ \\-]{0,1})0{0,1}\\){0,1}4{1}[\\d \\-]{8,10})))$",
        "title": "Test"
    },
    {
        "description": "I needed a clean string of keywords submitted in a form. This expression will select every word that doesn\u0027t have a vowel, every word that is shorter than 2 characters. It will select all non alphabetical characters.",
        "matches": [
            "\u0027re",
            "\u0027s",
            "is",
            "t5",
            "2015",
            "@#$",
            "stt"
        ],
        "nonMatches": [
            "you",
            "john",
            "are",
            "sit"
        ],
        "pattern": "([^\\w]+)|([^A-Za-z])|(\\b[^aeiouy]+\\b)|(\\b(\\w{2})\\b)",
        "title": "Test"
    },
    {
        "description": "Ensures a given string matches the basic pattern of a bank routing transit number (RTN), used to identify financial institutions on instruments such as checks. Ensures number is nine digits long and has first two digits that comply with American Bankers Association rules.",
        "matches": [
            "614321634, 114000900, 703452098"
        ],
        "nonMatches": [
            "1145329, 491212012, banana"
        ],
        "pattern": "^((0[0-9])|(1[0-2])|(2[1-9])|(3[0-2])|(6[1-9])|(7[0-2])|80)([0-9]{7})$",
        "title": "Test"
    },
    {
        "description": "Checks date in format dd-mm-yyyy. Seperation characters can be -/. and space. dd and mm HAVE to be two characters. Year has to be four characters and minimum 1900. Expression handles leap year as well",
        "matches": [
            "20-02-1975",
            "20.02.1975",
            "20/02/1975",
            "20 02 1975",
            "20-12/1975"
        ],
        "nonMatches": [
            "20-12-1899",
            "29-02-2002",
            "28-2-2008"
        ],
        "pattern": "^(((0[1-9]|[12]\\d|3[01])[\\s\\.\\-\\/](0[13578]|1[02])[\\s\\.\\-\\/]((19|[2-9]\\d)\\d{2}))|((0[1-9]|[12]\\d|30)[\\s\\.\\-\\/](0[13456789]|1[012])[\\s\\.\\-\\/]((19|[2-9]\\d)\\d{2}))|((0[1-9]|1\\d|2[0-8])[\\s\\.\\-\\/]02[\\s\\.\\-\\/]((19|[2-9]\\d)\\d{2}))|(29[\\s\\.\\-\\/]02[\\s\\.\\-\\/]((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))$",
        "title": "Test"
    },
    {
        "description": "Strong password with the following requirements. - At least 8 characters long. - At least 1 uppercase, AND at least 1 lowercase - At least 1 digit OR at least 1 alphanumeric. - No spaces.",
        "matches": [
            "a3dAbed.",
            "P@ssword1",
            "aB_1bbbb",
            "myPassw0rd!"
        ],
        "nonMatches": [
            "password",
            "password12",
            "password__12",
            "p@ssw0rd"
        ],
        "pattern": "(?-i)(?=^.{8,}$)((?!.*\\s)(?=.*[A-Z])(?=.*[a-z]))(?=(1)(?=.*\\d)|.*[^A-Za-z0-9])^.*$",
        "title": "Test"
    },
    {
        "description": "This pattern matches US phone numbers but excludes numbers that are 800 or 900 numbers. It excludes the following area codes 800, 888,877,866, and 900.",
        "matches": [
            "123-554-1247, (455)521-5482"
        ],
        "nonMatches": [
            "800-585-1234, (866)958-4221"
        ],
        "pattern": "^(((?!\\(800\\))(?!\\(888\\))(?!\\(877\\))(?!\\(866\\))(?!\\(900\\))\\(\\d{3}\\) ?)|(?!800)(?!888)(?!877)(?!866)(?!900)(\\d{3}-))?\\d{3}-\\d{4}",
        "title": "Test"
    },
    {
        "description": "Mapea los nombres. Cualquier caracter, incluyendo la \u00F1 exeptuando los n\u00FAmeros.",
        "matches": [
            "Fernando",
            "Mart\u00EDnez",
            "Ni\u00F1o"
        ],
        "nonMatches": [
            "Luara123"
        ],
        "pattern": "[a-zA-Z \u00C1-\u00DA\u00E1-\u00FA][^1234567890]+$",
        "title": "Test"
    },
    {
        "description": "Check Dutch phonenumber including 0031 or +31 and optional - characters. I know it can be shortened, but for readability (and shortage of time ;-)) I kept it like it is...",
        "matches": [
            "0031612345678",
            "0031-6123456789",
            "0031-6-123456789",
            "0031-50-1234567",
            "0031-592-123456",
            "+31612345678",
            "0612345678",
            "06-12345678",
            "050-1234567",
            "0592-123456"
        ],
        "nonMatches": [
            "+31(0)612345678",
            "06123456789",
            "00310612345678",
            "0031-6-123-45678"
        ],
        "pattern": "^((((0031)|(\\+31))(\\-)?6(\\-)?[0-9]{8})|(06(\\-)?[0-9]{8})|(((0031)|(\\+31))(\\-)?[1-9]{1}(([0-9](\\-)?[0-9]{7})|([0-9]{2}(\\-)?[0-9]{6})))|([0]{1}[1-9]{1}(([0-9](\\-)?[0-9]{7})|([0-9]{2}(\\-)?[0-9]{6}))))$",
        "title": "Test"
    },
    {
        "description": "This will match fields in a row of a csv file. Values can be double quoted or not. If a value is double quoted it can have commas inside it. Each value will be captured to word.",
        "matches": [
            "\u0022test\u0022,\u0022test this\u0022,test, test,test ,\u0022123,456.12\u0022"
        ],
        "nonMatches": [
            "\u0027te, st\u0027"
        ],
        "pattern": "(\\\u0022(?\u003Cword\u003E[^\\\u0022]+|\\\u0022\\\u0022)*\\\u0022|(?\u003Cword\u003E[^,]*))",
        "title": "Test"
    },
    {
        "description": "An overly simple UNIX based path regex. The path must begin with a forward slash. The path segments may not lead or end with an underscore or dash which is a good thing. They also can not be doubled (__ or --). Another good thing. I\u0027ve omitted all the punctuation that RFC allows until further notice.",
        "matches": [
            "/users/web/mysite/web/cgi-bin"
        ],
        "nonMatches": [
            "/users/web/my site/web/cgi-bin",
            "users/web/mysite/web/cgi-bin/"
        ],
        "pattern": "^((?:\\/[a-zA-Z0-9]+(?:_[a-zA-Z0-9]+)*(?:\\-[a-zA-Z0-9]+)*)+)$",
        "title": "Test"
    },
    {
        "description": "This is a very basic regex for a simple subject or title. It must begin and end with a word character and may contain spaces. No punctuation :(",
        "matches": [
            "My Category"
        ],
        "nonMatches": [
            "any nonword character and leading/trailing spaces"
        ],
        "pattern": "^([a-zA-Z0-9]+(?: [a-zA-Z0-9]+)*)$",
        "title": "Test"
    },
    {
        "description": "This expression matches date and time (24 hour) both in format dd-MMM-yyyy HH:mm:ss. Only the short form of month is allowed i.e. Jan not January. The month names are also case sensitive. The second part of the time is optional. Also the leading zeros for day, hour, minute and seconds are optional.",
        "matches": [
            "31-Jan-2008 1:30:00",
            "29-Feb-2008 01:45:45",
            "30-Sep-2007 23:59"
        ],
        "nonMatches": [
            "31-Jan-2008 24:30:00",
            "29-Feb-2007 01:45:45",
            "3-Sep-2007 23:60:60"
        ],
        "pattern": "^((31(?!([-])(Feb|Apr|June?|Sep|Nov)))|((30|29)(?!([-])Feb))|(29(?=([-])Feb([-])(((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))|(0?[1-9])|1\\d|2[0-8])([-])(Jan|Feb|Ma(r|y)|Apr|Ju(l|n)|Aug|Oct|(Sep|Nov|Dec))([-])((1[6-9]|[2-9]\\d)\\d{2}\\s(([0-1]?[0-9])|([2][0-3])):([0-5]?[0-9])(:([0-5]?[0-9]))?)$",
        "title": "Test"
    },
    {
        "description": "Expression to match decimal number with 2 digits.",
        "matches": [
            "1.0, 1.1 .. 1.11 ... 99.0, 99.1, 99.2, ... 99.11"
        ],
        "nonMatches": [
            "0, 0.0. 0.11, 99.12, 1.12, 100, 100.11"
        ],
        "pattern": "^([1-9]([0-9])?)(\\.(([0])?|([1-9])?|[1]([0-1])?)?)?$",
        "title": "Test"
    },
    {
        "description": "Can be used to pre-validate strings before calling the TimeSpan.Parse() method in the .Net framework, to ensure that the string can be parsed without throwing an exception. The regex uses capturing groups instead of non-capturing groups so that it can easily be used as a pattern in XML Schema by simply removing the ^$ from the beginning/end. This expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help. It even checks the upper/lower boundaries on day values (10675199 days.)",
        "matches": [
            "00:00:15",
            "23:59:59",
            "23:59:59.9999999",
            "-00:00:00",
            "365",
            "-365",
            "7.00:00:00.0000000",
            "5:5:5",
            "10:10",
            "21:15",
            "19:1",
            "00:10",
            "0",
            "10675199.23:59:59.9999999",
            "-10675199.23:59:59.9999999",
            "10599999",
            "10669999",
            "10674999",
            "10675099"
        ],
        "nonMatches": [
            "1.23:59:60",
            "24:00",
            "23:59:59.00000000",
            "00:00:60",
            "24:00:00",
            "25:00:00",
            "10675200",
            "10676000",
            "10680000",
            "10700000",
            "11000000"
        ],
        "pattern": "^\\s*-?(\\d{0,7}|10[0-5]\\d{0,5}|106[0-6]\\d{0,4}|1067[0-4]\\d{0,3}|10675[0-1]\\d{0,2}|((\\d{0,7}|10[0-5]\\d{0,5}|106[0-6]\\d{0,4}|1067[0-4]\\d{0,3}|10675[0-1]\\d{0,2})\\.)?([0-1]?[0-9]|2[0-3]):[0-5]?[0-9](:[0-5]?[0-9](\\.\\d{1,7})?)?)\\s*$",
        "title": "Test"
    },
    {
        "description": "This is my simple phone number regex. There are many like it but this is mine. It accepts the most common United States phone number formats that normal people use. The number 1 at the beginning is optional and so is the separators. The separators can be a dash (-), a period (.) or a space. Putting the area code in parenthesis is also an option. That\u0027s about it.",
        "matches": [
            "1-234-567-8910",
            "(123) 456-7891",
            "123.456.7891",
            "12345678910"
        ],
        "nonMatches": [
            "12-345-678-9101",
            "123-45678",
            "123456789101"
        ],
        "pattern": "^(1?(?: |\\-|\\.)?(?:\\(\\d{3}\\)|\\d{3})(?: |\\-|\\.)?\\d{3}(?: |\\-|\\.)?\\d{4})$",
        "title": "Test"
    },
    {
        "description": "Just for US zip codes. Very simple but effective regex for verifying a number that resembles a zip code. The post office number is optional.",
        "matches": [
            "12345",
            "12345-6789"
        ],
        "nonMatches": [
            "1234",
            "123456",
            "12345-123",
            "12345-12345"
        ],
        "pattern": "^(\\d{5}(?:\\-\\d{4})?)$",
        "title": "Test"
    },
    {
        "description": "Updated SSN regex. A very simple one for verifying a properly formatted US social security number. First three digits must be 001 - 899 and not 666. Disallows all zeros in a group.",
        "matches": [
            "123-45-6789"
        ],
        "nonMatches": [
            "123-45 6789",
            "1234-56-7890",
            "123-00-7890"
        ],
        "pattern": "^(?!000)(?!666)(?!9)\\d{3}([- ]?)(?!00)\\d{2}\\1(?!0000)\\d{4}$",
        "title": "Test"
    },
    {
        "description": "This is a regular expression to check for a properly formatted date according to the international date and time notation ISO 8601. Remember, this is just for the date. See ISO 8601 specification for more information.",
        "matches": [
            "ISO 8601 date format"
        ],
        "nonMatches": [
            "non-ISO date format"
        ],
        "pattern": "^(\\d{4}(?:(?:(?:\\-)?(?:00[1-9]|0[1-9][0-9]|[1-2][0-9][0-9]|3[0-5][0-9]|36[0-6]))?|(?:(?:\\-)?(?:1[0-2]|0[1-9]))?|(?:(?:\\-)?(?:1[0-2]|0[1-9])(?:\\-)?(?:0[1-9]|[12][0-9]|3[01]))?|(?:(?:\\-)?W(?:0[1-9]|[1-4][0-9]5[0-3]))?|(?:(?:\\-)?W(?:0[1-9]|[1-4][0-9]5[0-3])(?:\\-)?[1-7])?)?)$",
        "title": "Test"
    },
    {
        "description": "This is a regular expression to check for a properly formatted time according to the international date and time notation ISO 8601. See ISO 8601 specification for more information.",
        "matches": [
            "24",
            "24:00",
            "23:59:59",
            "235959"
        ],
        "nonMatches": [
            "25",
            "24:60"
        ],
        "pattern": "^([0-2][0-4](?:(?:(?::)?[0-5][0-9])?|(?:(?::)?[0-5][0-9](?::)?[0-5][0-9](?:\\.[0-9]+)?)?)?)$",
        "title": "Test"
    },
    {
        "description": "Accepts all integers between 0-100",
        "matches": [
            "0",
            "00",
            "01",
            "45",
            "99",
            "100"
        ],
        "nonMatches": [
            "-1",
            ".23",
            "101"
        ],
        "pattern": "^0?[0-9]?[0-9]$|^(100)$",
        "title": "Test"
    },
    {
        "description": "This is a little goofy regex to allow punctuation. I was reluctant to post it but what the heck. If it puts a smile on somebody\u0027s face then it was worth it. It works in most cases. :)",
        "matches": [
            "\u0022hello!\u0022",
            "\u0022hello again\u0022!",
            "I\u0027m back"
        ],
        "nonMatches": [
            "hello\u0022",
            "\u0022hello again!\u0022!",
            "I\u0027mnot back"
        ],
        "pattern": "^((\\\u0027|\\\u0022)?[a-zA-Z]+(?:\\-[a-zA-Z]+)?(?:s\\\u0027|\\\u0027[a-zA-Z]{1,2})?(?:(?:(?:\\,|\\.|\\!|\\?)?(?:\\2)?)|(?:(?:\\2)?(?:\\,|\\.|\\!|\\?)?))(?: (\\\u0027|\\\u0022)?[a-zA-Z]+(?:\\-[a-zA-Z]+)?(?:s\\\u0027|\\\u0027[a-zA-Z]{1,2})?(?:(?:(?:\\,|\\.|\\!|\\?)?(?:\\2|\\3)?)|(?:(?:\\2|\\3)?(?:\\,|\\.|\\!|\\?)?)))*)$",
        "title": "Test"
    },
    {
        "description": "A simple regex to validate an embedded YouTube video.",
        "matches": [
            "a valid embedded YouTube video"
        ],
        "nonMatches": [
            "anything else"
        ],
        "pattern": "(\\\u0022http:\\/\\/www\\.youtube\\.com\\/v\\/\\w{11}\\\u0026rel\\=1\\\u0022)",
        "title": "Test"
    },
    {
        "description": "A simple regex for validating an embedded Google video.",
        "matches": [
            "an embedded Google video"
        ],
        "nonMatches": [
            "anything else"
        ],
        "pattern": "(\\\u0022http:\\/\\/video\\.google\\.com\\/googleplayer\\.swf\\?docId=\\d{19}\\\u0026hl=[a-z]{2}\\\u0022)",
        "title": "Test"
    },
    {
        "description": "My simple but effective password regex. The password can only contain letters and/or digits and must be at least 6 characters long and no more than 20. I know it says {6,18} but it just works out that way. The question mark was added for optimization. Also, the password can not begin or end with a space or underscore.",
        "matches": [
            "abc123"
        ],
        "nonMatches": [
            "_abc123_"
        ],
        "pattern": "^([a-zA-Z0-9]{6,18}?)$",
        "title": "Test"
    },
    {
        "description": "Here\u0027s a regex for a person\u0027s name. Simple but effective.",
        "matches": [
            "Mr. O\u0027Donnell III",
            "Billy B. Bob Jr."
        ],
        "nonMatches": [
            "@$%\u0026?",
            "0\u0027Donnell"
        ],
        "pattern": "^([a-zA-Z]+(?:\\.)?(?:(?:\u0027| )[a-zA-Z]+(?:\\.)?)*)$",
        "title": "Test"
    },
    {
        "description": "Here\u0027s another one for numbers. Any kind of number. Money $$$, percentage %, ect. Commas are optional and must be properly formatted.",
        "matches": [
            "$1,000,000.00",
            "100%",
            "12345.67890"
        ],
        "nonMatches": [
            "$$10.00",
            "10%%",
            "1234,5678,",
            "123.456.789"
        ],
        "pattern": "^((?:\\+|\\-|\\$)?(?:\\d+|\\d{1,3}(?:\\,\\d{3})*)(?:\\.\\d+)?(?:[a-zA-Z]{2}|\\%)?)$",
        "title": "Test"
    },
    {
        "description": "A URL to a domain name. Only for HTTP but that can be easily changed to accept more. The dashes and underscores can only be used between text and/or digits. The slash on the end is optional. Unlike my other URL checkers this one does not allow query strings.",
        "matches": [
            "http://www.website.com/",
            "http://my-website.net",
            "http://another_site.org"
        ],
        "nonMatches": [
            "www.website.com",
            "http://_website.com",
            "http://www. web--site.com"
        ],
        "pattern": "^(http\\:\\/\\/(?:www\\.)?[a-zA-Z0-9]+(?:(?:\\-|_)[a-zA-Z0-9]+)*(?:\\.[a-zA-Z0-9]+(?:(?:\\-|_)[a-zA-Z0-9]+)*)*\\.[a-zA-Z]{2,7}(?:\\/)?)$",
        "title": "Test"
    },
    {
        "description": "Valiadation IP RegExp.",
        "matches": [
            "192.168.1.92",
            "172.16.4.0",
            "255.255.255.255"
        ],
        "nonMatches": [
            "1923.0.1.2",
            "256.1.1.2"
        ],
        "pattern": "^(?:(?:1\\d{0,2}|[3-9]\\d?|2(?:[0-5]{1,2}|\\d)?|0)\\.){3}(?:1\\d{0,2}|[3-9]\\d?|2(?:[0-5]{1,2}|\\d)?|0)$",
        "title": "Test"
    },
    {
        "description": "This pattern was based on this reference: http://www.remote.org/jochen/mail/info/chars.html This expression allows only these symbols (+, -, _, or .) in the local part of the address, but no two consecutive symbols are allowed. The symbols behave like separators for alphanumeric atoms. The local part must begin and end with an atom. Therefore, local part cannot begin or end with a symbol. For the domain name, I tested what was allowed at various domain registrars. While hyphens are allowed, domain names must abide by the following rules: -can\u0027t begin or end with hyphen -no more than two hyphens can appear consecutively",
        "matches": [
            "abc@test.com",
            "abc@test-test.info",
            "abc.d-e_f+g@a.b-c.d--e.museum"
        ],
        "nonMatches": [
            "a+@test.com",
            "+a@test.com",
            "a++a@test.com",
            "abc@a---b.com",
            "abc@a---b.test.com"
        ],
        "pattern": "^([a-zA-Z0-9]+([\\.+_-][a-zA-Z0-9]+)*)@(([a-zA-Z0-9]+((\\.|[-]{1,2})[a-zA-Z0-9]+)*)\\.[a-zA-Z]{2,6})$",
        "title": "Test"
    },
    {
        "description": "This regular expression is used to validate only comma separated numbers.",
        "matches": [
            "100,200,300"
        ],
        "nonMatches": [
            "100,200,"
        ],
        "pattern": "^([0-9]*)+(,[0-9]+)+$",
        "title": "Test"
    },
    {
        "description": "Integer with comma and dot",
        "matches": [
            "1,200.00 / 1200.00 / 1200"
        ],
        "nonMatches": [
            "1,20.00 / 23,8888 / 120.812"
        ],
        "pattern": "^[-+]?(\\d?\\d?\\d?,?)?(\\d{3}\\,?)*(\\.\\d{1,2})?$",
        "title": "Test"
    },
    {
        "description": "Regular expression that accepts positive numbers with or with decimal places, but will not allow zero or 0.000",
        "matches": [
            "1",
            "25",
            "25.0",
            "25.001",
            "0.001",
            "0.234"
        ],
        "nonMatches": [
            "0",
            "0.0",
            "-12"
        ],
        "pattern": "^(([1-9]{1}(\\d+)?)(\\.\\d+)?)|([0]\\.(\\d+)?([1-9]{1})(\\d+)?)$",
        "title": "Test"
    },
    {
        "description": "This accepts RFC 2822 email addresses in the form:\u003Cbr\u003Eblah@blah.com OR\u003Cbr\u003E Blah <blah@blah.com>\u003Cbr\u003E\u003Cbr\u003E RFC 2822 email \u0027mailbox\u0027:\u003Cbr\u003E mailbox = name-addr | addr-spec\u003Cbr\u003E name-addr = [display-name] \u0022\u003C\u0022 addr-spec \u0022\u003E\u0022\u003Cbr\u003E addr-spec = local-part \u0022@\u0022 domain\u003Cbr\u003E",
        "matches": [
            "name.surname@blah.com",
            "Name Surname \u003Cname.surname@blah.com\u003E",
            "\u0022b. blah\u0022@blah.co.nz"
        ],
        "nonMatches": [
            "name surname@blah.com",
            "name.\u0022surname\u0022@blah.com",
            "name@bla-.com"
        ],
        "pattern": "^((?\u003E[a-zA-Z\\d!#$%\u0026\u0027*+\\-/=?^_\u0060{|}~]+\\x20*|\u0022((?=[\\x01-\\x7f])[^\u0022\\\\]|\\\\[\\x01-\\x7f])*\u0022\\x20*)*(?\u003Cangle\u003E\u003C))?((?!\\.)(?\u003E\\.?[a-zA-Z\\d!#$%\u0026\u0027*+\\-/=?^_\u0060{|}~]+)+|\u0022((?=[\\x01-\\x7f])[^\u0022\\\\]|\\\\[\\x01-\\x7f])*\u0022)@(((?!-)[a-zA-Z\\d\\-]+(?\u003C!-)\\.)+[a-zA-Z]{2,}|\\[(((?(?\u003C!\\[)\\.)(25[0-5]|2[0-4]\\d|[01]?\\d?\\d)){4}|[a-zA-Z\\d\\-]*[a-zA-Z\\d]:((?=[\\x01-\\x7f])[^\\\\\\[\\]]|\\\\[\\x01-\\x7f])+)\\])(?(angle)\u003E)$",
        "title": "Test"
    },
    {
        "description": "This regex searches multi-line, single-line, and XML comments present in C# file.",
        "matches": [
            "/* multi-line */",
            "// comment",
            "/// XML Comment"
        ],
        "nonMatches": [
            "/* multi-line /*"
        ],
        "pattern": "(/\\*[\\d\\D]*?\\*/)|(\\/\\*(\\s*|.*?)*\\*\\/)|(\\/\\/.*)|(/\\\\*[\\\\d\\\\D]*?\\\\*/)|([\\r\\n ]*//[^\\r\\n]*)+",
        "title": "Test"
    },
    {
        "description": "I was looking for a date format that allowed 1 or 2 digit Month and Days and 2 digit years. I found and tweak this one based off Cliff Schneide Date example.",
        "matches": [
            "03-25-08",
            "3-25-08",
            "3-1-08"
        ],
        "nonMatches": [
            "03-25-2008",
            "3-25-2008",
            "3/25/2008"
        ],
        "pattern": "^((((0?[13578])|(1[02]))[\\-]?((0?[1-9]|[0-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-]?((0?[1-9]|[0-2][0-9])|(30)))|(0?[2][\\-]?(0?[1-9]|[0-2][0-9])))[\\-]?\\d{2}$",
        "title": "Test"
    },
    {
        "description": "Finds title, first name, middle initial, last name, and suffix of a name. Middle names are added to first name. Uses .Net capture group names.",
        "matches": [
            "Mary, Mary White, Mary Jo White, Dr. Mary Jo White, Dr. Mary Jo T. White, Ph.D."
        ],
        "nonMatches": [
            "Mary Jo Thomas White"
        ],
        "pattern": "^(?\u003Ctitle\u003E.*\\.\\s)*(?\u003Cfirstname\u003E([A-Z][a-z]+\\s*)+)(\\s)(?\u003Cmiddleinitial\u003E([A-Z]\\.?\\s)*)(?\u003Clastname\u003E[A-Z][a-zA-Z-\u0027]+)(?\u003Csuffix\u003E.*)$",
        "title": "Test"
    },
    {
        "description": "Filters out VB.NET and VB6.0 comments.",
        "matches": [
            "REM comment",
            "\u0027comment",
            "\u0027\u0027\u0027 XML comment"
        ],
        "nonMatches": [
            "REMA",
            "text=\u0027test\u0027"
        ],
        "pattern": "(REM [\\d\\D]*?[\\r\\n])|(?\u003CSL\u003E\\\u0027[\\d\\D]*?[\\r\\n])",
        "title": "Test"
    },
    {
        "description": "Zip code validation for Switzerland. Forces 4-digits only zipcode starting at 1000",
        "matches": [
            "1000",
            "1200",
            "8200",
            "8048",
            "9999"
        ],
        "nonMatches": [
            "a-z",
            "aaaa",
            "123",
            "0000"
        ],
        "pattern": "^[1-9][0-9][0-9][0-9]$",
        "title": "Test"
    },
    {
        "description": "Validates a strong password. It must be between 8 and 10 characters, contain at least one digit and one alphabetic character, and must not contain special characters",
        "matches": [
            "test1test"
        ],
        "nonMatches": [
            "testtest"
        ],
        "pattern": "(?!^[0-9]*$)(?!^[a-zA-Z]*$)^([a-zA-Z0-9]{8,10})$",
        "title": "Test"
    },
    {
        "description": "Validated date in the following format: MM/DD/YY from 1900 to 2999",
        "matches": [
            "01/12/2009",
            "12/09/1999",
            "10/21/2008"
        ],
        "nonMatches": [
            "1/10/1800",
            "11/3/2006",
            "05/32/2010"
        ],
        "pattern": "((0[1-9])|(1[0-2]))\\/((0[1-9])|(1[0-9])|(2[0-9])|(3[0-1]))/\\(([1][9][0-9][0-9])|([2][0-9][0-9][0-9])))",
        "title": "Test"
    },
    {
        "description": "matches US states and territories in 2 character UPPER case. Reduced from Jason Gaylord\u0027s http://regexlib.com/REDetails.aspx?regexp_id=396",
        "matches": [
            "AZ NY"
        ],
        "nonMatches": [
            "Ax Arizona"
        ],
        "pattern": "^((A[LKSZR])|(C[AOT])|(D[EC])|(F[ML])|(G[AU])|(HI)|(I[DLNA])|(K[SY])|(LA)|(M[EHDAINSOT])|(N[EVHJMYCD])|(MP)|(O[HKR])|(P[WAR])|(RI)|(S[CD])|(T[NX])|(UT)|(V[TIA])|(W[AVIY]))$",
        "title": "Test"
    },
    {
        "description": "Tokenize a Javascript document for parsing each token is a language-token : string, int, float, comment, multiline comment, operator, expression etc. etc.",
        "matches": [
            "var a = 12.5 * 5 + 3e9;var b = \u0022str\u0027\\\u0022ing\u0022;var c = \u0027str\u0022\\\u0027ing\u0027;var d = /regex/gi;var e = Func();"
        ],
        "nonMatches": [
            "spaces/newline/tab"
        ],
        "pattern": "(\\/\\*[\\s\\S.]+?\\*\\/|[/]{2,}.*|\\/((\\\\\\/)|.??)*\\/[gim]{0,3}|\u0027((\\\\\\\u0027)|.??)*\u0027|\u0022((\\\\\\\u0022)|.??)*\u0022|-?\\d+\\.\\d+e?-?e?\\d*|-?\\.\\d+e-?\\d+|\\w+|[\\[\\]\\(\\)\\{\\}:=;\u0022\u0027\\-\u0026!|+,.\\/*])",
        "title": "Test"
    },
    {
        "description": "First word and second word should be a single space",
        "matches": [
            "ABC Infotech Pvt Ltd"
        ],
        "nonMatches": [
            "ABC Infotech Pvt Ltd"
        ],
        "pattern": "^[\\w\\s]+$ ^[[A-Z]\\s]$",
        "title": "Test"
    },
    {
        "description": "This phone pattern matches all New Zealand phone numbers with formatting and returns a single formatted string as the first return in the array. Does not take into account all specific exclusions, though, in case of changes (like 025 to 027 in 2007). Based off of CGRdevelopment\u0027s New Zealand regex.",
        "matches": [
            "6402123456",
            "+64.800.12345678",
            "(03) 123 4567",
            "021123456",
            "027-123-456",
            "+64-027-123-123"
        ],
        "nonMatches": [
            "02.123.4567",
            "+64031234567",
            "64.024.123.4567",
            "800.123456"
        ],
        "pattern": "^(((\\+?64\\s*[-\\.]?[3-9]|\\(?0[3-9]\\)?)\\s*[-\\.]?\\d{3}\\s*[-\\.]?\\d{4})|((\\+?64\\s*[-\\.\\(]?2\\d{1}[-\\.\\)]?|\\(?02\\d{1}\\)?)\\s*[-\\.]?\\d{3}\\s*[-\\.]?\\d{3,5})|((\\+?64\\s*[-\\.]?[-\\.\\(]?800[-\\.\\)]?|[-\\.\\(]?0800[-\\.\\)]?)\\s*[-\\.]?\\d{3}\\s*[-\\.]?(\\d{2}|\\d{5})))$",
        "title": "Test"
    },
    {
        "description": "Use this expression to check that a valid web address is used without any protocol.",
        "matches": [
            "www.myurl.com",
            "myurl.com/default.aspx?i=id",
            "www3.myurl.com/?a"
        ],
        "nonMatches": [
            "www.my url.com",
            "myurl.com/default.aspx?i=1 2 3",
            "www3.myurl.com?a",
            "http://myurl.com"
        ],
        "pattern": "^([\\w-]+\\.)+[\\w-]+(/[\\w-./?%\u0026=]*)?$",
        "title": "Test"
    },
    {
        "description": "Password must have at least 8 characters with at least one Capital letter, at least one lower case letter and at least one number or special character.",
        "matches": [
            "Spring08",
            "spR1ng14",
            "~Spring%"
        ],
        "nonMatches": [
            "spring",
            "SpringSp",
            "12345678"
        ],
        "pattern": "(?-i)(?=^.{8,}$)((?!.*\\s)(?=.*[A-Z])(?=.*[a-z]))((?=(.*\\d){1,})|(?=(.*\\W){1,}))^.*$",
        "title": "Test"
    },
    {
        "description": "match ip address from 1.0.0.0 to 223.255.255.255",
        "matches": [
            "192.168.0.1",
            "223.255.255.255",
            "9.0.0.0"
        ],
        "nonMatches": [
            "0.10.2.52",
            "255.255.255.255",
            "127.0.257.1"
        ],
        "pattern": "^((([1]\\d{2})|(22[0-3])|([1-9]\\d)|(2[01]\\d)|[1-9]).(([1]\\d{2})|(2[0-4]\\d)|(25[0-5])|([1-9]\\d)|\\d).(([1]\\d{2})|(2[0-4]\\d)|(25[0-5])|([1-9]\\d)|\\d).(([1]\\d{2})|(2[0-4]\\d)|(25[0-5])|([1-9]\\d)|\\d))$",
        "title": "Test"
    },
    {
        "description": "This is the USA Date Format. MM/DD/YYYY with checking leaf year",
        "matches": [
            "05/15/2008,02/29/2008"
        ],
        "nonMatches": [
            "05-12-2008,02/29/2007"
        ],
        "pattern": "(((0[13578]|10|12)([/])(0[1-9]|[12][0-9]|3[01])([/])([1-2][0,9][0-9][0-9]))|((0[469]|11)([/])([0][1-9]|[12][0-9]|30)([/])([1-2][0,9][0-9][0-9]))|((02)([/])(0[1-9]|1[0-9]|2[0-8])([/])([1-2][0,9][0-9][0-9]))|((02)([/])(29)(\\.|-|\\/)([02468][048]00))|((02)([/])(29)([/])([13579][26]00))|((02)([/])(29)([/])([0-9][0-9][0][48]))|((02)([/])(29)([/])([0-9][0-9][2468][048]))|((02)([/])(29)([/])([0-9][0-9][13579][26])))",
        "title": "Test"
    },
    {
        "description": "Requires a person\u0027s name including at least 2 parts. (first and last) Allows optional extra names. It allows plenty of initials as well as symbols in names. Restricts symbol usage quite a bit, but allows even names with 2 symbols. Requires last name to have at least 2 characters and cannot be an initial. Works well for filtering names on validation.",
        "matches": [
            "E.J. O\u0027Malley",
            "Jack O\u0027Neil",
            "Mary-Lou Elizabeth Jones"
        ],
        "nonMatches": [
            "Johnathan Michael S.",
            "Prince",
            "Teddy Has-a..Fake-Name"
        ],
        "pattern": "^([a-zA-Z]+[\\\u0027\\,\\.\\-]?[a-zA-Z ]*)+[ ]([a-zA-Z]+[\\\u0027\\,\\.\\-]?[a-zA-Z ]+)+$",
        "title": "Test"
    },
    {
        "description": "This checks whether the string is equals to \u0022*\u0022 i.e., contains only \u0022*(Asterisk)\u0022 or begins with Asterisk.",
        "matches": [
            "*, *Asdf"
        ],
        "nonMatches": [
            "a*, asdf"
        ],
        "pattern": "^[:*:]",
        "title": "Test"
    },
    {
        "description": "With this regex you can find or replace any CSS commentary in your stylesheets in once. Build for use with dreamweaver. Probably works also fine in any other circumstances.",
        "matches": [
            "/* Commentary */",
            "/* CSS */",
            "/* text:padding */"
        ],
        "nonMatches": [
            "/* CSS;* :: / */",
            "/ no comment /",
            "*comment*"
        ],
        "pattern": "/\\*[^\\/]+/",
        "title": "Test"
    },
    {
        "description": "\u003E=0 \u0026\u003C100????",
        "matches": [
            "0,56,99"
        ],
        "nonMatches": [
            "-1,01,100"
        ],
        "pattern": "^[0-9]$|[1-9]+[0-9]$",
        "title": "Test"
    },
    {
        "description": "Matches URI\u0027s! \u0022filename.ext\u0022 is part of path. ER can\u0027t differ file name from directory name. only domain is required. scheme://usern:passw@domain:port/path/file.ext?querystring#fragment",
        "matches": [
            "domain",
            "ftp://localhost:21/",
            "192.168.254.0",
            "http://username:password@www.domain.com:1234/path1/pathX/filename.ext?query=string\u0026example=v1#fragment"
        ],
        "nonMatches": [
            "non-alpha://domain",
            "domain:non-number"
        ],
        "pattern": "^(?:(?\u003Cscheme\u003E[a-z]+):\\/\\/)?(?:(?\u003Cusern\u003E[a-z0-9_.]*)(?::(?\u003Cpassw\u003E[a-z0-9_.]*))?@)?(?\u003Cdomain\u003E(?:(?:[a-z][a-z0-9_-]+\\.?)+|[0-9]{1,3}(?:\\.[0-9]{1,3}){3}))(?::(?\u003Cport\u003E[0-9]+))?(?\u003Cpath\u003E(?:\\/[.%a-z0-9_]*)+)?(?:\\?(?\u003Cquery\u003E(?:\u0026?[][a-z0-9_]+(?:\\=?[a-z0-9_;]*)?)+))?(?:#(?\u003Cfragment\u003E[a-z0-9_]+))?$",
        "title": "Test"
    },
    {
        "description": "ukrainian phone numbers in Kiev",
        "matches": [
            "+38-044-283-93-57; (044)2839357; +380442839357; +38 (044)537-28-07; 8044223-95-26;"
        ],
        "nonMatches": [
            "+380612839357"
        ],
        "pattern": "^((8|\\+38)-?)?(\\(?044\\)?)?-?\\d{3}-?\\d{2}-?\\d{2}$",
        "title": "Test"
    },
    {
        "description": "Optional Amount, with optional thousands seperator (using the point) and optional decimal comma. If decimal comma is in string, then 2 trailing digits are required. Also checks for the optional euro sign",
        "matches": [
            "1",
            "1,00",
            "1.000,00",
            "\u20AC1"
        ],
        "nonMatches": [
            "1a",
            ".00,00",
            "1,0",
            "$1"
        ],
        "pattern": "^([\\u20AC]?[1-9]\\d*\\.\\d{3}(?:,\\d{2})?|[\\u20AC]?[1-9]\\d*(?:,\\d{2})?|[\\u20AC]?[1-9]\\d*)$",
        "title": "Test"
    },
    {
        "description": "Modified version of Chris Myers\u0027 regexp for po boxes. This one won\u0027t match the word \u0022box\u0022 in the address. Only matches if there is a number following the po box. Also accepts a # in front of the number and other spelling variations.",
        "matches": [
            "po box 123, p.o.b. #123, box 123"
        ],
        "nonMatches": [
            "123 box canyon rd"
        ],
        "pattern": "\\b[P|p]?(OST|ost)?\\.?\\s*[O|o|0]?(ffice|FFICE)?\\.?\\s*[B|b][O|o|0]?[X|x]?\\.?\\s+[#]?(\\d+)\\b",
        "title": "Test"
    },
    {
        "description": "Checks to make sure that entry starts with http:// or https:// and that contents are limited to alphas . - /",
        "matches": [
            "http://www.google.com https://www.google.com http://localhost/"
        ],
        "nonMatches": [
            "www.google.com"
        ],
        "pattern": "http[s]?://[a-zA-Z0-9.-/]+",
        "title": "Test"
    },
    {
        "description": "This Regex is usefull to validate if the text typed will still lead to a valid number for a international input. Replace , with \\. to get an american notation",
        "matches": [
            "6,32 -409,00 -,0 -, ,05 +, +,0198 +, ,"
        ],
        "nonMatches": [
            "8- 23+ 12.1 .01 0.0"
        ],
        "pattern": "[+-]*[0-9]+[,]*[0-9]*|[+-]*[0-9]*[,]+[0-9]*",
        "title": "Test"
    },
    {
        "description": "Match any number , no characters, no empty sets, and accept zero.",
        "matches": [
            "0001",
            "12345",
            ""
        ],
        "nonMatches": [
            "abcd",
            "012a"
        ],
        "pattern": "^([0-9]{1}[\\d]{0,2}(\\,[\\d]{3})*(\\,[\\d]{0,2})?|[0-9]{1}[\\d]{0,}(\\,[\\d]{0,2})?|0(\\,[\\d]{0,2})?|(\\,[\\d]{1,2})?)$",
        "title": "Test"
    },
    {
        "description": "This regex matches all valid, current UK Postcodes, including Girobank and non-geographic postcodes, irrespective of whether they contain a space. It does not include overseas territories. Adapted from the BS7666 postcode rules at: http://www.cabinetoffice.gov.uk/govtalk/schemasstandards/e-gif/datastandards/address/postcode.aspx",
        "matches": [
            "M1 1AA",
            "M60 1NW",
            "CR2 6XH",
            "DN55 1PT",
            "W1A 1HQ",
            "EC1A 1BB",
            "GIR 0AA"
        ],
        "nonMatches": [
            "Q1 1AA",
            "M60 1CW",
            "5R2 6XH",
            "DJ55 1PT",
            "W1M 1HQ",
            "EC1D 1BB",
            "GIR 1AA"
        ],
        "pattern": "^(GIR ?0AA|(?:[A-PR-UWYZ](?:\\d|\\d{2}|[A-HK-Y]\\d|[A-HK-Y]\\d\\d|\\d[A-HJKSTUW]|[A-HK-Y]\\d[ABEHMNPRV-Y])) ?\\d[ABD-HJLNP-UW-Z]{2})$",
        "title": "Test"
    },
    {
        "description": "Matches any number which includes the US currency symbol ($), a negative sign (-), comma separators, and a decimal. It matches an unlimited number of decimal places. It does NOT reject an empty string passed to it. Credit goes to Al Kahler for posting the original expression from http://regxlib.com/REDetails.aspx?regexp_id=70 along with a fix for the decimal place.",
        "matches": [
            "$.01",
            "1,234.003",
            "834223.1",
            "$0.01",
            "-$1.50",
            "$-50.123"
        ],
        "nonMatches": [
            ".0,001",
            "1,1.01",
            "1E",
            "5$"
        ],
        "pattern": "^((\\$?\\-?)|(\\-?\\$?))([0-9]{1,3},([0-9]{3},)*[0-9]{3}|[0-9]+)?(\\.[0-9]*)?$",
        "title": "Test"
    },
    {
        "description": "This expression matches ICD-10 code",
        "matches": [
            "Z99.9",
            "Z99"
        ],
        "nonMatches": [
            "Z999",
            "Z99.",
            "99"
        ],
        "pattern": "^[A-Z]\\d{2}(\\.\\d){0,1}$",
        "title": "Test"
    },
    {
        "description": "This regular expression can be used to validate a strong password. It will evaluate to true if the following critera are met: Must be 8 characters in length total. Must contain at least 1 digit. Must contain at least 1 lower case letter. Must contain at least 1 upper case letter. Must contain at least 1 non-character (such as !,#,%,@, etc). Must not contain the words \u0022password\u0022 or \u0022pass\u0022 or \u0022word\u0022 or \u0022god\u0022 Must not contain a whitespace. Note: This version is not compatible with JavaScript",
        "matches": [
            "one2!fouR, @Eight21, one22Four%, 2thRee@four, 7diPity*, 12345aB("
        ],
        "nonMatches": [
            "one2three!, four2345, #viced@#$, short1@"
        ],
        "pattern": "^(?=^.{8,}$)(?=.*\\d)(?=.*\\W+)(?=.*[a-z])(?=.*[A-Z])(?i-msnx:(?!.*pass|.*password|.*word|.*god|.*\\s))(?!^.*\\n).*$",
        "title": "Test"
    },
    {
        "description": "This expression was written for C#, and as such you should just be able to drop it in. It matches Windows paths, be they the drive letter version or the UNC version. It was not written to specifically match filenames, but it will in most cases anyway. Be aware that Windows has a maximum path+filename length (260 chars on XP) and this regular expression does not check for this. This has been tested against large datasets.",
        "matches": [
            "C:\\Program Files\\Test, \\\\server\\share\\directory"
        ],
        "nonMatches": [
            "c:?Program Files\\Lab, \\\\$erver\\sh*re\\directory, a:\\di:::r"
        ],
        "pattern": "^((\\\\\\\\[a-zA-Z0-9-]+\\\\[a-zA-Z0-9\u0060~!@#$%^\u0026(){}\u0027._-]+([ ]+[a-zA-Z0-9\u0060~!@#$%^\u0026(){}\u0027._-]+)*)|([a-zA-Z]:))(\\\\[^ \\\\/:*?\u0022\u0022\u003C\u003E|]+([ ]+[^ \\\\/:*?\u0022\u0022\u003C\u003E|]+)*)*\\\\?$",
        "title": "Test"
    },
    {
        "description": "This RE locates and/or validates standard Bible verse notation.",
        "matches": [
            "Leviticus 3:3-4",
            "II Ki. 2:11; 3:12-22, 25",
            "2Cor 3:16; Rom. 12:1-5,7,9"
        ],
        "nonMatches": [
            "Lev chap 3 vv3-4",
            "2nd Kings 2:11",
            "Romans 12"
        ],
        "pattern": "(?:(?:[123]|I{1,3})\\s*)?(?:[A-Z][a-zA-Z]+|Song of Songs|Song of Solomon).?\\s*(?:1?[0-9]?[0-9]):\\s*\\d{1,3}(?:[,-]\\s*\\d{1,3})*(?:;\\s*(?:(?:[123]|I{1,3})\\s*)?(?:[A-Z][a-zA-Z]+|Song of Songs|Song of Solomon)?.?\\s*(?:1?[0-9]?[0-9]):\\s*\\d{1,3}(?:[,-]\\s*\\d{1,3})*)*",
        "title": "Test"
    },
    {
        "description": "This regex will match all HTML tags except \u0027a\u0027 tags or \u0027img\u0027 tags. You can edit the list of exclusions as you see fit. I use this regex to strip all HTML tags from source data except anchor tags and image tags.",
        "matches": [
            "\u003Cscript\u003E\u003C/html\u003E\u003Canytag\u003E"
        ],
        "nonMatches": [
            "\u003Ca\u003E\u003Cimg /\u003E\u003C/a\u003E"
        ],
        "pattern": "\u003C\\/*?(?![^\u003E]*?\\b(?:a|img)\\b)[^\u003E]*?\u003E",
        "title": "Test"
    },
    {
        "description": "This regular expression will match only \u003Cscript\u003E and \u003Cstyle\u003E tags and all content between them. Use this with regex.replace to strip script blocks and style blocks from HTML source.",
        "matches": [
            "\u003Cscript\u003Etest\u003C/script\u003E, \u003Cstyle\u003Etest\u003Cstyle\u003E"
        ],
        "nonMatches": [
            "-all other html code is ignored-"
        ],
        "pattern": "\u003C(script|style)[^\u003E]*?\u003E(?:.|\\n)*?\u003C/\\s*\\1\\s*\u003E",
        "title": "Test"
    },
    {
        "description": "This will accept SSN in the form of 123-45-6789 OR 123456789.",
        "matches": [
            "123-45-6789",
            "123456789",
            "456-63-6666"
        ],
        "nonMatches": [
            "123-45-459a",
            "222-2-2222",
            "222-222222"
        ],
        "pattern": "^(\\d{3}-\\d{2}-\\d{4})|(\\d{3}\\d{2}\\d{4})$",
        "title": "Test"
    },
    {
        "description": "Expression to validate currency formatted numbers without the currency symbol",
        "matches": [
            "153",
            "33.48",
            "786.1",
            "1567863483.33"
        ],
        "nonMatches": [
            "-123",
            "8524.258",
            "eo45"
        ],
        "pattern": "^(\\d?)*(\\.\\d{1}|\\.\\d{2})?$",
        "title": "Test"
    },
    {
        "description": "Will verify if the text is is in a valid user name format like: is alphanumeric, starts with an alphabet and contains no special characters other than underscore or dash.",
        "matches": [
            "username",
            "user123",
            "user_123",
            "user-123",
            "username123_type"
        ],
        "nonMatches": [
            "123username",
            "user name",
            "_username"
        ],
        "pattern": "^([a-zA-Z])[a-zA-Z_-]*[\\w_-]*[\\S]$|^([a-zA-Z])[0-9_-]*[\\S]$|^[a-zA-Z]*[\\S]$",
        "title": "Test"
    },
    {
        "description": "This regex gets the value within an XML Tag. For example, given the following tag: \u003CResult\u003Eresult is here\u003C/Result\u003E it returns the string \u0022result is here\u0022. Replace TAGNAME with your tag name.",
        "matches": [
            "\u003Ctest\u003Evalue\u003C/test\u003E",
            "\u003CResult\u003Esome response\u003C/Result\u003E",
            "\u003Cname\u003ERyan Shripat\u003C/name\u003E",
            "\u003Ca href=\u0022http://www.mindbaseconsulting.com\u0022\u003EMindbase Consulting\u003C/a\u003E"
        ],
        "nonMatches": [
            "\u003Cresult\u003Etrue\u003C/answer\u003E",
            "\u003Cname isLong=\u0022yes\u0022\u003ERyan Shripat\u003C/nameX\u003E",
            "random text"
        ],
        "pattern": "(?\u003C=\u003CTAGNAME.*\u003E).*(?=\u003C/TAGNAME\u003E)",
        "title": "Test"
    },
    {
        "description": "Validate: First five characters are letters; characters six-17 are letters, numbers, or hyphen; string length is eight characters minimum, 17 characters maximum",
        "matches": [
            "ABCDE123abc-123AB"
        ],
        "nonMatches": [
            "1BCDE123abc-123AB -BCDE123abc-123AB ABCDE6789012345678"
        ],
        "pattern": "^([a-zA-Z]{5})([a-zA-Z0-9-]{3,12})",
        "title": "Test"
    },
    {
        "description": "Returns the value from a CSV line.",
        "matches": [
            ",,\u0022\u0022,a,a\u0022\u0022,\u0022\u0022a,a\u0022\u0022a,aa\u0022\u0022a,\u0022,\u0022,a\u0022a,a\u0022a\u0022,aa\u0022,bb\u0022",
            "as,\u0022fsfdf,g",
            ",\u0022as,\u0022fsfdf,g\u0022"
        ],
        "nonMatches": [
            "",
            ""
        ],
        "pattern": "\\A[^,\u0022]*(?=,)|(?:[^\u0022,]*\u0022[^\u0022]*\u0022[^\u0022,]*)+|[^\u0022,]*\u0022[^\u0022]*\\Z|(?\u003C=,)[^,]*(?=,)|(?\u003C=,)[^,]*\\Z|\\A[^,]*\\Z",
        "title": "Test"
    },
    {
        "description": "This Expression verifies all the valid date in the US Date Format.It also checks the leap year.we can use this expression with or with out the prefix of zero in the date column and month column Eg[01/02/2008 or 1/2/2008].It accepts date which are greater than the year 1900.I can assure that this will be useful for all the developers who are searching for Date entry",
        "matches": [
            "02/29/1984;10/9/2000;1/1/2009"
        ],
        "nonMatches": [
            "02/02/1899;13/02/2000;02/29/2001;02-29-2000"
        ],
        "pattern": "^(((0?[1-9]|1[012])/(0?[1-9]|1\\d|2[0-8])|(0?[13456789]|1[012])/(29|30)|(0?[13578]|1[02])/31)/(19|[2-9]\\d)\\d{2}|0?2/29/((19|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|(([2468][048]|[3579][26])00)))$",
        "title": "Test"
    },
    {
        "description": "This regular expressions matches dates of the form XX/XXX/YYYY where XX can be 1 or 2 digits long, XXX can be JAN/Jan/jan(Month name in 3 char) and YYYY is always 4 digits long.",
        "matches": [
            "11/jun/1980, 11/JUN/1980, 11/Jun/1980"
        ],
        "nonMatches": [
            "11 jun 1980, 11-jun-1980"
        ],
        "pattern": "^(3[0-1]|2[0-9]|1[0-9]|0[1-9])[\\/](Jan|JAN|Feb|FEB|Mar|MAR|Apr|APR|May|MAY|Jun|JUN|Jul|JUL|Aug|AUG|Sep|SEP|Oct|OCT|Nov|NOV|Dec|DEC)[\\/]\\d{4}$",
        "title": "Test"
    },
    {
        "description": "This Expression will help you in Validating Multiple e-Mail IDs in a single line seperated by \u0022;\u0022",
        "matches": [
            "jaimohann@yahoo.com",
            "jai.mohan@yahoo.com",
            "jai.mohan@yahoo.co.in",
            "jaimohann@yahoo.com;jai.mohan@yahoo.com;jai.mohan@yahoo.co.in"
        ],
        "nonMatches": [
            "jai..mohan@yahoo.com",
            "jai.mohan@yahoo.co.inkk"
        ],
        "pattern": "^(\\w+([_.]{1}\\w+)*@\\w+([_.]{1}\\w+)*\\.[A-Za-z]{2,3}[;]?)*$",
        "title": "Test"
    },
    {
        "description": "Matches persian(farsi) charctes from latin",
        "matches": [
            "\u0633\u0644\u0627\u0645",
            "\u0645\u06CC\u0647\u0646 123",
            "test\u062F\u06AF\u0631"
        ],
        "nonMatches": [
            "test121",
            "test 34243242",
            "all(...)"
        ],
        "pattern": "/([^\\x00-\\xFF]\\s*)/u",
        "title": "Test"
    },
    {
        "description": "Match any percentage entered between 0.00 and 100.00%, includes up to 2 decimal places. Percent sign is optional",
        "matches": [
            "100% 100.00 % 95.4% 1.2 % 12"
        ],
        "nonMatches": [
            "100.01% 120% -1.2% 95.445% 12%%"
        ],
        "pattern": "^100(\\.0{0,2})? *%?$|^\\d{1,2}(\\.\\d{1,2})? *%?$",
        "title": "Test"
    },
    {
        "description": "Match any percent from -100.00% to +100.00% up to 2 decimla places. Percent sign is optional",
        "matches": [
            "-96.4% -100% 100% 9% 9.10%"
        ],
        "nonMatches": [
            "-101% 101% 100.01% 9.288%"
        ],
        "pattern": "^[+-]? *100(\\.0{0,2})? *%?$|^[+-]? *\\d{1,2}(\\.\\d{1,2})? *%?$",
        "title": "Test"
    },
    {
        "description": "function isValidURL($url) { $protocol = \u0022((http|ftp|https):\\/\\/)?\u0022; $domain = \u0022([[:alpha:]][-[:alnum:]]*[[:alnum:]])(\\.[[:alpha:]][-[:alnum:]]*[[:alpha:]])+\u0022; $dir = \u0022(/[[:alpha:]][-[:alnum:]]*[[:alnum:]])*\u0022; $page = \u0022(/[[:alpha:]][-[:alnum:]]*\\.[[:alpha:]]{3,5})?\u0022; $getstring = \u0022(\\?([[:alnum:]][-_%[:alnum:]]*=[-_%[:alnum:]]+)(\u0026([[:alnum:]][-_%[:alnum:]]*=[-_%[:alnum:]]+))*)?\u0022; $pattern = \u0022^\u0022.$protocol.$domain.$dir.$page.$getstring.\u0022$\u0022; return eregi($pattern, $url); } //----------------- Be sure to put each variable ($protocol, $domain, $dir, $page, $getstring, $pattern, and \u0027return\u0027) on separate line!",
        "matches": [
            "www.google.co.uk",
            "www9.g-88gle.co.uk",
            "http://path1/to-page",
            "http://phpinfo.php"
        ],
        "nonMatches": [
            "9ww.google.3o.uk",
            "www.google4.co.uk3",
            "http://path1-/2-page",
            "http://phpinfo.php4"
        ],
        "pattern": "if(!isValidURL($_POST[\u0027url\u0027]){ echo \u0022do something\u0022; }",
        "title": "Test"
    },
    {
        "description": "You can use this to check the valid file type you have given to the last in the expression like ^(([a-zA-Z]:)|(\\\\{2}\\w+)\\$?)(\\\\(\\w[\\w].*))+(.pdf)$ This will accept .pdf only OR ^(([a-zA-Z]:)|(\\\\{2}\\w+)\\$?)(\\\\(\\w[\\w].*))+((.pdf)|(.doc))$ This will accept .pdf and .doc OR ^(([a-zA-Z]:)|(\\\\{2}\\w+)\\$?)(\\\\(\\w[\\w].*))+((.pdf)|(.doc)|(.txt))$ This will accept .pdf , .doc and .txt",
        "matches": [
            "C:\\Documents and Settings\\chandan.kumar\\Desktop\\1004.pdf"
        ],
        "nonMatches": [
            "C:\\Documents and Settings\\All Users\\Documents\\My Pictures\\Sample Pictures\\Sunset.jpg"
        ],
        "pattern": "^(([a-zA-Z]:)|(\\\\{2}\\w+)\\$?)(\\\\(\\w[\\w].*))+(.pdf)$",
        "title": "Test"
    },
    {
        "description": "This expression will validate if a string represents a time in 24 hour format. The expression will evaluate the string from start to finish. It will not accept 24:00, use 00:00 instead.",
        "matches": [
            "1:59",
            "01:59",
            "23:59"
        ],
        "nonMatches": [
            "24:00",
            "01:60",
            "01:234"
        ],
        "pattern": "^([0-1]?[0-9]{1}|2[0-3]{1}):([0-5]{1}[0-9]{1})$",
        "title": "Test"
    },
    {
        "description": "This will validatet the Number for Max Tow decimal place after a number.. it will validate like 12, 12.1, 12.23; but it will invalidate 12.326",
        "matches": [
            "100,100.1,100.11"
        ],
        "nonMatches": [
            "100.123 , 100.1234"
        ],
        "pattern": "^\\d+(?:\\.\\d{0,2})?$",
        "title": "Test"
    },
    {
        "description": "Modified version- to capture the PO BOX based on user input on the website - It will not include any Rural Route or any University Box",
        "matches": [
            "PO Box N,P O Box125,HC73 P.O. Box 217,P.O Box 0129,pobox123, P O Box124"
        ],
        "nonMatches": [
            "777 Post Oak Blvd,PSC 477 Box 396,RR 1 Box 1020"
        ],
        "pattern": "[p|P][\\s]*[o|O][\\s]*[b|B][\\s]*[o|O][\\s]*[x|X][\\s]*[a-zA-Z0-9]*|\\b[P|p]+(OST|ost|o|O)?\\.?\\s*[O|o|0]+(ffice|FFICE)?\\.?\\s*[B|b][O|o|0]?[X|x]+\\.?\\s+[#]?(\\d+)*(\\D+)*\\b",
        "title": "Test"
    },
    {
        "description": "Zipcode should be of 5 numerics",
        "matches": [
            "matches only if 5 numerics are present"
        ],
        "nonMatches": [
            "not matches if less than 5 numerics"
        ],
        "pattern": "^[0-9]{5}$",
        "title": "Test"
    },
    {
        "description": "A very simple regex to parse 10-digit US phone numbers. Captures the leading 1 in $1, the area code in $2, the 3-digit prefix in $3, and the four-digit postfix in $4. This expression DOES allow for reserved area codes (001,etc) which are not typically in use.",
        "matches": [
            "(123)456-7890",
            "1234567890",
            "123 456 7890",
            "123-456-7890",
            "(123)4567890",
            "123-4567890"
        ],
        "nonMatches": [
            "123456789",
            "(1234)567890",
            "(12-3)4567890"
        ],
        "pattern": "(1)?-?\\(?\\s*([0-9]{3})\\s*\\)?\\s*-?([0-9]{3})\\s*-?\\s*([0-9]{4})\\s*",
        "title": "Test"
    },
    {
        "description": "Used with Regex.Split, this pattern split every sentences in a paragraph or a text (it recognizes quotation marks \u0022 and \u00BB and multiple .!?) It matches the spaces between every sentence.",
        "matches": [
            "n/a"
        ],
        "nonMatches": [
            "n/a"
        ],
        "pattern": "(?\u003C=[\\w\\s](?:[\\.\\!\\? ]+[\\x20]*[\\x22\\xBB]*))(?:\\s+(?![\\x22\\xBB](?!\\w)))",
        "title": "Test"
    },
    {
        "description": "Matches the first part of a UK Postcode (known as a postcode district). Case insensitive. Doesnt match: GIR # the postcode for the formerly Post Office-owned Girobank is GIR 0AA. SAN # the postcode for correctly addressed letters to Father Christmas is SAN TA1",
        "matches": [
            "LN5",
            "SW1",
            "ln5"
        ],
        "nonMatches": [
            "ln5 7nq",
            "GIR",
            "SAN"
        ],
        "pattern": "([A-PR-UWYZa-pr-uwyz]([0-9]{1,2}|([A-HK-Ya-hk-y][0-9]|[A-HK-Ya-hk-y][0-9]([0-9]|[ABEHMNPRV-Yabehmnprv-y]))|[0-9][A-HJKS-UWa-hjks-uw]))",
        "title": "Test"
    },
    {
        "description": "LTER PROCEDURE [dbo].[usernamecheck] @username varchar(50), @loginID int = 0 OUTPUT AS SELECT @loginID = empid from emp WHERE username=@username if @@ROWCOUNT \u003C 1 SELECT @loginID = 0 select @loginID",
        "matches": [
            "storedprocedures"
        ],
        "nonMatches": [
            "not stored procedures"
        ],
        "pattern": "getting username from empid",
        "title": "Test"
    },
    {
        "description": "Matches simple e-mail addresses such as me@domain.com, me@domain.co.uk, but does not place any restrictions on TLDs other than they must be lower case and alphabetic. a-z, A-Z, 0-9, ., _, and - are all allowed on the left side of @.",
        "matches": [
            "me@test.com",
            "me@test.co.uk",
            "me@test.asdf"
        ],
        "nonMatches": [
            "@test.com",
            "@.com",
            "@."
        ],
        "pattern": "^[a-zA-Z0-9._\\-]+@[a-z0-9\\-]+(\\.[a-z]+){1,}$",
        "title": "Test"
    },
    {
        "description": "Regular expression to limit types of files accepted. This example matches .aspx files only. This is the extended virsion of Ramon Hildreth for asp.net files.",
        "matches": [
            ". /oldpage.aspx",
            "http://www.newsite.com/newpage.aspx",
            "www.abc.com/aspx"
        ],
        "nonMatches": [
            "abc.asp",
            "abc",
            "abc.xxx"
        ],
        "pattern": "^([a-zA-Z].*|[1-9].*|[:./].*)\\.(((a|A)(s|S)(p|P)(x|X)))$",
        "title": "Test"
    },
    {
        "description": "US Addresses validation having atleast 3 characters ignoring any spaces. Can have hash \u0022#\u0022 comma \u0022,\u0022 dash \u0022-\u0022 dot \u0022.\u0022 but cannot start with these.",
        "matches": [
            "123 E DRACHMAN TUCSON AZ 12345, St # 123, North AVE New York. NY 12345"
        ],
        "nonMatches": [
            "-1 AVE,1, Aa,#1 Street ,. 20 North,,1 AVE"
        ],
        "pattern": "^[a-zA-Z0-9]+[\\s]*[a-zA-Z0-9.\\-\\,\\#]+[\\s]*[a-zA-Z0-9.\\-\\,\\#]+[a-zA-Z0-9\\s.\\-\\,\\#]*$",
        "title": "Test"
    },
    {
        "description": "This Regular Expression Chack Matching Persian Mobile Numbers It is Checking MCI,MTN Irancell and Talya Operators For Example In C#.NET: Regex.IsMatch(MobileNumber, \u0022(^(09|9)[1][1-9]\\\\d{7}$)|(^(09|9)[3][12456]\\\\d{7}$)\u0022);",
        "matches": [
            "09122838473",
            "9122838473",
            "09369048504"
        ],
        "nonMatches": [
            "+989122838473",
            "22248016",
            "12345"
        ],
        "pattern": "(^(09|9)[1][1-9]\\\\d{7}$)|(^(09|9)[3][12456]\\\\d{7}$)",
        "title": "Test"
    },
    {
        "description": "This Regex Will Remove All Html Tags And Return Simple Plain Text . For Example In C#.NET : Regex.Replace(Html, \u0022\u003C[^\u003E]*\u003E\u0022, string.Empty);",
        "matches": [
            "\u003Cp\u003E Hello Ali Delshad \u003C/p\u003E"
        ],
        "nonMatches": [
            "Hello Ali Delshad"
        ],
        "pattern": "\u003C[^\u003E]*\u003E",
        "title": "Test"
    },
    {
        "description": "Returns ungrouped match on Canadian Province Code, new and old or full province name",
        "matches": [
            "Any Province Code New and Old, Full Province Name"
        ],
        "nonMatches": [
            "Some French Abbreviations, All French Province Names"
        ],
        "pattern": "\\b(?:AB|ALB|Alta|alberta|BC|CB|British Columbia|LB|Labrador|MB|Man|Manitoba|N[BLTSU]|Nfld|NF|Newfoundland|NWT|Northwest Territories|Nova Scotia|New Brunswick|Nunavut|ON|ONT|Ontario|PE|PEI|IPE|Prince Edward Island|QC|PC|QUE|QU|Quebec|SK|Sask|Saskatchewan|YT|Yukon|Yukon Territories)\\b",
        "title": "Test"
    },
    {
        "description": "Checks for properly formatted Mime-Types. Checks that the Content-Type (before the \u0027/\u0027) is one registered with IANA. No spaces allowed.",
        "matches": [
            "application/mpeg4-generic",
            "image/png",
            "video/my-video+format"
        ],
        "nonMatches": [
            "x-world/x-3dmf",
            "text-javascript",
            "text/richtext rtx"
        ],
        "pattern": "/^(application|audio|example|image|message|model|multipart|text|video)\\/[a-zA-Z0-9]+([+.-][a-zA-z0-9]+)*$/",
        "title": "Test"
    },
    {
        "description": "its validating the string as shown in example(matches).",
        "matches": [
            "navjot, 24",
            "Sweet, 23"
        ],
        "nonMatches": [
            "456, abcd",
            "abcd 123"
        ],
        "pattern": "^\\s*[a-zA-Z\\s]+\\,[0-9\\s]+\\s*$",
        "title": "Test"
    },
    {
        "description": "Useful for determining whether a string constitutes a valid local or UNC path.",
        "matches": [
            "\\\\mypath\\mypath1\\myfile.aaa, C:\\mypath\\mypath\\mypath, \\\\otherpath\\otherpath, D:\\somepath\\somefile.file"
        ],
        "nonMatches": [
            "http://www.mysite.com, \\\\\\badpath\\badpath, X::\\\\badpath"
        ],
        "pattern": "^[a-zA-Z]\\:\\\\.*|^\\\\\\\\.*",
        "title": "Test"
    },
    {
        "description": "Time, which reg express is very simple to use :)",
        "matches": [
            "010000",
            "245959",
            "120000"
        ],
        "nonMatches": [
            "10000",
            "000000",
            "250000"
        ],
        "pattern": "^((0[1-9]|1[0-9]|2[0-4])([0-5]\\d){2})$",
        "title": "Test"
    },
    {
        "description": "I got a regex for date time from here, which had some bugs. so i referred a few regex from this site and created a regex which i tested and didnt find any errors. I will check again and update if required.",
        "matches": [
            "12/24/2004 12:42:25 AM, 12/24/2004(without time)"
        ],
        "nonMatches": [
            "12-24-2004 12:42:24 AM, 12/24/2004 12:42:24 am"
        ],
        "pattern": "^(0[1-9]|1[012])[/](0[1-9]|[12][0-9]|3[01])[/][0-9]{4}(\\s((0[1-9]|1[012])\\:([0-5][0-9])((\\s)|(\\:([0-5][0-9])\\s))([AM|PM|]{2,2})))?$",
        "title": "Test"
    },
    {
        "description": "Matches any integer from 0 to 2147483647 (max Integer size for C#, Java, others)",
        "matches": [
            "0",
            "352533",
            "2147483647"
        ],
        "nonMatches": [
            "-1",
            "2.4",
            "2147483648"
        ],
        "pattern": "^(\\d|\\d{1,9}|1\\d{1,9}|20\\d{8}|213\\d{7}|2146\\d{6}|21473\\d{5}|214747\\d{4}|2147482\\d{3}|21474835\\d{2}|214748364[0-7])$",
        "title": "Test"
    },
    {
        "description": "Regular Expression matches any internet URLs. Used with the replace method it comes in very handy.",
        "matches": [
            "http://www.mk.com,www.mk.com,www.mk.com/default.aspx,http://www.mk.com/default.aspx"
        ],
        "nonMatches": [
            ".com,wwww,1234"
        ],
        "pattern": "(http://([\\w-]+\\.)|([\\w-]+\\.))+[\\w-]*(/[\\w- ./?%=]*)?",
        "title": "Test"
    },
    {
        "description": "This expression will be useful to check postal code or pin code of India. This expression will check postal code or pin code in two format. One is code is separated by space after 3 digit and another is code is written in 6 digit.",
        "matches": [
            "360311",
            "360 311",
            "360 001"
        ],
        "nonMatches": [
            "36 0311",
            "3603111",
            "360 31",
            "36031"
        ],
        "pattern": "([0-9]{6}|[0-9]{3}\\s[0-9]{3})",
        "title": "Test"
    },
    {
        "description": "Returns array of full A tag [0], href [1], title [2] and innerHTML [3]. href, title and innerHTML are optional in tag; will return empty if missing. Test will only work using PHP preg_match_all or similar; I ask this site to add that option. Credit goes to user prometheuzz.",
        "matches": [
            "\u003Ca id=\u0027a\u0027 class=\u0027\u0027b\u0027 href=\u0027c\u0027 title=\u0027d\u0027\u003EinnerHTML\u003C/a\u003E; \u003Ca\u003E\u003C/a\u003E"
        ],
        "nonMatches": [
            "non a tags"
        ],
        "pattern": "#\u003Ca\\s*(?:href=[\\\u0027\u0022]([^\\\u0027\u0022]+)[\\\u0027\u0022])?\\s*(?:title=[\\\u0027\u0022]([^\\\u0027\u0022]+)[\\\u0027\u0022])?.*?\u003E((?:(?!\u003C/a\u003E).)*)\u003C/a\u003E#i",
        "title": "Test"
    },
    {
        "description": "A quick and dirty expression for splitting up a generic street address",
        "matches": [
            "101 W Main St",
            "101 W Main St. N",
            "101 Main St N"
        ],
        "nonMatches": [
            "Main St",
            "55a Main St",
            "101 W Main St Apt 5"
        ],
        "pattern": "^(\\d{3,})\\s?(\\w{0,5})\\s([a-zA-Z]{2,30})\\s([a-zA-Z]{2,15})\\.?\\s?(\\w{0,5})$",
        "title": "Test"
    },
    {
        "description": "This regex will match various ways of entering a Swiss phone number along with the country code.",
        "matches": [
            "+41 44 123 12 34",
            "+41 (0) 44 123 12 34",
            "+41-44-123-1234",
            "0041 44 123 12 34"
        ],
        "nonMatches": [
            "+41 0 44 123 1234",
            "+41.44.123.1234"
        ],
        "pattern": "^(\\+?)(\\d{2,4})(\\s?)(\\-?)((\\(0\\))?)(\\s?)(\\d{2})(\\s?)(\\-?)(\\d{3})(\\s?)(\\-?)(\\d{2})(\\s?)(\\-?)(\\d{2})",
        "title": "Test"
    },
    {
        "description": "Matches valid 3 or 6 character hex codes used for HTML or CSS.",
        "matches": [
            "fff",
            "#990000",
            "#cc3366",
            "#AAAAAA"
        ],
        "nonMatches": [
            "#5555",
            "#ZJK000",
            "CDCDCDCD"
        ],
        "pattern": "^\\#?[A-Fa-f0-9]{3}([A-Fa-f0-9]{3})?$",
        "title": "Test"
    },
    {
        "description": "Tests that a password contains between 6 and 12 characters, and contains at least one number.",
        "matches": [
            "Password1, pAsSwOrD23"
        ],
        "nonMatches": [
            "pwd, ThisPasswordIsTooLong3423423"
        ],
        "pattern": "^(?=.*\\d)(?=.*[a-zA-Z])(?!.*\\s).{6,12}$",
        "title": "Test"
    },
    {
        "description": "Tests that a screen name begins and ends with an alphanumeric, and otherwise use alphanumeric characters, hyphens, and underscores. Dictates length between 6 and 20 characters",
        "matches": [
            "Screen Name, screen_name1, 222_screen"
        ],
        "nonMatches": [
            "name, wayTooLong_ScreenName, *Screen\u0026Name@!"
        ],
        "pattern": "^([\\w][\\w\\-_\\u0020]{4,18}[\\w])$",
        "title": "Test"
    },
    {
        "description": "Classic gender descriptor regex.",
        "matches": [
            "F, M, female, male, Female, Male"
        ],
        "nonMatches": [
            "mail, femail, a, z,"
        ],
        "pattern": "^(?:m|M|male|Male|f|F|female|Female)$",
        "title": "Test"
    },
    {
        "description": "This is for Saudi phone",
        "matches": [
            "00966-01-4567890"
        ],
        "nonMatches": [
            "333-333-3333",
            "0096614252186"
        ],
        "pattern": "^(\\d{5}-\\d{2}-\\d{7})*$",
        "title": "Test"
    },
    {
        "description": "Matches a number using normalised scientific \u0027E\u0027 notation",
        "matches": [
            "-1.23E99",
            "1E0",
            "-9.999e-999"
        ],
        "nonMatches": [
            "+10E0",
            "2.3e5.4"
        ],
        "pattern": "[+-]?\\d(\\.\\d+)?[Ee][+-]?\\d+",
        "title": "Test"
    },
    {
        "description": "Validates that a string represents a javascript number (as defined by ECMAScript 3 Specs): integer (base-10) or floating point including in the exponential notation. Doesn\u0027t match the empty string.",
        "matches": [
            "23",
            "-17.e23",
            "+.199E-19",
            "10.",
            "10e10"
        ],
        "nonMatches": [
            "+.e2",
            "23.17.5",
            "10e2.0",
            "22e"
        ],
        "pattern": "^[-+]?(?:\\d+\\.?|\\.\\d)\\d*(?:[Ee][-+]?\\d+)?$",
        "title": "Test"
    },
    {
        "description": "Matches against dumps of Cisco MAC address tables on newer versions of Cisco IOS.",
        "matches": [
            "001e.1324.683f",
            "1234.abcd.1234",
            "ffff.ffff.ffff"
        ],
        "nonMatches": [
            "001E.1324.683f",
            "001234.abcd.abcd",
            "abcd.1234.abcd.1234",
            "aa-bb-cc-dd-ee-ff",
            "11:22:33:44:55:66"
        ],
        "pattern": "^([0-9a-f]{4}\\.[0-9a-f]{4}\\.[0-9a-f]{4})$",
        "title": "Test"
    },
    {
        "description": "This Regex allows usernames with or without special char .",
        "matches": [
            "vishal.mehta;vishal12.12;vishal08"
        ],
        "nonMatches": [
            ".vishal;vishal_mehta09;Vishal Mehta;vishal."
        ],
        "pattern": "^([a-zA-Z]+)[0-9]*\\.*[a-zA-Z0-9]+$|^[a-zA-Z]+[0-9]*$",
        "title": "Test"
    },
    {
        "description": "An expression to validate a search string which accepts a wildcard(asterik) at most once anywhere in the string.",
        "matches": [
            "search*",
            "*search",
            "se*rch",
            "search",
            "*"
        ],
        "nonMatches": [
            "search**",
            "**search",
            "**",
            "s**rch",
            "s*a*ch"
        ],
        "pattern": "^[^\\*]{0,}[\\*]{0,1}[^\\*]{0,}$",
        "title": "Test"
    },
    {
        "description": "Will match any valid US or Canada zip code",
        "matches": [
            "12345, 12345-1234, A1A 1A1, A1A1A1"
        ],
        "nonMatches": [
            "123451234, 1234, 1A1 A1A"
        ],
        "pattern": "^(\\d{5}-\\d{4}|\\d{5}|\\d{9})$|^([a-zA-Z]\\d[a-zA-Z]( )?\\d[a-zA-Z]\\d)$",
        "title": "Test"
    },
    {
        "description": "Decimal like 123.23 123.1234 12345.456",
        "matches": [
            "123.23",
            "123.1234",
            "1234",
            "1234.456"
        ],
        "nonMatches": [
            "123a.12",
            "123.34d",
            "abc"
        ],
        "pattern": "^\\d*[0-9](|.\\d*[0-9]|)*$",
        "title": "Test"
    },
    {
        "description": "This expression will help you to match chennai telephone numbers. chennai bsnl telephone numbers will start from 2.",
        "matches": [
            "044-26320244",
            "04426320244"
        ],
        "nonMatches": [
            "044-12345678",
            "123-12345678"
        ],
        "pattern": "^(0)44[\\s]{0,1}[\\-]{0,1}[\\s]{0,1}2[\\s]{0,1}[1-9]{1}[0-9]{6}$",
        "title": "Test"
    },
    {
        "description": "Matches single line or multi-line comments.",
        "matches": [
            "// Comment here",
            "/// Comment here",
            "/* Cmment Here */",
            "/**** Comment Here ****/"
        ],
        "nonMatches": [
            "/ * Comment Here */",
            "/* Comment here * /"
        ],
        "pattern": "//.*|/\\*[\\s\\S]*?\\*/",
        "title": "Test"
    },
    {
        "description": "matches most most web URLs",
        "matches": [
            "domain.com",
            "domain.co.uk",
            "www.domain.co.uk",
            "http://www.domain.co.uk",
            "http://www.amazon.co.uk/MP3-Music-Download/b/ref=amb_link_83020893_6?ie=UTF8\u0026node=77197031\u0026pf_rd_m=A3P5ROKL5A1OLE\u0026pf_rd_s=center-0\u0026pf_rd_r=0DG5PYVMBYNY9SHEJCQ1\u0026pf_rd_t=101\u0026pf_rd_p=465942413\u0026pf_rd_i=468294"
        ],
        "nonMatches": [
            "http:///",
            "ftp://",
            "anythingElse://"
        ],
        "pattern": "(https?://)?((?:(\\w+-)*\\w+)\\.)+(?:com|org|net|edu|gov|biz|info|name|museum|[a-z]{2})(\\/?\\w?-?=?_?\\??\u0026?)+[\\.]?[a-z0-9\\?=\u0026_\\-%#]*",
        "title": "Test"
    },
    {
        "description": "Validate full names (w/ accents). A first/last name needed, at least, 2 letters. See examples.",
        "matches": [
            "Thayn\u00E3 Sant\u0027Anna",
            "Bruno Moretti"
        ],
        "nonMatches": [
            "Thayn\u00E3 C.",
            "T. Moretti"
        ],
        "pattern": "^(?i)([\u00C0-\u00FFa-z\\-]{2,})\\x20([\u00C0-\u00FFa-z\\-\u0027]{2,})(?-i)",
        "title": "Test"
    },
    {
        "description": "Basic expression to validate a 10 digit number. Does not allow for any delimiters between numbers. Specifies that numbers cannot start with a one.",
        "matches": [
            "2125551212",
            "7875559090",
            "4043005555"
        ],
        "nonMatches": [
            "18011212345",
            "(801)555-1212",
            "800-555-1212"
        ],
        "pattern": "(([2-9]{1})([0-9]{2})([0-9]{3})([0-9]{4}))$",
        "title": "Test"
    },
    {
        "description": "This will identify all the characters in between html tags irrespective of the length of the character or intiger. If scenario emerges to extract content between tags a replacement string can be used: $3",
        "matches": [
            "\u003Ctd\u003Ecity\u003C/td\u003E\u003Chead\u003Eok\u003C/head\u003E"
        ],
        "nonMatches": [
            "content without tags"
        ],
        "pattern": "(\\\u003C(.*?)\\\u003E)(.*?)(\\\u003C\\/(.*?)\\\u003E)",
        "title": "Test"
    },
    {
        "description": "Repetition of two numeric sets can be identified with this RE.",
        "matches": [
            "(1 1) (33 33) (1234567890 1234567890)"
        ],
        "nonMatches": [
            "(1 1two) (1 one) (twothree4 234)"
        ],
        "pattern": "\\b([0-9]+) +\\1\\b",
        "title": "Test"
    },
    {
        "description": "This RE recognizes unformatted US phone numbers. The replacement string is $2-$4-$6. Helps when you want to normalize the phone numbers in a DB field.This also identifies a single space given before are after the part of first, second 3 digits and before the last 4 digits. The replaced format will be \u0022123-456-7890\u0022",
        "matches": [
            "(123)-123/2345 1234567890 123-123-2345 123/234\\8976 333.334,3456"
        ],
        "nonMatches": [
            "(1234567890 jdfojsdoj) ( 3456789098) (sdfhdih 675-576-9087)"
        ],
        "pattern": "^([\\.\\\u0022\\\u0027-/ \\(/)\\s\\[\\]\\\\\\,\\\u003C\\\u003E\\;\\:\\{\\}]?)([0-9]{3})([\\.\\\u0022\\\u0027-/\\(/)\\s\\[\\]\\\\\\,\\\u003C\\\u003E\\;\\:\\{\\}]?)([0-9]{3})([\\,\\.\\\u0022\\\u0027-/\\(/)\\s\\[\\]\\\\\\\u003C\\\u003E\\;\\:\\{\\}]?)([0-9]{4})$",
        "title": "Test"
    },
    {
        "description": "USA Phone number with dash, periods, slashes, spaces, () and only last 7 digit is required but everything else is checked Here it is broken down feel free to add too it or use it Begin String: ^ Country Code 1: (1|1(\\s|\\s?-\\s?|\\s?\\.\\s?|\\s?/\\s?))? Area Code FirstDigit cannot be 0 or 1:((\\(?[2-9]{1}[\\d]{2}\\)?(\\s|\\s?-\\s?|\\s?\\.\\s?|\\s?/\\s?)?))? 3Digit Prefix: (\\d{3}) Space/-/. between: (\\s|\\s?-\\s?|\\s?\\.\\s?|\\s?/\\s?)? 4Digit Suffix: (\\d{4}) End String $ *can add country code with out area code!!",
        "matches": [
            "555-5555 1-555-555-5555 1-(555)-555-5555"
        ],
        "nonMatches": [
            "0 or 1 starts area code, 1 isn\u0027t the country code, non-valid US numbers"
        ],
        "pattern": "^(1|1(\\s|\\s?-\\s?|\\s?\\.\\s?|\\s?/\\s?))?((\\(?[2-9]{1}[\\d]{2}\\)?(\\s|\\s?-\\s?|\\s?\\.\\s?|\\s?/\\s?)?))?(\\d{3})(\\s|\\s?-\\s?|\\s?\\.\\s?|\\s?/\\s?)?(\\d{4})$",
        "title": "Test"
    },
    {
        "description": "Aceita duas casas decimas ap\u00F3s a v\u00EDrgula. Pode ser usado para Real Brasil. Uses up to two decimal places. Good to use for brazilian money format (Real).",
        "matches": [
            "100.000,00",
            "100000,00",
            "89",
            "89,87",
            ""
        ],
        "nonMatches": [
            "89.87",
            "100,000.00",
            "0.75"
        ],
        "pattern": "^([1-9]{1}[\\d]{0,2}(\\.[\\d]{3})*(\\,[\\d]{0,2})?|[1-9]{1}[\\d]{0,}(\\,[\\d]{0,2})?|0(\\,[\\d]{0,2})?|(\\,[\\d]{1,2})?)$",
        "title": "Test"
    },
    {
        "description": "This matches a valid windows filename. Not a valid path.I wanted something simple that covered all the bases",
        "matches": [
            "file.txt",
            "fie.txt.pdf",
            "file(with parenthesis).pdf"
        ],
        "nonMatches": [
            "*file.pdf",
            "file.tx"
        ],
        "pattern": "^([a-zA-Z]:\\\\)?[^\\x00-\\x1F\u0022\u003C\u003E\\|:\\*\\?/]+\\.[a-zA-Z]{3,4}$",
        "title": "Test"
    },
    {
        "description": "count the space and new line character also .. pass first parameter for minimun and next for maximum character",
        "matches": [
            "r,rr,rrr,rrrr,rrrrr"
        ],
        "nonMatches": [
            "rrrrrr"
        ],
        "pattern": "(.|[\\r\\n]){1,5}",
        "title": "Test"
    },
    {
        "description": "For Email Inputs checks to RFC 5322 Standards (no IP address though Didn\u0027t Want them) localhost: cannot start or end with . cannot have .. in it Domain: cannot start with - or . Known problems: TLDDoesntExist@domain.moc domains can be longer then 255. But each Domain can only be 63 then a . is required",
        "matches": [
            "3tt3rsAndNumb3rs@domain.comhas-dash@domain.com hasApostrophe.o\u0027leary@domain.orguncommonTLD@domain.museumuncommonTLD@domain.traveluncommonTLD@domain.mobicountryCodeTLD@domain.ukcountryCodeTLD@domain.rwlettersInDomain@911.comunderscore_inLocal@domain.netsubdomain@sub.domain.comlocal@dash-inDomain.comdot.inLocal@foo.coma@singleLetterLocal.orgsingleLetterDomain@x.org\u0026*=?^+{}\u0027~@CharsInLocal.net"
        ],
        "nonMatches": [
            "missingDomain@.com @missingLocal.org missingatSign.net missingDot@comtwo@@signs.com .localStartsWithDot@domain.comlocalEndsWithDot.@domain.comtwo..consecutiveDots@domain.comdomainStartsWithDash@-domain.comdomainEndsWithDash@domain-.com"
        ],
        "pattern": "^[-\\w\u0027+*$^\u0026%=~!?{}#|/\u0060]{1}([-\\w\u0027+*$^\u0026%=~!?{}#|\u0060.]?[-\\w\u0027+*$^\u0026%=~!?{}#|\u0060]{1}){0,31}[-\\w\u0027+*$^\u0026%=~!?{}#|\u0060]?@(([a-zA-Z0-9]{1}([-a-zA-Z0-9]?[a-zA-Z0-9]{1}){0,31})\\.{1})+([a-zA-Z]{2}|[a-zA-Z]{3}|[a-zA-Z]{4}|[a-zA-Z]{6}){1}$",
        "title": "Test"
    },
    {
        "description": "According to RFC 2821 (\u003Csee cref=\u0022http://tools.ietf.org/html/2821\u0022/\u003E) and RFC 2822 (\u003Csee cref=\u0022http://tools.ietf.org/html/2822\u0022/\u003E), the local-part of an email addresses may use any of these ASCII characters: 1. Uppercase and lowercare letters 2. The digits 0 through 9 3. The characters, !#$%\u0026\u0027*+-/=?^_\u0060{|}~ 4. The character \u0022.\u0022 provided that it is not the first or last character in the local-part.",
        "matches": [
            "a\u0026d@somedomain.com, a*d@somedomain.com,a/d@somedomain.com,"
        ],
        "nonMatches": [
            ".abc@somedomain.com, abc.@somedomain.com, a\u003Eb@somedomain.com"
        ],
        "pattern": "^((([!#$%\u0026\u0027*+\\-/=?^_\u0060{|}~\\w])|([!#$%\u0026\u0027*+\\-/=?^_\u0060{|}~\\w][!#$%\u0026\u0027*+\\-/=?^_\u0060{|}~\\.\\w]{0,}[!#$%\u0026\u0027*+\\-/=?^_\u0060{|}~\\w]))[@]\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*)$",
        "title": "Test"
    },
    {
        "description": "Phone number with country prefix +2 or +22 (one or two digits), then City code in parenthesis, like (444)? then phone number 6 to 8 digits and optional extension \u0027#XXX\u0027 up to 10 digits",
        "matches": [
            "+7(834)4328933#890",
            "+72(834)43289323#8902892",
            "+33(834)328932"
        ],
        "nonMatches": [
            "+7(834)4328933#",
            "+7(834)4328#89908",
            "+723(834)4328#89908"
        ],
        "pattern": "^[+]\\d{1,2}\\(\\d{2,3}\\)\\d{6,8}(\\#\\d{1,10})?$",
        "title": "Test"
    },
    {
        "description": "Matches the Common Name (CN) of the subject of a US Department of Defense (DoD) Common Access Card (CAC). In the plain-text part of the client certificate stored on a CAC, a subject, or the person named as the user of the certificate is represented by their Common Name. This regex identifies CNs and groups the parts that represent first and last name and the unique 10-digit identifying number at the end. I optionally matches the middle name or initial and ordinal (or generation) (II,III,IV, etc), if present. It also accounts for both leading and trailing spaces as well as spaces and dashes within the name parts. It works for all common names I have ever had to deal with, though I do not know where the standard is stated to confirm compliance. It is formatted for use specifically as validation, but could be modified for search.",
        "matches": [
            "SMITH.JOHN.Q.0123456789",
            "SMITH.JANE.9876543210",
            "FILCH-TEMPLETON.GEORGE.FILIGREE-WHITE.XXVII.0192837465"
        ],
        "nonMatches": [
            "JOHN.1234567890",
            "SMITH.HENRY.123",
            "A.B.C.D.5647382910"
        ],
        "pattern": "^\\s*(?\u003CLast\u003E[-A-Za-z ]+)[.](?\u003CFirst\u003E[-A-Za-z ]+)(?:[.](?\u003CMiddle\u003E[-A-Za-z ]+))?(?:[.](?\u003COrdinal\u003E[IVX]+))?(?:[.](?\u003CNumber\u003E\\d{10}))\\s*$",
        "title": "Test"
    },
    {
        "description": "Will find any texts within a string that is enclosed within parenthesis ( )",
        "matches": [
            "Test (test 1)",
            "(test)",
            "Test (test 1) Test (test 2)"
        ],
        "nonMatches": [
            "Test"
        ],
        "pattern": "[\\(]{1,}[^)]*[)]{1,}",
        "title": "Test"
    },
    {
        "description": "This expressions was written for C#. Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also will only match files that have extensions consisting of 2, 3, or 4 characters. Currently fails with _ . or - in the path, this will be updated at some point.",
        "matches": [
            "/mnt/share/",
            "/home/.BASH",
            "/mnt/share/pic.jpeg",
            "/mnt/share/install.sh"
        ],
        "nonMatches": [
            "mnt/share",
            "//mnt///share//",
            "/mnt/share/install.installer",
            "/home\\user"
        ],
        "pattern": "^/{1}(((/{1}\\.{1})?[a-zA-Z0-9 ]+/?)+(\\.{1}[a-zA-Z0-9]{2,4})?)$",
        "title": "Test"
    },
    {
        "description": "[en] Postal Code in Slovak Republic contains five numbers. Between 3rd and 4th number can be space. [sk] Po\u0161tov\u00E9 smerov\u00E9 c\u00EDslo v Slovenskej Republike m\u00E1 p\u00E4t c\u00EDsel. Medzi 3. a 4. c\u00EDslicou m\u00F4\u017Ee byt medzera.",
        "matches": [
            "960 07",
            "84204"
        ],
        "nonMatches": [
            "96 010",
            "9604",
            "689012"
        ],
        "pattern": "^(([0-9]{5})|([0-9]{3}[ ]{0,1}[0-9]{2}))$",
        "title": "Test"
    },
    {
        "description": "SUPPORTED constructions: [*] - all five commands; [number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 \u0026 7 is sun); [*/nubmer] - see construction [number]; [word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters). NON SUPPORTED constructions: [number-number] and [number,number].",
        "matches": [
            "*/15 */12 30 feb 7",
            "10 * * * */2",
            "* * * * *"
        ],
        "nonMatches": [
            "62 * * */2 *",
            "* * * 0 *",
            "* * * Feb *"
        ],
        "pattern": "^(((([\\*]{1}){1})|((\\*\\/){0,1}(([0-9]{1}){1}|(([1-5]{1}){1}([0-9]{1}){1}){1}))) ((([\\*]{1}){1})|((\\*\\/){0,1}(([0-9]{1}){1}|(([1]{1}){1}([0-9]{1}){1}){1}|([2]{1}){1}([0-3]{1}){1}))) ((([\\*]{1}){1})|((\\*\\/){0,1}(([1-9]{1}){1}|(([1-2]{1}){1}([0-9]{1}){1}){1}|([3]{1}){1}([0-1]{1}){1}))) ((([\\*]{1}){1})|((\\*\\/){0,1}(([1-9]{1}){1}|(([1-2]{1}){1}([0-9]{1}){1}){1}|([3]{1}){1}([0-1]{1}){1}))|(jan|feb|mar|apr|may|jun|jul|aug|sep|okt|nov|dec)) ((([\\*]{1}){1})|((\\*\\/){0,1}(([0-7]{1}){1}))|(sun|mon|tue|wed|thu|fri|sat)))$",
        "title": "Test"
    },
    {
        "description": "Case sensitive (upper)!",
        "matches": [
            "BB123AB",
            "KE 999BB"
        ],
        "nonMatches": [
            "QT 123AB",
            "BB 1234AA",
            "BB001ABC"
        ],
        "pattern": "^(B(A|B|C|J|L|N|R|S|Y)|CA|D(K|S|T)|G(A|L)|H(C|E)|IL|K(A|I|E|K|M|N|S)|L(E|C|M|V)|M(A|I|L|T|Y)|N(I|O|M|R|Z)|P(B|D|E|O|K|N|P|T|U|V)|R(A|K|S|V)|S(A|B|C|E|I|K|L|O|N|P|V)|T(A|C|N|O|R|S|T|V)|V(K|T)|Z(A|C|H|I|M|V))([ ]{0,1})([0-9]{3})([A-Z]{2})$",
        "title": "Test"
    },
    {
        "description": "no comment",
        "matches": [
            "0955 12 34 56 - 0955 123 456 - 0955 123456 - 0955123456 - 955 12 34 56 - 955 123 456 - 955 123456 - 955123456"
        ],
        "nonMatches": [
            "0955 123 4567 - 0055 123 456"
        ],
        "pattern": "^(([0]{0,1})([1-9]{1})([0-9]{2})){1}([\\ ]{0,1})((([0-9]{3})([\\ ]{0,1})([0-9]{3}))|(([0-9]{2})([\\ ]{0,1})([0-9]{2})([\\ ]{0,1})([0-9]{2})))$",
        "title": "Test"
    },
    {
        "description": "This regular expression can be used to extract titles from web page",
        "matches": [
            "\u003Ctitle\u003ERegular Expression Library\u003C/title\u003E"
        ],
        "nonMatches": [
            "\u003Ctd\u003ERegular Expression Library\u003C/td\u003E"
        ],
        "pattern": "\u003Ctitle\u003E(.*?)\u003C/title\u003E",
        "title": "Test"
    },
    {
        "description": "Table: http://en.wikipedia.org/wiki/ISO_3166-1",
        "matches": [
            "only country code (two upper letters)"
        ],
        "nonMatches": [
            "others"
        ],
        "pattern": "^(A(D|E|F|G|I|L|M|N|O|R|S|T|Q|U|W|X|Z)|B(A|B|D|E|F|G|H|I|J|L|M|N|O|R|S|T|V|W|Y|Z)|C(A|C|D|F|G|H|I|K|L|M|N|O|R|U|V|X|Y|Z)|D(E|J|K|M|O|Z)|E(C|E|G|H|R|S|T)|F(I|J|K|M|O|R)|G(A|B|D|E|F|G|H|I|L|M|N|P|Q|R|S|T|U|W|Y)|H(K|M|N|R|T|U)|I(D|E|Q|L|M|N|O|R|S|T)|J(E|M|O|P)|K(E|G|H|I|M|N|P|R|W|Y|Z)|L(A|B|C|I|K|R|S|T|U|V|Y)|M(A|C|D|E|F|G|H|K|L|M|N|O|Q|P|R|S|T|U|V|W|X|Y|Z)|N(A|C|E|F|G|I|L|O|P|R|U|Z)|OM|P(A|E|F|G|H|K|L|M|N|R|S|T|W|Y)|QA|R(E|O|S|U|W)|S(A|B|C|D|E|G|H|I|J|K|L|M|N|O|R|T|V|Y|Z)|T(C|D|F|G|H|J|K|L|M|N|O|R|T|V|W|Z)|U(A|G|M|S|Y|Z)|V(A|C|E|G|I|N|U)|W(F|S)|Y(E|T)|Z(A|M|W))$",
        "title": "Test"
    },
    {
        "description": "I was looking for a regex that allows pretty much any combo of a US phone number. I found some that covered most of the bases, but not all of them. This regex allows for missing characters, periods, hyphens. It should cover most of the bases. If not, let me know! I want to make it better!",
        "matches": [
            "1231231234",
            "11231231234",
            "1-1231231234",
            "1123-1231234",
            "1123123-1234",
            "1-123-1231234",
            "1-123123-1234",
            "1123-123-1234",
            "1-123-123-1234",
            "(1231231234",
            "123)1231234",
            "(123)1231234",
            "(123)-1231234",
            "(123)123-1234",
            "(123)-123-1234",
            "(123-1231234",
            "(123123-1234",
            "123)-1231234",
            "123)123-1234",
            "(123-123-1234",
            "123)-123-1234",
            "1(123)1231234",
            "1(1231231234",
            "1123)1231234",
            "1-(1231231234",
            "1-123)1231234",
            "1-(123)1231234",
            "1-(123-1231234",
            "1-(123123-1234",
            "1-123)-1231234",
            "1-123)123-1234",
            "1-(123)-1231234",
            "1-(123)123-1234",
            "1-(123)-123-1234",
            "-1231231234",
            "-123-1231234",
            "-123123-1234",
            "-123-123-1234",
            "-"
        ],
        "nonMatches": [
            ")123(1231234",
            "123-1233-123",
            "(123(1231234"
        ],
        "pattern": "/^(1)?(-|.)?(\\()?([0-9]{3})(\\))?(-|.)?([0-9]{3})(-|.)?([0-9]{4})/",
        "title": "Test"
    },
    {
        "description": "Its validates a time stamp",
        "matches": [
            "2009-04-20 14:34:32",
            "2010-03-09 12:59:00",
            "1020-03-09 23:59:00"
        ],
        "nonMatches": [
            "text",
            "2009-13-00 00:00:00",
            "2009-12-20 23:60:00"
        ],
        "pattern": "^[1-9]{1}[0-9]{3}-(0[1-9]{1}|1[0-2]{1})-([0-2]{1}[1-9]{1}|3[0-1]{1}) ([0-1]{1}[0-9]{1}|2[0-3]{1}):[0-5]{1}[0-9]{1}:[0-5]{1}[0-9]{1}$",
        "title": "Test"
    },
    {
        "description": "Password must have at least 8 characters and maximum of 15 characters with at least one Capital letter, at least one lower case letter and at least one number.Special character is optional. Special characters \u0022,;\u0026|\u0027 not allowed.",
        "matches": [
            "Sathish2",
            "Sathi$h2",
            "Sath1sh"
        ],
        "nonMatches": [
            "sathish",
            "sathish2",
            "Sathish\u00262",
            "Sath",
            "sh"
        ],
        "pattern": "(?=^.{8,15}$)((?!.*\\s)(?=.*[A-Z])(?=.*[a-z])(?=(.*\\d){1,}))((?!.*[\u0022,;\u0026|\u0027])|(?=(.*\\W){1,}))(?!.*[\u0022,;\u0026|\u0027])^.*$",
        "title": "Test"
    },
    {
        "description": "Simple (non-validating) match with numbered group captures that extracts parts of a filename into $1 = folder path, $2 = filename w/o extension, $3 = extension. Should work on Windows, OS X, and Unix/Linux, but not on OS 9 and OSs with folder separators other than slashes (either direction). Tested only on .NET RE engine.",
        "matches": [
            "test",
            "test.txt",
            "C:\\test",
            "C:\\test.txt",
            "C:\\test.txt\\testing.txt",
            "C:\\folder\\test",
            "C:\\folder\\test.txt.txt",
            "C:\\folder\\test.txt.txt\\testing.txt",
            "/usr/test",
            "/usr/test.txt",
            "/usr/test.txt/testing.pdf"
        ],
        "nonMatches": [
            "N/A (some captures may end up being blank in the event of a relative path or no file extension)"
        ],
        "pattern": "^(.*?)([^/\\\\]*?)(\\.[^/\\\\.]*)?$",
        "title": "Test"
    },
    {
        "description": "The Regular Expression to validate time format in [24:00] hrs. \u003E\u003E Pemitted values from 00:00 to 23:59 \u003E\u003E Prefix zero for single digit hours 01:00 to 09:59 \u003E\u003E Tested \u0026 Certified by Mr. Shripad Pramod Bhende :-)",
        "matches": [
            "01:00 , 23:59"
        ],
        "nonMatches": [
            "2:00, 2:2, 02-30"
        ],
        "pattern": "^(([01][0-9]|[012][0-3]):([0-5][0-9]))*$",
        "title": "Test"
    },
    {
        "description": "Regular Expression to validate date in MM/DD/YYYY format. \u003E\u003E Permitted formats \u00221/1/2008\u201D or \u201C01/01/2008\u201D or \u201C01/1/2008\u201D or 1/01/2008\u201D",
        "matches": [
            "1/1/2008, 01/01/2008, 01/1/2008, 1/01/2008, 1-01-2008"
        ],
        "nonMatches": [
            "31/12/2009"
        ],
        "pattern": "(([1-9]|[0][1-9])|1[012])[- /.](([1-9]|[0][1-9])|[12][0-9]|3[01])[- /.](19|20)\\d\\d",
        "title": "Test"
    },
    {
        "description": "This will validate most legal websites, including ftp.",
        "matches": [
            "http://www.website.com",
            "www.website.co.uk",
            "ftp.stuff.org",
            "http://website.com/directory/directory/file.php?question=answer"
        ],
        "nonMatches": [
            "abc://www.name.com",
            "www.website",
            "http//www.website.com",
            "website.com"
        ],
        "pattern": "^((http|https|ftp):\\/\\/(www\\.)?|www\\.)[a-zA-Z0-9\\_\\-]+\\.([a-zA-Z]{2,4}|[a-zA-Z]{2}\\.[a-zA-Z]{2})(\\/[a-zA-Z0-9\\-\\._\\?\\\u0026=,\u0027\\+%\\$#~]*)*$",
        "title": "Test"
    },
    {
        "description": "Matches valid UK residential telephone numbers in all expected formats, including international.",
        "matches": [
            "02081234567, 0208 123 4567, 0208 123-4567, +44 208 123 4567, +44 (0) 208 123 4567, 01234 567 890, +44 0 1234 567-890, 07712 123 456"
        ],
        "nonMatches": [
            "020812345678, 123456789, 07612 123 4567"
        ],
        "pattern": "^(?:\\(\\+?44\\)\\s?|\\+?44 ?)?(?:0|\\(0\\))?\\s?(?:(?:1\\d{3}|7[1-9]\\d{2}|20\\s?[78])\\s?\\d\\s?\\d{2}[ -]?\\d{3}|2\\d{2}\\s?\\d{3}[ -]?\\d{4})$",
        "title": "Test"
    },
    {
        "description": "Searches for US SSNs that have either a white space, \u0022.\u0022, \u0022,\u0022, or \u0022=\u0022 in front and either a white space, \u0022.\u0022, or \u0022,\u0022 at the end. Ensures that sets are separated with the same format (either spaces, dashes, or nothing).",
        "matches": [
            "123-45-6789",
            "123456789",
            "123 45 6789",
            "=123-45-6789",
            ".123456789",
            "end. 123 45 6789"
        ],
        "nonMatches": [
            "\u0026123-45-6789",
            "1234567890",
            "123 45 6789z",
            "123-456789",
            "12345-6789"
        ],
        "pattern": "[/,,/.,/=,\\s]([0-6]\\d{2}|7[0-6]\\d|77[0-2])(\\s|\\-)?(\\d{2})\\2(\\d{4})[/,,/.,\\s]",
        "title": "Test"
    },
    {
        "description": "Will match any unsigned integer from range 0 to 4294967295",
        "matches": [
            "0",
            "1000",
            "4294967295"
        ],
        "nonMatches": [
            "-100",
            "-0",
            "+0",
            "4294967296"
        ],
        "pattern": "^(0|(\\+)?[1-9]{1}[0-9]{0,8}|(\\+)?[1-3]{1}[0-9]{1,9}|(\\+)?[4]{1}([0-1]{1}[0-9]{8}|[2]{1}([0-8]{1}[0-9]{7}|[9]{1}([0-3]{1}[0-9]{6}|[4]{1}([0-8]{1}[0-9]{5}|[9]{1}([0-5]{1}[0-9]{4}|[6]{1}([0-6]{1}[0-9]{3}|[7]{1}([0-1]{1}[0-9]{2}|[2]{1}([0-8]{1}[0-9]{1}|[9]{1}[0-5]{1})))))))))$",
        "title": "Test"
    },
    {
        "description": "Manage negative double integer with four decimal",
        "matches": [
            "123.1234,-12.12,1234"
        ],
        "nonMatches": [
            "+123,12.123456"
        ],
        "pattern": "^[-]?[0-9]*\\.?[0-9]?[0-9]?[0-9]?[0-9]?",
        "title": "Test"
    },
    {
        "description": "This is the tightest uk postcode validator I can come up with, I have copy of Royal Mail\u0027s PAF (Postal Address File) and I\u0027ve confirmed that it will correctly validate all 1.75 million distinct postcodes. I figure this regex will accept 54 million strings as valid, which gives a 30:1 false accept ratio, the best I can do. I\u0027ll endeavour to keep it up to date with new post codes. I\u0027ve deliberately excluded special cases, These can be added as simple alternates. 2009-06-05 Improved: Replaced all numbered captured groups with 6 named capture groups (I Incode, O Outcode, d District, s Sector, a Area, u Unit) for separating postcode parts. Also removed begin (^) and end ($) positioning characters ST",
        "matches": [
            "CR0 1AA",
            "EC50 1AA",
            "SW1P 1AA",
            "GU1 3AW"
        ],
        "nonMatches": [
            "DR1 1AA",
            "EC51 1AA",
            "sw1p 1aa",
            "CR01AA",
            "GIR 0AA",
            "SAN TA1",
            "BFPO 2",
            "ASCN 1ZZ"
        ],
        "pattern": "(?\u003CO\u003E(?\u003Cd\u003E[BEGLMNS]|A[BL]|B[ABDHLNRST]|C[ABFHMORTVW]|D[ADEGHLNTY]|E[HNX]|F[KY]|G[LUY]|H[ADGPRSUX]|I[GMPV]|JE|K[ATWY]|L[ADELNSU]|M[EKL]|N[EGNPRW]|O[LX]|P[AEHLOR]|R[GHM]|S[AEGKL-PRSTWY]|T[ADFNQRSW]|UB|W[ADFNRSV]|YO|ZE)(?\u003Ca\u003E\\d\\d?)|(?\u003Cd\u003EE)(?\u003Ca\u003E\\dW)|(?\u003Cd\u003EEC)(?\u003Ca\u003E\\d[AMNPRVY0])|(?\u003Cd\u003EN)(?\u003Ca\u003E\\dP)|(?\u003Cd\u003ENW)(?\u003Ca\u003E\\dW)|(?\u003Cd\u003ESE)(?\u003Ca\u003E\\dP)|(?\u003Cd\u003ESW)(?\u003Ca\u003E\\d[AEHPVWXY])|(?\u003Cd\u003EW)(?\u003Ca\u003E1[0-4A-DFGHJKSTUW])|(?\u003Cd\u003EW)(?\u003Ca\u003E[2-9])|(?\u003Cd\u003EWC)(?\u003Ca\u003E[12][ABEHNRVX]))\\ (?\u003CI\u003E(?\u003Cs\u003E\\d)(?\u003Cu\u003E[ABD-HJLNP-UW-Z]{2}))",
        "title": "Test"
    },
    {
        "description": "Matches the Canadian postal code with or without space between. Also matches uppercase and lower case letters.",
        "matches": [
            "K4A3Z5",
            "K4A 3Z5",
            "k4a3z5",
            "k4a 3z5"
        ],
        "nonMatches": [
            "D1G 1T9",
            "abc def",
            "123 456",
            "f1g4t0"
        ],
        "pattern": "^[ABCEGHJKLMNPRSTVXYabceghjklmnprstvxy]{1}\\d{1}[A-Za-z]{1}[ ]{0,1}\\d{1}[A-Za-z]{1}\\d{1}$",
        "title": "Test"
    },
    {
        "description": "Password must be 6-40 characters - {6,40} Must have no spaces, at least 1 digit (?=.*[\\d]), at least 1 uppercase letter (?=.*[A-Z]) and at least one lowercase letter (?=.*[a-z]). Allows specifying special characters - !@#$%_",
        "matches": [
            "Pa5$Word",
            "HORS3y",
            "Th1$IsMyR3allYl0ngPa$$"
        ],
        "nonMatches": [
            "PASSWORD",
            "password",
            "Password",
            "1234567"
        ],
        "pattern": "^(?=.*[\\d])(?=.*[A-Z])(?=.*[a-z])[\\w\\d!@#$%_]{6,40}$",
        "title": "Test"
    },
    {
        "description": "Validate hours with seconds returning mirrors correctly.",
        "matches": [
            "09:05",
            "10:00",
            "1:15",
            "00:59:00",
            "23:01:59"
        ],
        "nonMatches": [
            "9:5",
            "09:1",
            "0:1",
            "0:00:0",
            "1:1:11"
        ],
        "pattern": "^([0-1][0-9]|[2][0-3]|[0-9]):([0-5][0-9])(?::([0-5][0-9]))?$",
        "title": "Test"
    },
    {
        "description": "Validate a date format: d/m/Y. See examples.",
        "matches": [
            "1/05/1990",
            "01/1/2006",
            "01/01/2008",
            "5/5/2009",
            "1/1/1990",
            "29/05/2009"
        ],
        "nonMatches": [
            "01/01/90",
            "32/02/2009",
            "1/13/1990",
            "0/0/2009"
        ],
        "pattern": "^([0-2]\\d|3[0-1]|[1-9])\\/(0\\d|1[0-2]|[1-9])\\/(\\d{4})$",
        "title": "Test"
    },
    {
        "description": "test for valid day, 01 to 31 and 1 to 31",
        "matches": [
            "01",
            "1",
            "31"
        ],
        "nonMatches": [
            "-1",
            "32",
            "0"
        ],
        "pattern": "^[0-2]?[1-9]{1}$|^3{1}[01]{1}$",
        "title": "Test"
    },
    {
        "description": "This regex only matches clean domain names. No path after. Ends in a forward slash. Starts with http://www. It is pretty slack on the TLD requiring a 2 or 3 letter ending. This part could be tightened up if you wanted to be restrict it to specific TLDs.",
        "matches": [
            "http://www.somedomain.co.uk/",
            "http://www.somedomain.com/",
            "http://www.dodgydomain.com.com/"
        ],
        "nonMatches": [
            "http://www.somedomain.co.uk/withpath.aspx",
            "http://somedomainwithoutwww.co.uk",
            "http://www.com/",
            "www.noprotocolprefix.com/",
            "https://www.secureprotocolprefix.com/",
            "http://www.notrailingslash.co.uk",
            "HTTP://WWW.beginswithcaps.com/"
        ],
        "pattern": "^http\\://www.[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,3}/$",
        "title": "Test"
    },
    {
        "description": "Pattern matches all file extensions from two(2) to five(5) characters in length (e.g. Adobe Illustrator [*.ai] or Extensible Hypertext Markup Language [*.xhtml]). Input can be an absolute path, relative path, URI, directory path, etc. If there are get variables in a URI input, they are ignored.",
        "matches": [
            "http://regexlib.com/Add.aspx",
            "/path/to/filename.txt",
            "TheSpanishInquisition.mpeg",
            "42.ai",
            "Dont Panic.xhtml",
            "http://localhost/webPage/index.php?variable=value"
        ],
        "nonMatches": [
            "Non-extentionFileName",
            "FilenameWithOneCharacterExtension.q",
            "FIlenameWithSixOrMoreCharactersExtension.invalid"
        ],
        "pattern": "\\.([A-Za-z0-9]{2,5}($|\\b\\?))",
        "title": "Test"
    },
    {
        "description": "This regular expression will parse an ISO8601 date into it\u0027s individual parts.",
        "matches": [
            "2009-06-18T18:50:57-06:00, 2009-06-18T18:30:01.123478-06:00, 2009-06-18T18:30:45Z, 2009-06-18T18:39Z"
        ],
        "nonMatches": [
            "January 5, 1995, or other non ISO8601 dates."
        ],
        "pattern": "(\\d\\d\\d\\d)-?(\\d\\d)-?(\\d\\d)T?(\\d\\d):?(\\d\\d)(?::?(\\d\\d)(\\.\\d+)*?)?(Z|[+-])(?:(\\d\\d):?(\\d\\d))?",
        "title": "Test"
    },
    {
        "description": "Allows dashes or spaces to separate.",
        "matches": [
            "0800 333 4444",
            "0870-333-4444",
            "0844 333-4444"
        ],
        "nonMatches": [
            "08003334444",
            "0800=333=4444",
            "0800 333 4444"
        ],
        "pattern": "^[\\d]{4}[-\\s]{1}[\\d]{3}[-\\s]{1}[\\d]{4}$",
        "title": "Test"
    },
    {
        "description": "Single- or multi-digit signed Integer.",
        "matches": [
            "12",
            "-2",
            "+3213"
        ],
        "nonMatches": [
            "abc",
            "@41",
            "43.12"
        ],
        "pattern": "^[+-]?[0-9]+$",
        "title": "Test"
    },
    {
        "description": "This matches any valid IPV4 IP Address. It includes 0-255 range checks since none of the IP components may exceed 255.",
        "matches": [
            "97.67.44.20",
            "199.154.37.214",
            "127.0.0.1"
        ],
        "nonMatches": [
            "63.125.94.287",
            "140.370.a.187",
            "94.923.1"
        ],
        "pattern": "^(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9]{1,2})(\\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9]{1,2})){3}$",
        "title": "Test"
    },
    {
        "description": "Separa \u003CApellidos\u003E, \u003CNombres\u003E",
        "matches": [
            "L\u00F3pez Benites, Arturo Fernando",
            "L\u00F3pez B., A. Fernando",
            "O\u0027Higgins, Gabriel"
        ],
        "nonMatches": [
            "cuando se dan m\u00E1s de 4 o bien Apellidos o Nombres pero es editable {1,4}"
        ],
        "pattern": "^(?n:(?\u003CApellidos\u003E(?-i:[A-Z]\\\u0027?(\\w+?|\\.)\\ ??){1,4})?[\\s,\\s]*(?\u003CNombres\u003E(?-i:[A-Z]\\\u0027?(\\w+?|\\.)\\ ??){1,4})?)$",
        "title": "Test"
    },
    {
        "description": "By using this we can upload only images files. This is the simplest and its execution is fast.",
        "matches": [
            "D:\\Documents and Settings\\Administrator\\Desktop\\New Folder\\60101-prep.png"
        ],
        "nonMatches": [
            "D:\\Documents and Settings\\Administrator\\Desktop\\New Folder\\60101-prep.pdf"
        ],
        "pattern": "^.*([^\\.][\\.](([gG][iI][fF])|([Jj][pP][Gg])|([Jj][pP][Ee][Gg])|([Bb][mM][pP])|([Pp][nN][Gg])))",
        "title": "Test"
    },
    {
        "description": "This matches all valid forms of an IPv6 address. Including the compatibility form used to map IPv4 addresses. As well as the base-85 encoded integer form. It takes care of value range checking on the ipv4 part (components cannot exceed 0-255). This has been tested quite thoroughly, but considering the complexity and possibilities in the formation of an IPv6 address, matching errors are not guaranteed to be absent.",
        "matches": [
            "::5:aef1:ffff",
            "::ffff:240.65.238.22",
            "0:0:0:0:0:0:0:1"
        ],
        "nonMatches": [
            "79250:9a0:",
            "8",
            "91cf91d3da9"
        ],
        "pattern": "(^\\d{20}$)|(^((:[a-fA-F0-9]{1,4}){6}|::)ffff:(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9]{1,2})(\\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9]{1,2})){3}$)|(^((:[a-fA-F0-9]{1,4}){6}|::)ffff(:[a-fA-F0-9]{1,4}){2}$)|(^([a-fA-F0-9]{1,4}) (:[a-fA-F0-9]{1,4}){7}$)|(^:(:[a-fA-F0-9]{1,4}(::)?){1,6}$)|(^((::)?[a-fA-F0-9]{1,4}:){1,6}:$)|(^::$)",
        "title": "Test"
    },
    {
        "description": "This can be used to validate package names ending with %. If % is not needed ^([a-z]+?\\.[a-z]+)+. (.....) can be used to make that part common. \u0022+\u0022 is for more than one number of occurences. \u0022?\u0022 is for one \u0022.\u0022 (dot) charactor",
        "matches": [
            "aaa.bbb% a.b.cccc.dd%"
        ],
        "nonMatches": [
            "aa% aaa.% aaa.bbb. aaa.bbb"
        ],
        "pattern": "^([a-z]+?\\.[a-z]+)+\\%$",
        "title": "Test"
    },
    {
        "description": "This matches Natural numbers with or without preceding zeros. ^[0]+?[1-9]\\d*\\.?[0]*$ this states there should be atleast one zero",
        "matches": [
            "090, 089, 01",
            "01.00",
            "08.0",
            "000056",
            "0054.0",
            "00055.000"
        ],
        "nonMatches": [
            "0",
            "0.00",
            "-1"
        ],
        "pattern": "^[0]*?[1-9]\\d*\\.?[0]*$",
        "title": "Test"
    },
    {
        "description": "Registro Federal de Contribuyentes (RFC) , used in Mexico as a unique set of characters for a person or corporation registration . Registro Federal de Contribuyentes utilizado en Mexico para el registro en hacienda (includes leap years)",
        "matches": [
            "ABCD790419",
            "ABC790419aa1",
            "ABC800229aa1"
        ],
        "nonMatches": [
            "AB790419",
            "A12790419",
            "ABC791332"
        ],
        "pattern": "^([A-Z|a-z|&]{3})(([0-9]{2})([0][13456789]|[1][012])([0][1-9]|[12][\\d]|[3][0])|([0-9]{2})([0][13578]|[1][02])([0][1-9]|[12][\\d]|[3][01])|([02468][048]|[13579][26])([0][2])([0][1-9]|[12][\\d])|([1-9]{2})([0][2])([0][1-9]|[12][0-8]))(\\w{2}[A|a|0-9]{1})$|^([A-Z|a-z]{4})(([0-9]{2})([0][13456789]|[1][012])([0][1-9]|[12][\\d]|[3][0])|([0-9]{2})([0][13578]|[1][02])([0][1-9]|[12][\\d]|[3][01])|([02468][048]|[13579][26])([0][2])([0][1-9]|[12][\\d])|([1-9]{2})([0][2])([0][1-9]|[12][0-8]))((\\w{2})([A|a|0-9]{1})){0,3}$",
        "title": "Test"
    },
    {
        "description": "Simply match to a combination of 5 characters, using capital letters and numbers only. No special characters or lower case letters.",
        "matches": [
            "AAAA1, 1111A, AW12A"
        ],
        "nonMatches": [
            "aAAAA, 1111a, AAAA, AAAAAA"
        ],
        "pattern": "^([A-Z0-9]{5})$",
        "title": "Test"
    },
    {
        "description": "Validates subnet specified by CIDR notation. A valid CIDR notation begins with the IP address followed by a \u0027/\u0027 character and a decimal number specifying the length, in bits, of the subnet mask or routing prefix (number from 0 to 32).",
        "matches": [
            "192.168.100.1/24",
            "0.0.0.0/0"
        ],
        "nonMatches": [
            "192.168.100.1/33",
            "0.0.0.0/90"
        ],
        "pattern": "/^(([01]?\\d?\\d|2[0-4]\\d|25[0-5])\\.){3}([01]?\\d?\\d|2[0-4]\\d|25[0-5])\\/(\\d{1}|[0-2]{1}\\d{1}|3[0-2])$/",
        "title": "Test"
    },
    {
        "description": "India phone number, accept with optional +91 national code and 0 for land and mobile number prefix . Allows optional - after national code",
        "matches": [
            "+91-9764544544",
            "09764544544",
            "01087656444",
            "+91-1087656444"
        ],
        "nonMatches": [
            "+91-01087656444",
            "+91-09764544544",
            "+9178786765652"
        ],
        "pattern": "^((\\+)?(\\d{2}[-])?(\\d{10}){1})?(\\d{11}){0,1}?$",
        "title": "Test"
    },
    {
        "description": "Matches a latitude in the range of -90 to 90 degrees, with between 1 and 6 trailing decimal places.",
        "matches": [
            "-90.0 -77.284382 89.999999 1.0001"
        ],
        "nonMatches": [
            "-90.1 90.12345 91 -20.1234567 -90 90"
        ],
        "pattern": "^-?([1-8]?[0-9]\\.{1}\\d{1,6}$|90\\.{1}0{1,6}$)",
        "title": "Test"
    },
    {
        "description": "Matches a longitude in the range of -180 to 180 degrees, with between 1 and 6 trailing decimal places.",
        "matches": [
            "-180.0 180.0 -179.010293 1.123456 -45.012 0.12"
        ],
        "nonMatches": [
            "180 -180 180.1 -180.1 0.1234567 190.1"
        ],
        "pattern": "^-?((([1]?[0-7][0-9]|[1-9]?[0-9])\\.{1}\\d{1,6}$)|[1]?[1-8][0]\\.{1}0{1,6}$)",
        "title": "Test"
    },
    {
        "description": "I wanted to get the original size of an image placed into a Wordpress post. This should find the resized image dimensions, from here you should be able to manipulate the size of the image of remove the dimesions to get the image untouched",
        "matches": [
            "image-50x50.jpg"
        ],
        "nonMatches": [
            "image.jpg"
        ],
        "pattern": "-[0-9]*[x][0-9]*",
        "title": "Test"
    },
    {
        "description": "A regexp for general username entry. Which doesn\u0027t allow special characters other than underscore. Username must be of length ranging(3-30). starting letter should be a number or a character.",
        "matches": [
            "fname_lastname, fname, f_name, 1_fname, 1_f"
        ],
        "nonMatches": [
            "_fname, _f, f_ , ff, 11,"
        ],
        "pattern": "^[a-zA-Z0-9][a-zA-Z0-9_]{2,29}$",
        "title": "Test"
    },
    {
        "description": "This regular expression matches the format MM/DD/YYYY. Month and Day can have an optional leading 0. Months are from 01-12, days are from 01-31, and years are from 1000-2999.",
        "matches": [
            "1/1/1999",
            "01/01/2001",
            "12/31/1900"
        ],
        "nonMatches": [
            "00/12/0999",
            "13/1/2000",
            "10/0/2009"
        ],
        "pattern": "^(([0]?[1-9])|(1[0-2]))\\/(([0]?[1-9])|([1,2]\\d{1})|([3][0,1]))\\/[12]\\d{3}$",
        "title": "Test"
    },
    {
        "description": "RE to match numbers with value greater than 0.",
        "matches": [
            "0001",
            "120064",
            "1000000",
            "1"
        ],
        "nonMatches": [
            "0",
            "000000000",
            "0000"
        ],
        "pattern": "^([\\d]*[1-9]+[\\d]*)$",
        "title": "Test"
    },
    {
        "description": "Match a start/end XML tag",
        "matches": [
            "\u003Cxs:complexType name=\u0022includeType\u0022 mixed=\u0022true\u0022\u003E"
        ],
        "nonMatches": [
            "..."
        ],
        "pattern": "(?\u003CSTag\u003E\u003C)[/\\?\\s]*(?\u003CPrefix\u003E\\w*:)*(?\u003CTagName\u003E\\w*)\\s*(?\u003CAttributes\u003E(?\u003CAttribute\u003E((?\u003CAttributePrefix\u003E\\w*)\\s*:\\s*)*(?\u003CAttributeName\u003E\\w*)\\s*=\\s*(?\u003CAttributeValue\u003E\u0022[^\u0022]*\u0022|\u0027[^\u0027]*\u0027|[^\u003E\\s]*)\\s*)*)\\s*/?(?\u003CETag\u003E\u003E)",
        "title": "Test"
    },
    {
        "description": "This is the regex for the bank Swift Number",
        "matches": [
            "NEDSZAJJ, NEDSZAJJXXX, NEDSZAJJ100"
        ],
        "nonMatches": [
            "NEDS ZA JJ, NEDS ZA JJ XXX, NEDS ZA JJ 100"
        ],
        "pattern": "^[a-zA-Z]{4}[a-zA-Z]{2}[a-zA-Z0-9]{2}[XXX0-9]{0,3}",
        "title": "Test"
    },
    {
        "description": "Matches over 18 different combinations for UK phone numbers that I could find. If there are any errors please get in touch.",
        "matches": [
            "0121 111 1111",
            "+44 (0)21 444 4444",
            "07941 111 111",
            "07941 111111",
            "(+44) 121 222 3333"
        ],
        "nonMatches": [
            "0121_111_3333"
        ],
        "pattern": "((\\+44\\s?\\(0\\)\\s?\\d{2,4})|(\\+44\\s?(01|02|03|07|08)\\d{2,3})|(\\+44\\s?(1|2|3|7|8)\\d{2,3})|(\\(\\+44\\)\\s?\\d{3,4})|(\\(\\d{5}\\))|((01|02|03|07|08)\\d{2,3})|(\\d{5}))(\\s|-|.)(((\\d{3,4})(\\s|-)(\\d{3,4}))|((\\d{6,7})))",
        "title": "Test"
    },
    {
        "description": "Displays duration in 1 d 22:33:44 format. Can be modified to match some other formats e.g. 1.22:33:44 if needed. Takes a 24-hour day into account.",
        "matches": [
            "1 d 22:33:44",
            "109 d 11:02:00",
            "0 d 00:00:00"
        ],
        "nonMatches": [
            "d 22:33:44",
            "1 d 24:00:00",
            "3 d 11:75:00"
        ],
        "pattern": "([0-9]+)\\s(d)\\s(([0-1][0-9])|([2][0-3])):([0-5][0-9]):([0-5][0-9])",
        "title": "Test"
    },
    {
        "description": "This will match those string which contains the word \u0022kumar\u0022",
        "matches": [
            "my name is kumar"
        ],
        "nonMatches": [
            "I am mohan"
        ],
        "pattern": "^.*(?:kumar).*$",
        "title": "Test"
    },
    {
        "description": "Multi-part host name validator, RFC-compliant but does not validate length of components or overall length",
        "matches": [
            "localhost www.example.com host-1234.example.com"
        ],
        "nonMatches": [
            "localhost. -1234.example.com"
        ],
        "pattern": "[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*(?:\\.[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*)*",
        "title": "Test"
    },
    {
        "description": "formata\u00E7\u00E3o de placas de carros brasileiros. ************************ Formatting of license plates Brazilian",
        "matches": [
            "HHH1234",
            "hhh1234"
        ],
        "nonMatches": [
            "H1H432A"
        ],
        "pattern": "^(([a-zA-Z]{3})?([0-9]{4}))$",
        "title": "Test"
    },
    {
        "description": "This is a combination of Jerry Schmersahl\u0027s (http://regexlib.com/REDetails.aspx?regexp_id=930) US ZIP Code regex and John Alpha\u0027s (http://regexlib.com/REDetails.aspx?regexp_id=2754) Canadian Postal Code regex. It takes a Canadian postal code with or without a space and matches the first three digits to the named reference \u0027part1\u0027, the second three digits to the named reference \u0027part2\u0027, and the entire code (if a match) to the named reference \u0027full\u0027",
        "matches": [
            "M4S 1G9",
            "M4S1G9",
            "K1A0B1",
            "K1A 0B1"
        ],
        "nonMatches": [
            "123 ABC",
            "5A2A2B",
            "K1A 0B",
            "M4S",
            "90210"
        ],
        "pattern": "^(?\u003Cfull\u003E(?\u003Cpart1\u003E[ABCEGHJKLMNPRSTVXY]{1}\\d{1}[A-Z]{1})(?:[ ](?=\\d))?(?\u003Cpart2\u003E\\d{1}[A-Z]{1}\\d{1}))$",
        "title": "Test"
    },
    {
        "description": "Gets the file name from a URL including the \u0022/\u0022. If the URL ends in \u0022/\u0022 the \u0022/\u0022 is matched.",
        "matches": [
            "/index.htm",
            "/",
            "/default.aspx"
        ],
        "nonMatches": [
            "google.com",
            "hi everybody",
            "\\myFile.txt"
        ],
        "pattern": "(?\u003C!/)/(\\w+\\.\\w+)?$",
        "title": "Test"
    },
    {
        "description": "checks German Street Name with housenumber without Mannheim \u00DCberpr\u00FCft Deutsche Strassennamen mit Hausnummer (ohne Mannheit)",
        "matches": [
            "Kaiserallee 1",
            "Kaiser-Wilhelm-Allee 1111a",
            "M\u00FChlenstr. 33"
        ],
        "nonMatches": [
            "Kaiserallee",
            "Kaiser-Wilhelm-Allee 1aa",
            "1 Kaiserstrasse"
        ],
        "pattern": "^([A-Z\u00C4\u00D6\u00DC][a-z\u00E4\u00F6\u00FC\u00DF]+(([.] )|( )|([-])))+[1-9][0-9]{0,3}[a-z]?$",
        "title": "Test"
    },
    {
        "description": "Strong passwords with min 8 - max 15 character length, at least two letters (not case sensitive), one number, one special character (all, not just defined), space is not allowed.",
        "matches": [
            "\u0026test*81",
            "te$tPa55word",
            "testpass(7"
        ],
        "nonMatches": [
            "mypassword",
            "pass%5",
            "test5324",
            "374833e**"
        ],
        "pattern": "^(?=(.*[a-zA-Z].*){2,})(?=.*\\d.*)(?=.*\\W.*)[a-zA-Z0-9\\S]{8,15}$",
        "title": "Test"
    },
    {
        "description": "General phone number validation for Finland. It will pass old and new format numbers. Between numbers space or dash can be used ones. number has to start +358 or 00358 or 0 are code can be 2 or 3 digit. I could not come with better idea then this",
        "matches": [
            "003589999999",
            "00 358 999 999",
            "00 358 9999 999",
            "00 358 999 9999",
            "091212",
            "09 99 99 99"
        ],
        "nonMatches": [
            "050 999 9999 9999 999",
            "151212"
        ],
        "pattern": "^((([\\+][\\s]{0,1})|([0]{2}[\\s-]{0,1}))([358]{3})([\\s-]{0,1})|([0]{1}))(([1-9]{1}[0-9]{0,1})([\\s-]{0,1})([0-9]{2,4})([\\s-]{0,1})([0-9]{2,4})([\\s-]{0,1}))([0-9]{0,3}){1}$",
        "title": "Test"
    },
    {
        "description": "Strong passwords with min 8 - max 15 character length, at least one uppercase letter, one lowercase letter, one number, one special character (all, not just defined), space is not allowed.",
        "matches": [
            "te$tPa55word",
            "Passw0r",
            ")",
            "Pa$sw0rd"
        ],
        "nonMatches": [
            "\u0026test*81",
            "testpass7*",
            "TestPassw0rd"
        ],
        "pattern": "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d.*)(?=.*\\W.*)[a-zA-Z0-9\\S]{8,15}$",
        "title": "Test"
    },
    {
        "description": "VAT Number BE. Assumes BE followed by 0 or 1 or \u0027\u0027 the digits will grouped by xxxxxxxxxx or xxxx.xxx.xxx. If you only want VAT numbers starting with 0 then replace [0-1]{1} with [0]",
        "matches": [
            "BE 0471.339.727",
            "BE0471.339.727",
            "BE0471339727"
        ],
        "nonMatches": [
            "BE 0471.3397.27",
            "BE 047133972",
            "0471339727"
        ],
        "pattern": "^(BE)[0-1]{1}[0-9]{9}$|^((BE)|(BE ))[0-1]{1}(\\d{3})([.]{1})(\\d{3})([.]{1})(\\d{3})",
        "title": "Test"
    },
    {
        "description": "Matches VALID 10 digit US phone numbers. Formatting characters are optional. Valid area codes and prefixes never begin with 0 or 1.",
        "matches": [
            "9875551212",
            "(987) 555-1212",
            "987-555-1212"
        ],
        "nonMatches": [
            "1234567890",
            "987-123-5555"
        ],
        "pattern": "\\(?(?\u003Careacode\u003E[1]?[2-9]\\d{2})\\)?[\\s-]?(?\u003Cprefix\u003E[2-9]\\d{2})[\\s-]?(?\u003Clinenumber\u003E[\\d]{4})",
        "title": "Test"
    },
    {
        "description": "This was based on the regex in the source but it was buggy so I fixed it and then optimized it. It matches port numbers in the form of :1 to :65535 This is designed to be plugged onto the end of your favourite url regex because when I was looking for a IPv4 regex I noticed that a lot of them either didn\u0027t match the port or matched it badly (allowing the port number to start with a 0 or be higher than 65535) This regex solves those two problems.",
        "matches": [
            ":1",
            ":65535",
            ":2546"
        ],
        "nonMatches": [
            ":99999",
            ":0684",
            ":2ab23"
        ],
        "pattern": ":(6553[0-5]|655[0-2][0-9]\\d|65[0-4](\\d){2}|6[0-4](\\d){3}|[1-5](\\d){4}|[1-9](\\d){0,3})",
        "title": "Test"
    },
    {
        "description": "Regex for validating format of Hungarian phone numbers.",
        "matches": [
            "+3611234567",
            "+3676123456",
            "+36301234567",
            "+36 1 1234567",
            "+36 76 123456 +36 30 1234567",
            "+36(1)1234567",
            "+36(76)123456",
            "+36(30)1234567",
            "1/123-4567",
            "76/123-456",
            "30/123-45-67"
        ],
        "nonMatches": [
            "+0011234567"
        ],
        "pattern": "^(\\+?36)?[ -]?(\\d{1,2}|(\\(\\d{1,2}\\)))/?([ -]?\\d){6,7}$",
        "title": "Test"
    },
    {
        "description": "Accepts positive integers.",
        "matches": [
            "34",
            "1",
            "1000000000"
        ],
        "nonMatches": [
            "-34",
            "-1",
            "-1000000000",
            "34.5",
            "-34.5",
            "34,5",
            "-34,5",
            "34.",
            "34,",
            ".5",
            ",5"
        ],
        "pattern": "^\\d+([^.,])?$",
        "title": "Test"
    },
    {
        "description": "A regex for cellphone numbers in Portugal, for the three major operators (TMN, Optimus, Vodafone). 2 numbers (91/96/93/92) + 7 others.",
        "matches": [
            "965874512 935554789 911234567 924444445"
        ],
        "nonMatches": [
            "950000000 215555555 986655541"
        ],
        "pattern": "^([9]{1})+(6|3|2|1{1})+([0-9]{7})$",
        "title": "Test"
    },
    {
        "description": "Find any and all occurences of any of the three terms \u0022Error\u0022\u0022Warning\u0022\u0022Exception\u0022 in a log or txt file. Use this as a filter with TextAnalysisTool.NET for quick parsing of log files when looking for errors",
        "matches": [
            "2009-11-07 08:04:49.401 UTC Warning w3wp.24 SoapUtilities.CreateException ThrowException: actor = http://servername.subdomain.domain.com:8530/SimpleAuthWebService/SimpleAuth.asmx, ID=9ea54fc1-1351-4fb3-a6a3-ba52d5bd4671, ErrorCode=InternalServerError, Message=, Client=?"
        ],
        "nonMatches": [
            "Any log/text file that does not contain the words in the expression"
        ],
        "pattern": "(?:Error|Warning|Exception)",
        "title": "Test"
    },
    {
        "description": "To parse the above type of detailed date and time format.",
        "matches": [
            "MON NOV 16 16:06:02 2009"
        ],
        "nonMatches": [
            "Mon Nov November Monday 16-06-02"
        ],
        "pattern": "^(\\s(SUN|MON|TUE|WED|THU|FRI|SAT)\\s+(JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)\\s+(0?[1-9]|[1-2][0-9]|3[01])\\s+(2[0-3]|[0-1][0-9]):([0-5][0-9]):((60|[0-5][0-9]))\\s+(19[0-9]{2}|[2-9][0-9]{3}|[0-9]{2}))$",
        "title": "Test"
    },
    {
        "description": "Could not find a regex that truly matched the rules here http://en.wikipedia.org/wiki/Social_Security_number#Valid_SSNs So I modified an existing one to match the valid SSN rules. The first digit set will not match: 000, 666, 734 to 749, and greater than 772. * Numbers with all zeros in any digit group (000-xx-####, ###-00-####, ###-xx-0000)",
        "matches": [
            "455-55-4444",
            "333-22-1111",
            "733-11-1111"
        ],
        "nonMatches": [
            "734-11-1111",
            "749-11-1111",
            "772-11-1111"
        ],
        "pattern": "^((?!000)(?!666)(?:[0-6]\\d{2}|7[0-2][0-9]|73[0-3]|7[5-6][0-9]|77[0-2]))-((?!00)\\d{2})-((?!0000)\\d{4})$",
        "title": "Test"
    },
    {
        "description": "UK Street Address splits streetname and housenumber. Feel free to add more suggestions to help optimize this pattern.",
        "matches": [
            "4-6 Castle Street",
            "85c Main Road",
            "168 Main Road",
            "4 - 6 Castle Street",
            "4A-6B Castle Street",
            "4 - 6B Castle Street"
        ],
        "nonMatches": [
            "none"
        ],
        "pattern": "\\A(\\d+[a-zA-Z]{0,1}\\s{0,1}[-]{1}\\s{0,1}\\d*[a-zA-Z]{0,1}|\\d+[a-zA-Z-]{0,1}\\d*[a-zA-Z]{0,1})\\s*+(.*)",
        "title": "Test"
    },
    {
        "description": "This pattern splits the streetname and housenumber of Dutch Postal Addresses.",
        "matches": [
            "Sophia van Teylingenstraat 19",
            "Abrikozenstraat 116A",
            "Laan van Meerdervoort 1218-1220",
            "Laan van Meerdervoort 1218 - 1220"
        ],
        "nonMatches": [
            "none"
        ],
        "pattern": "\\A(.*?)\\s+(\\d+[a-zA-Z]{0,1}\\s{0,1}[-]{1}\\s{0,1}\\d*[a-zA-Z]{0,1}|\\d+[a-zA-Z-]{0,1}\\d*[a-zA-Z]{0,1})",
        "title": "Test"
    },
    {
        "description": "Simple validation reg ex that requires 1-15 alphanumeric characters",
        "matches": [
            "kazoosoft",
            "tw33tfan",
            "MediaOwls"
        ],
        "nonMatches": [
            "@lpha",
            "bad\\username",
            "badname1234567890"
        ],
        "pattern": "^([a-zA-Z0-9]{1,15})$",
        "title": "Test"
    },
    {
        "description": "I wrote this to parse the querystring into its key value parts. It will also match querystring keys without an associated value. For a nice url parser, look at this one http://regexlib.com/REDetails.aspx?regexp_id=628",
        "matches": [
            "http://www.foo.com/page.aspx?qs1=true\u0026test=foo\u0026bar=true\u0026test#blah"
        ],
        "nonMatches": [
            "http://www.foo.com/page.aspx"
        ],
        "pattern": "(?\u003C=[\\?|\\\u0026])(?\u003Ckey\u003E[^\\?=\\\u0026\\#]+)=?(?\u003Cvalue\u003E[^\\?=\\\u0026\\#]*)",
        "title": "Test"
    },
    {
        "description": "Handles any kind of money entry. With $ sign or not, with commas or not. With bracket, negative sign or none. Max of 2 decimal points. It\u0027s perfect :)",
        "matches": [
            "112.12 $1,112.15 (15555.5) $.12 0.1"
        ],
        "nonMatches": [
            "$111,1.15 52.121 (123.12 s123"
        ],
        "pattern": "^(-?\\$?([1-9]\\d{0,2}(,\\d{3})*|[1-9]\\d*|0|)(.\\d{1,2})?|\\(\\$?([1-9]\\d{0,2}(,\\d{3})*|[1-9]\\d*|0|)(.\\d{1,2})?\\))$",
        "title": "Test"
    },
    {
        "description": "Validates WII Wifi friend codes",
        "matches": [
            "1234-1234-1234-1234"
        ],
        "nonMatches": [
            "12345-1234-1234-1234"
        ],
        "pattern": "(?:[0-9]{4}-){3}[0-9]{4})",
        "title": "Test"
    },
    {
        "description": "This expression matches url that starts with or without http(s)",
        "matches": [
            "http://www.google.com,www.rediff.com,hTtPs:WwW.yahoo.Co.in,http://www.regexlib.com/Add.aspx"
        ],
        "nonMatches": [
            "wwwrediff.com,www..rediff.com"
        ],
        "pattern": "^(((h|H)(t|T))(t|T)(p|P)((s|S)?)\\:\\/\\/)?((www|WWW)+\\.)+(([0-9]{1,3}){3}[0-9]{1,3}\\.|([\\w!~*\u0027()-]+\\.)*([\\w^-][\\w-]{0,61})?[\\w]\\.[a-z]{2,6})(:[0-9]{1,4})?((\\/*)|(\\/+[\\w!~*\u0027().;?:@\u0026=+$,%#-]+)+\\/*)$",
        "title": "Test"
    },
    {
        "description": "This expression validates alphanumeric with one alphabet compulsory and one numeric compulsory and accepts minimum 6 characters and max 15 characters irrespective of the order and case.It doesnt accept special characters",
        "matches": [
            "1DAV100"
        ],
        "nonMatches": [
            "asdfgh,asd.123 etc.,"
        ],
        "pattern": "(?!^[0-9 ]*$)(?!^[a-zA-Z ]*$)^([a-zA-Z0-9 ]{6,15})$",
        "title": "Test"
    },
    {
        "description": "This expression validates urls that starts with http/HTTP/https/HTTPS/ftp/FTP/www/WWW.Its accepts either capital letters or small letters.Address is not case sensitive",
        "matches": [
            "HTTP://www.Rediff.Com"
        ],
        "nonMatches": [
            "HttP://Www.Rediff.Com etc"
        ],
        "pattern": "^((http|HTTP|https|HTTPS|ftp|FTP?)\\:\\/\\/)?((www|WWW)+\\.)+(([0-9]{1,3}){3}[0-9]{1,3}\\.|([\\w!~*\u0027()-]+\\.)*([\\w^-][\\w-]{0,61})?[\\w]\\.[a-z]{2,6})(:[0-9]{1,4})?((\\/*)|(\\/+[\\w!~*\u0027().;?:@\u0026=+$,%#-]+)+\\/*)$",
        "title": "Test"
    },
    {
        "description": "IPV4 and IPV6 address",
        "matches": [
            "10.11.12.13",
            "::1",
            "fe80::2d3d:3489:63e3:35eb"
        ],
        "nonMatches": [
            "3.2.1",
            "1::1::1",
            "1:2:3:4:5:6:7:8:9"
        ],
        "pattern": "^(((([1]?\\d)?\\d|2[0-4]\\d|25[0-5])\\.){3}(([1]?\\d)?\\d|2[0-4]\\d|25[0-5]))|([\\da-fA-F]{1,4}(\\:[\\da-fA-F]{1,4}){7})|(([\\da-fA-F]{1,4}:){0,5}::([\\da-fA-F]{1,4}:){0,5}[\\da-fA-F]{1,4})$",
        "title": "Test"
    },
    {
        "description": "This will accept any 6 digit street address only, with min of two and up to four street names.",
        "matches": [
            "123456 My Street",
            "123 West Main St",
            "12345 Via De La Rosa"
        ],
        "nonMatches": [
            "123 Street",
            "1234 W Side Street"
        ],
        "pattern": "^\\d{1,6}\\040([A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,})$|^\\d{1,6}\\040([A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,})$|^\\d{1,6}\\040([A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,})$",
        "title": "Test"
    },
    {
        "description": "this is usefull for Series of Vehicle Number of Indian Transport",
        "matches": [
            "RJ21-3M"
        ],
        "nonMatches": [
            "RJ21 3M"
        ],
        "pattern": "^([A-Z]{2}\\s?(\\d{2})?(-)?([A-Z]{1}|\\d{1})?([A-Z]{1}|\\d{1}))$",
        "title": "Test"
    },
    {
        "description": "With this expresion you ll be able to extract all the urls of a given text or HTML page. Works fine using the PHP preg_match function",
        "matches": [
            "\u003Ca href=\u0022http://foobar.com\u0022\u003E",
            "Hello world I\u0027m a http://google.fr",
            "Did you mean:http://google.fr/index.php?id=1\u0026b=6#2310"
        ],
        "nonMatches": [
            "http://",
            "http://\u003Cfoobar",
            "www.google.fr"
        ],
        "pattern": "\u0027\u0060.*?((http|ftp|https)://[\\w#$\u0026+,\\/:;=?@.-]+)[^\\w#$\u0026+,\\/:;=?@.-]*?\u0060i\u0027",
        "title": "Test"
    },
    {
        "description": "I think this is the ultimate url match expression to every possible url pattern including named or ip address domain PS: you have got to try RegexBuddy it\u0027s a very cool tool that helps realy http://www.regexbuddy.com",
        "matches": [
            "http://username:password@subdomain1.subdomain2.google.com:5000/test?q=2121ddf\u0026opt=blah#ttg",
            "http://www.test.com/test.htm#ttg",
            "domain.com/?q=test",
            "http://localhost/test",
            "http://127.0.0.1/test",
            "127.0.0.1",
            "me@test.com"
        ],
        "nonMatches": [
            "[test]",
            "opt=blah#ttg",
            "/path?q=test"
        ],
        "pattern": "^(?:(?:http|https|ftp|telnet|gopher|ms\\-help|file|notes)://)?(?:(?:[a-z][\\w~%!&\u0027,;=\\-\\.$\\(\\)\\*\\+]*):.*@)?(?:(?:[a-z0-9][\\w\\-]*[a-z0-9]*\\.)*(?:(?:(?:(?:[a-z0-9][\\w\\-]*[a-z0-9]*)(?:\\.[a-z0-9]+)?)|(?:(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)))(?::[0-9]+)?))?(?:(?:(?:/(?:[\\w\u0060~!$=;\\-\\+\\.\\^\\(\\)\\|\\{\\}\\[\\]]|(?:%\\d\\d))+)*/(?:[\\w\u0060~!$=;\\-\\+\\.\\^\\(\\)\\|\\{\\}\\[\\]]|(?:%\\d\\d))*)(?:\\?[^#]+)?(?:#[a-z0-9]\\w*)?)?$",
        "title": "Test"
    },
    {
        "description": "accepts - Domain name - or ip address",
        "matches": [
            "domain",
            "domain.local",
            "domain124.local",
            "190.200.1.12"
        ],
        "nonMatches": [
            "user@domain",
            "test.domain.local",
            "domain124_.local",
            "localhost:3000"
        ],
        "pattern": "^(?:[a-z0-9][\\w\\-]*[a-z0-9]*\\.)*(?:(?:(?:[a-z0-9][\\w\\-]*[a-z0-9]*)(?:\\.[a-z0-9]+)?)|(?:(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)))$",
        "title": "Test"
    },
    {
        "description": "Mathes all mobile and landline numbers in pakistan",
        "matches": [
            "+92 321 7469854",
            "923217469857",
            "041 2680226"
        ],
        "nonMatches": [
            "00124566",
            "01 922 745689",
            "0000000000"
        ],
        "pattern": "^(\\+)?([9]{1}[2]{1})?-? ?(\\()?([0]{1})?[1-9]{2,4}(\\))?-? ??(\\()?[1-9]{4,7}(\\))?$",
        "title": "Test"
    },
    {
        "description": "Tests expression for DTMF combinations (numbers 0-9, asterisk, octothorpe and A,B,C,D or a,b,c,d). Does not limit number of occurrences or their order.",
        "matches": [
            "*AB132#",
            "12#AB*3",
            "*c3d42a##"
        ],
        "nonMatches": [
            "r13",
            "#bCz31*",
            "*%#"
        ],
        "pattern": "^[0-9#\\*abcdABCD]+$",
        "title": "Test"
    },
    {
        "description": "Parses comma-separated numbers. Doesn\u0027t allow spaces inbetween numbers and/or between numbers and commas. Allows single number to be added. Doesn\u0027t allow sequence to end with a comma.",
        "matches": [
            "1321",
            "1321,0,42412",
            "0,1,2,3,4"
        ],
        "nonMatches": [
            "1321,,42412",
            "12c,13d,23",
            "445,",
            "412 , 421, 4122",
            "42 4,41"
        ],
        "pattern": "^[0-9]+(,[0-9]+)*$",
        "title": "Test"
    },
    {
        "description": "In this Pattern +91 will be the prefix in the Mobile number(of 10 digits).",
        "matches": [
            "+919123456789"
        ],
        "nonMatches": [
            "+91 9123456789,+91-9123456789.. like this"
        ],
        "pattern": "^((\\+){1}91){1}[1-9]{1}[0-9]{9}$",
        "title": "Test"
    },
    {
        "description": "Numbers ranging from 1 through 10",
        "matches": [
            "2, 10 , 1"
        ],
        "nonMatches": [
            "0, 11,2.2,0.21"
        ],
        "pattern": "^[1-9]0?$",
        "title": "Test"
    },
    {
        "description": "This regular expression validates an IP address within the range of 1.0.0.0 to 255.255.255.255",
        "matches": [
            "128.115.12.255, 227.12.14.87, 14.23.120.8"
        ],
        "nonMatches": [
            "111.56.045.78, 221.34.7.8.20, 75.45.301.14"
        ],
        "pattern": "^([1-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3}$",
        "title": "Test"
    },
    {
        "description": "This will accept all the Mobile nos starting with 8 or 9 and having exactly 10 digits (total) or it must be blank",
        "matches": [
            "9323444432,8022234456,8812345678"
        ],
        "nonMatches": [
            "72,54353454,01212,7644321108,79055,asdfg,12ase"
        ],
        "pattern": "^[89][0-9]{9}",
        "title": "Test"
    },
    {
        "description": "Validates dutch (european) date and time combination (dd-mm-yyyy). Dates are accepted, date and time is accepted. The time notation (hh:mm:ss) may or may not contain a value for seconds",
        "matches": [
            "31-12-2009 23:59:59",
            "1-1-2010 10:00",
            "01-01-2010"
        ],
        "nonMatches": [
            "32-12-2009",
            "01-13-2010",
            "01-01-2010 01"
        ],
        "pattern": "^([3]{1}[0-1]{1}|[1-1]?[0-9]{1})-([0-1]?[0-2]{1}|[0-9]{1})-[0-9]{4}([\\s]+([2]{1}[0-3]{1}|[0-1]?[0-9]{1})[:]{1}([0-5]?[0-9]{1})([:]{1}([0-5]?[0-9]{1}))?)?$",
        "title": "Test"
    },
    {
        "description": "This will check to see if the string entered is all digits and is seven digits long. It will allow for leading zeros and also not allow for all zeros to be entered.",
        "matches": [
            "0000001",
            "1234567",
            "0003344"
        ],
        "nonMatches": [
            "000012",
            "12345678",
            "123456A"
        ],
        "pattern": "^(000000[1-9])$|^(00000[1-9][0-9])$|^(0000[1-9][0-9][0-9])$|^(000[1-9][0-9][0-9][0-9])$|^(00[1-9][0-9][0-9][0-9][0-9])$|^(0[1-9][0-9][0-9][0-9][0-9][0-9])$|^([1-9][0-9][0-9][0-9][0-9][0-9][0-9])$",
        "title": "Test"
    },
    {
        "description": "Splits a mysql query file by matching everything but the semicolon at the end. Handles all three comments (\u0022-- \u0022, \u0022#\u0022, \u0022/*...*/\u0022), all three quotes (\u0022, \u0027, \u0060), and all three line break styles (\\r, \\n, \\r\\n). Use with multiline and ignore whitespace/comments.",
        "matches": [
            "load mysql file \u0022share\\mysql_fix_privilege_tables.sql\u0022 for the full effect"
        ],
        "nonMatches": [
            ";"
        ],
        "pattern": "(?: \u0022\u0022(?:(?:(?:\\\\.)|[^\u0022\u0022\\\\\\r\\n])*)\u0022\u0022| #double-quoted strings \u0027(?:(?:(?:\\\\.)|[^\u0027\\\\\\r\\n])*)\u0027| #single-quoted strings \u0060(?:(?:(?:\\\\.)|[^\u0060\\\\\\r\\n])*)\u0060| #backticked names (?:\\s?(?:\\#|--\\ ).*(?=[\\r\\n]))| #hash comments or double-dash comments (?:/\\*(?:(?:[^*]|\\*(?!/))*)\\*/)| #multiline comments (?:[^;\u0060\u0027\u0022\u0022](?!(?:--\\ |\\#|/\\*)))* #everything else not quote or followed by comment (?:[^;\u0060\u0027\u0022\u0022](?=(?:--\\ |\\#|/\\*)))? #that last possible character before that comment )*",
        "title": "Test"
    },
    {
        "description": "Check if the number is a valid italian mobile number. Note: even though 35X is non given yet, this regular expression consider it a valid number just in case it will be!",
        "matches": [
            "+393319991220 ; 00393319991220 ; 3319991220"
        ],
        "nonMatches": [
            "393319991220 ; 331999122044 ;"
        ],
        "pattern": "^(([+]|00)39)?((3[1-6][0-9]))(\\d{7})$",
        "title": "Test"
    },
    {
        "description": "8-20 chars; at least one alpha; at least one number or special char; up to 3 repeating chars, no more",
        "matches": [
            "8charact, twentychar$acters123, 1repppeats"
        ],
        "nonMatches": [
            "6chars, twentychar$acters123456, 1reppppeat, nonummmbers"
        ],
        "pattern": "^(?!.*(.)\\1{3})((?=.*[\\d])(?=.*[A-Za-z])|(?=.*[^\\w\\d\\s])(?=.*[A-Za-z])).{8,20}$",
        "title": "Test"
    },
    {
        "description": "First letter cannot be: D, F, I, Q, U, or V Second letter cannot be: D, F, I, O, Q, U, or V The first two character combinations BG, GB, NK, KN, TN, NT, and ZZ are not used. Followed by 6 digits (0-9) Finished by a suffix: A, B, C, D, F, or M",
        "matches": [
            "JG103759A AP019283D AB103455B SS345603D"
        ],
        "nonMatches": [
            "CK945723N BG103442A NT834238A ZZ834758A"
        ],
        "pattern": "\\b([A-CEGHJ-PR-TW-Z]{1}[A-CEGHJ-NPR-TW-Z]{1}(?\u003C!BG|GB|NK|KN|TN|NT|ZZ))[0-9]{6}[A-DFM]{1}\\b",
        "title": "Test"
    },
    {
        "description": "\u0027Deutsche Telefonnummern\u0027 Matches German phone and fax numbers (including cell phone numbers) in various formats like: 004989123456, +49 89 123456, +49(89)123456, 089-1234-5678, 089 1234 5678, (089)1234-5678 Max. number of digits is 21.",
        "matches": [
            "+49(89)123456",
            "089-1234-5678",
            "(089)1234-5678"
        ],
        "nonMatches": [
            "0049089123456",
            "0172.55555"
        ],
        "pattern": "^(((((((00|\\+)49[ \\-/]?)|0)[1-9][0-9]{1,4})[ \\-/]?)|((((00|\\+)49\\()|\\(0)[1-9][0-9]{1,4}\\)[ \\-/]?))[0-9]{1,7}([ \\-/]?[0-9]{1,5})?)$",
        "title": "Test"
    },
    {
        "description": "Matches South African telephone/mobile numbers, with or without the country code. Can also include spaces or hyphens between values. Doesn\u0027t match brackets around the area code, but that would be easy to add in. Hope it helps someone...",
        "matches": [
            "0111231234",
            "011 123 1234",
            "011-123-1234",
            "0821231234",
            "+27821231234",
            "+2782-123-1234",
            "+2782 123 1234",
            "27111231234",
            "2711 123 1234",
            "2711-123-1234"
        ],
        "nonMatches": [
            "(011)1231234",
            "(+2711) 123 1234",
            "(011) 123-1234"
        ],
        "pattern": "^((?:\\+27|27)|0)(\\d{2})-?(\\d{3})-?(\\d{4})$",
        "title": "Test"
    },
    {
        "description": "a simple expression to validate Persian dates.",
        "matches": [
            "1377/12/4 1388/4/31 1390/6/14 1389/03/1"
        ],
        "nonMatches": [
            "1290/12/2 1388/0/8"
        ],
        "pattern": "^1[34][0-9][0-9]\\/((1[0-2])|([1-9]))\\/(([12][0-9])|(3[01])|[1-9])$",
        "title": "Test"
    },
    {
        "description": "Validate Indonesian \u0022Mobile Numbers Only\u0022 with or without the country code, also base on regular phone number format at http://id.wikipedia.org/wiki/Daftar_kode_telepon_di_Indonesia. This regex only allowed characters that accepted by mobile phone/sms gateway only :D",
        "matches": [
            "+62817737669",
            "62817737669",
            "0817737669",
            "6221995500",
            "021995500",
            "0401998866"
        ],
        "nonMatches": [
            "+817737669",
            "817737669",
            "00817737669",
            "0817 737 669",
            "0817-737-669",
            "021-995500"
        ],
        "pattern": "^((?:\\+62|62)|0)[2-9]{1}[0-9]+$",
        "title": "Test"
    },
    {
        "description": "Useful for validating a basic singleline mathematical expression prior to calculating its value (as with eval). It allows numbers with optional 4 decimals marked with comma. Valid operations: addition, substraction, multiplication, division. Accepts negative numbers. Accepts only round brackets and balances them (.NET ONLY !!!).",
        "matches": [
            "-10/-3,5",
            "((5,4-234556.1)*(0,899/2)-4,6778)",
            "(1)+(-2)+-3*-5"
        ],
        "nonMatches": [
            "10*4,55555",
            "(-10+3)+",
            "-10*95,5+(-3"
        ],
        "pattern": "^ (?: (?\u003E # non backtracking for alternated tokens (?: \\- # \u0022-\u0022 operator (?=\\d|\\() # followed by digit or \u0022(\u0022 ) | (?: (?\u003C=\\d|\\)) # preceded by digit or \u0022)\u0022 (?:\\+|\\/|\\*) # basic operators except \u0022-\u0022 (?=\\d|\\(|\\-) # followed by digit or \u0022(\u0022 or \u0022-\u0022 ) | (?\u003Cparenthesis\u003E # incremente balancing group \u0022parenthesis\u0022 counter (?\u003C=^|\\+|\\/|\\-|\\*|\\() # preceded by start of line or basic operator or \u0022(\u0022 \\( # opening parenthesis \u0022(\u0022 (?=\\d|\\(|\\-) # followed by digit or \u0022-\u0022 or \u0022(\u0022 ) | (?\u003C-parenthesis\u003E # decrement balancing group \u0022parenthesis\u0022 counter (?\u003C=\\d|\\)) # preceded by digit or \u0022)\u0022 \\) # opening parenthesis \u0022)\u0022 (?!\\d) # not followed by digit ) | (?: (?\u003C=\\(|\\-|\\+|\\*|\\/|^) # preceded by start of line or basic operator or \u0022(\u0022 (?:\\d+(?:\\,\\d{1,4})?) # number with optional 4 decimal with comma as decimal marker (?=$|\\)|\\-|\\+|\\*|\\/) # followed by end of line or \u0022)\u0022 or basic operator ) ) + (?(parenthesis)(?!)) # test for balancing group \u0022parenthesis\u0022 counter ) # unnamed group whole expression $",
        "title": "Test"
    },
    {
        "description": "RegEx to match Invalid XML character",
        "matches": [
            "\u0019",
            "\b",
            "\u0010"
        ],
        "nonMatches": [
            "abc",
            "0x007F",
            "xyz"
        ],
        "pattern": "[^\\u0009\\u000A\\u000D\\u0020-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]",
        "title": "Test"
    },
    {
        "description": "Matches any text inside greater than less than characters. Can be used to remove HTML Markup including attributes and comments.",
        "matches": [
            "\u003Cp\u003E\u003Cfont face=\u0022Trebuchet MS\u0022 size=\u00222\u0022\u003Esummary of \u003C/font\u003E\u003C/p\u003E",
            "\u003Cbody\u003E\u003Cfont face=\u0022Trebuchet MS\u0022 size=\u00222\u0022\u003EExample 2\u003C/font\u003E\u003C/body\u003E",
            "\u003C!-- Comment--\u003E"
        ],
        "nonMatches": [
            "Regular Text",
            "Regular Text2",
            "Regular Text3"
        ],
        "pattern": "(\u003C(!--|script)(.|\\n[^\u003C])*(--|script)\u003E)|(\u003C|<)(/?[\\w!?]+)\\s?[^\u003C]*(\u003E|>)|(\\\u0026[\\w]+\\;)",
        "title": "Test"
    },
    {
        "description": "This should require all of the following: An uppercase letter, a lowercase letter, a number and a special character from the provided list. Lastly, it needs to be between 8 and 20 characters long. A lot of expressions I\u0027ve found here don\u0027t require all four, this should. I\u0027m pretty new at regex though, so I hope that other people will help strengthen this expression. When testing on this site, make sure you have the Case Insensitive checkbox turned off.",
        "matches": [
            "p2sSw@rd",
            "p2sSw@rd#l0ngEr",
            "abc#$%GH1"
        ],
        "nonMatches": [
            "p2ssw@rd",
            "p2sSw@rd#l0ngErThisIs2l0ng",
            "abc123DEF"
        ],
        "pattern": "^(?=.*[!@#$%^\u0026*()\\-_=+\u0060~\\[\\]{}?|])(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9]).{8,20}$",
        "title": "Test"
    },
    {
        "description": "Hexadecimal color values to validate the system must begin with a # symbol, which can be combination of numbers and letters AF, but the letters must be uppercase.",
        "matches": [
            "#000000",
            "#FFFFFF",
            "#000FFF",
            "#FFF000",
            "#A1B2C3"
        ],
        "nonMatches": [
            "#ffffff",
            "#ABC",
            "#123",
            "#AJKSDD",
            "#a1b2c3",
            "abcdef",
            "123456"
        ],
        "pattern": "^#(\\d{6})|^#([A-F]{6})|^#([A-F]|[0-9]){6}",
        "title": "Test"
    },
    {
        "description": "This expression extract all class names from a php source code. E.g. it will extract A from the following declarations",
        "matches": [
            "class A {}",
            "class A extends B {}",
            "class A extends B implements C {}",
            "class A extends B implements C,D {}",
            "class A implements B {}",
            "class A implements B,C {}"
        ],
        "nonMatches": [
            "class A implements B extends C (invalid PHP syntax)"
        ],
        "pattern": "/class\\s+([a-z0-9_]+)(?:\\s+extends\\s+[a-z0-9_]+)?(?:\\s+implements\\s+(?:[a-z0-9_]+\\s*,*\\s*)+)?\\s*\\{/Usi",
        "title": "Test"
    },
    {
        "description": "Regular Expression matches any internet URLs. Used with the replace method it comes in very handy.",
        "matches": [
            "https://yahoo.com http://www.yahoo.com/ http://www.google.com/search?q=good+url+regex https://ajay.com?query https://google.com http://kdsir.co.in http://qa.re.com/no_session.jsp www.yahoo.co.in"
        ],
        "nonMatches": [
            "https://yahoo yahoo.com/ kushagra.co.in ht://google.com htp://google.co"
        ],
        "pattern": "(https:[/][/]|http:[/][/]|www.)[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,3}(:[a-zA-Z0-9]*)?/?([a-zA-Z0-9\\-\\._\\?\\,\\\u0027/\\\\\\+&%\\$#\\=~])*$",
        "title": "Test"
    },
    {
        "description": "Checks all Iban numbers on the first 2 characters example NL has 18 characters less or more is not allowed",
        "matches": [
            "NL02 RABO 5678 9012 3456"
        ],
        "nonMatches": [
            "NL02 RABO 5678 9012 345, NL02 RABO 5678 9012 3456 7, NL02RABO567890123456, nl02 rabo 5678 9012 3456"
        ],
        "pattern": "^((NO)[0-9A-Z]{2}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{3}|(NO)[0-9A-Z]{15}|(BE)[0-9A-Z]{2}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}|(BE)[0-9A-Z]{16}|(DK|FO|FI|GL|NL)[0-9A-Z]{2}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{2}|(DK|FO|FI|GL|NL)[0-9A-Z]{18}|(MK|SI)[0-9A-Z]{2}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{3}|(MK|SI)[0-9A-Z]{19}|(BA|EE|KZ|LT|LU|AT)[0-9A-Z]{2}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}|(BA|EE|KZ|LT|LU|AT)[0-9A-Z]{20}|(HR|LI|LV|CH)[0-9A-Z]{2}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{1}|(HR|LI|LV|CH)[0-9A-Z]{21}|(BG|DE|IE|ME|RS|GB)[0-9A-Z]{2}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{2}|(BG|DE|IE|ME|RS|GB)[0-9A-Z]{22}|(GI|IL)[0-9A-Z]{2}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{3}|(GI|IL)[0-9A-Z]{23}|(AD|CZ|SA|RO|SK|ES|SE|TN)[0-9A-Z]{2}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}|(AD|CZ|SA|RO|SK|ES|SE|TN)[0-9A-Z]{24}|(PT)[0-9A-Z]{2}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{1}|(PT)[0-9A-Z]{25}|(IS|TR)[0-9A-Z]{2}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{2}|(IS|TR)[0-9A-Z]{26}|(FR|GR|IT|MC|SM)[0-9A-Z]{2}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{3}|(FR|GR|IT|MC|SM)[0-9A-Z]{27}|(AL|CY|HU|LB|PL)[0-9A-Z]{2}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}|(AL|CY|HU|LB|PL)[0-9A-Z]{28}|(MU)[0-9A-Z]{2}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{2}|(MU)[0-9A-Z]{30}|(MT)[0-9A-Z]{2}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{3}|(MT)[0-9A-Z]{31})$",
        "title": "Test"
    },
    {
        "description": "Manually derived this from the grammar in Appendix A of RFC3986 (Uniform Resource Identifier (URI): Generic Syntax). Matches anything that fits the generic syntax of a URI. Supports IPv6 hosts.",
        "matches": [
            "http://user:pwd@domain.com:123/dir/subdir/?qp1=v%d3\u0026qp2=98#frag",
            "http://192.168.0.0:123/dir/subdir/?qp1=v%d3\u0026qp2=98#frag",
            "svn+ssh://[D456::1234:4321]:123/dir/subdir/?qp1=v%d3\u0026qp2=98#frag"
        ],
        "nonMatches": [
            "http://user:pwddomain.com:123/dir/subdir/?qp1=v%d3\u0026qp2=98#frag",
            "http://192.168.0.0:123/dir/subdir/?qp1=v%d\u0026qp2=98#frag",
            "svn+ssh://[D456::12344321]:123/dir/subdir/?qp1=v%d3\u0026qp2=98#frag"
        ],
        "pattern": "^([a-zA-Z][a-zA-Z0-9+-.]*):((\\/\\/(((([a-zA-Z0-9\\-._~!$\u0026\u0027()*+,;=\u0027:]|(%[0-9a-fA-F]{2}))*)@)?((\\[((((([0-9a-fA-F]{1,4}:){6}|(::([0-9a-fA-F]{1,4}:){5})|(([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:){4})|((([0-9a-fA-F]{1,4}:)?[0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:){3})|((([0-9a-fA-F]{1,4}:){0,2}[0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:){2})|((([0-9a-fA-F]{1,4}:){0,3}[0-9a-fA-F]{1,4})?::[0-9a-fA-F]{1,4}:)|((([0-9a-fA-F]{1,4}:){0,4}[0-9a-fA-F]{1,4})?::))((([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4}))|(([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5]))\\.([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5]))\\.([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5]))\\.([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5])))))|((([0-9a-fA-F]{1,4}:){0,5}[0-9a-fA-F]{1,4})?::[0-9a-fA-F]{1,4})|((([0-9a-fA-F]{1,4}:){0,5}[0-9a-fA-F]{1,4})?::))|(v[0-9a-fA-F]+\\.[a-zA-Z0-9\\-._~!$\u0026\u0027()*+,;=\u0027:]+))\\])|(([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5]))\\.([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5]))\\.([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5]))\\.([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5])))|(([a-zA-Z0-9\\-._~!$\u0026\u0027()*+,;=\u0027]|(%[0-9a-fA-F]{2}))*))(:[0-9]*)?)((\\/([a-zA-Z0-9\\-._~!$\u0026\u0027()*+,;=\u0027:@]|(%[0-9a-fA-F]{2}))*)*))|(\\/?(([a-zA-Z0-9\\-._~!$\u0026\u0027()*+,;=\u0027:@]|(%[0-9a-fA-F]{2}))+(\\/([a-zA-Z0-9\\-._~!$\u0026\u0027()*+,;=\u0027:@]|(%[0-9a-fA-F]{2}))*)*)?))(\\?(([a-zA-Z0-9\\-._~!$\u0026\u0027()*+,;=\u0027:@\\/?]|(%[0-9a-fA-F]{2}))*))?((#(([a-zA-Z0-9\\-._~!$\u0026\u0027()*+,;=\u0027:@\\/?]|(%[0-9a-fA-F]{2}))*)))?$",
        "title": "Test"
    },
    {
        "description": "This expression will match all positive numbers that contain decimals and commas.",
        "matches": [
            "2,000.00, 2,000, .0020, 100, 100.00"
        ],
        "nonMatches": [
            "0, 0.00, -100.00, -0, -2000.00"
        ],
        "pattern": "(^(\\d|,)*\\.?\\d*[1-9]+\\d*$)|(^[1-9]+(\\d|,)*\\.\\d*$)|(^[1-9]+(\\d|,)*\\d*$)",
        "title": "Test"
    },
    {
        "description": "Allows for all kinds of generic international phone numbers, including that of the USA, may include () around area code as well as period, dash, space or nothing seperating numbers. International code needs to be seperated from rest by period, space or dash and my be prefixed with plus. Not overly restrictive but limits size and repetition of codes",
        "matches": [
            "2155552527",
            "(215) 555 2527",
            "215.555.2527",
            "+1 215-555-2527",
            "+1.215.555.2527"
        ],
        "nonMatches": [
            "+1215.555.2527",
            "321654",
            "+11+27 215-555-2527"
        ],
        "pattern": "^((\\+)?[1-9]{1,2})?([-\\s\\.])?((\\(\\d{1,4}\\))|\\d{1,4})(([-\\s\\.])?[0-9]{1,12}){1,2}$",
        "title": "Test"
    },
    {
        "description": "Check the Dutch postal code offical format of \u00229999 AA\u0022. Since it is often stored in a database without the space, this pattern allows 0 or 1 space.",
        "matches": [
            "9999 AA",
            "9999AA"
        ],
        "nonMatches": [
            "9999 aa",
            "9999?AA"
        ],
        "pattern": "^[0-9]{4} {0,1}[A-Z]{2}$",
        "title": "Test"
    },
    {
        "description": "Expression for validation of one or more emails separated by semicolon(;) -- Express\u00E3o para valida\u00E7\u00E3o de um ou mais emails separados por ponto e v\u00EDrgula(;)",
        "matches": [
            "renanxr3@hotmail.com;renanxr2@hotmail.com"
        ],
        "nonMatches": [
            "[renanxr3@hotmail.com; renanxr2@hotmail.com;] [renanxr3@hotmail.comrenanxr2@hotmail.com;]"
        ],
        "pattern": "\u0022^([a-z0-9,!#\\$%\u0026\u0027\\*\\+/=\\?\\^_\u0060\\{\\|}~-]+(\\.[a-z0-9,!#\\$%\u0026\u0027\\*\\+/=\\?\\^_\u0060\\{\\|}~-]+)*@[a-z0-9-]+(\\.[a-z0-9-]+)*\\.([a-z]{2,})){1}(;[a-z0-9,!#\\$%\u0026\u0027\\*\\+/=\\?\\^_\u0060\\{\\|}~-]+(\\.[a-z0-9,!#\\$%\u0026\u0027\\*\\+/=\\?\\^_\u0060\\{\\|}~-]+)*@[a-z0-9-]+(\\.[a-z0-9-]+)*\\.([a-z]{2,}))*$\u0022",
        "title": "Test"
    },
    {
        "description": "Matches valid Medicare HIC number according to CMS specifications",
        "matches": [
            "H123456",
            "XYZ123456789",
            "123456789B"
        ],
        "nonMatches": [
            "H123",
            "H999999",
            "H1234XB"
        ],
        "pattern": "(?![A-Z](\\d)\\1{5,})(^[A-Z]{1,3}(\\d{6}|\\d{9})$)|(^\\d{9}[A-Z][0-9|A-Z]?$)",
        "title": "Test"
    },
    {
        "description": "SUMMARY: Very selective email address Regex USE: intended for finding emails in text. DETAILS: regex is terminated by a match for all possible Top-Level-Domains, so regex can even differentiate the terminating end of the email string from other text (including letters)",
        "matches": [
            "bob.wintson@hotmail.combob.wintson@middlesex.lenovix.combob.c.wintson@mysite.middlesex.hotmail.combob_c_wintson@mysite.middlesex.hotmail.com"
        ],
        "nonMatches": [
            "bob_d_c_wintson@mysite.middlesex.hotmail.combob_c_wintson@mysite.middlesex.hotmail.cop"
        ],
        "pattern": "[a-z0-9]+([-+._][a-z0-9]+){0,2}@.*?(\\.(a(?:[cdefgilmnoqrstuwxz]|ero|(?:rp|si)a)|b(?:[abdefghijmnorstvwyz]iz)|c(?:[acdfghiklmnoruvxyz]|at|o(?:m|op))|d[ejkmoz]|e(?:[ceghrstu]|du)|f[ijkmor]|g(?:[abdefghilmnpqrstuwy]|ov)|h[kmnrtu]|i(?:[delmnoqrst]|n(?:fo|t))|j(?:[emop]|obs)|k[eghimnprwyz]|l[abcikrstuvy]|m(?:[acdeghklmnopqrstuvwxyz]|il|obi|useum)|n(?:[acefgilopruz]|ame|et)|o(?:m|rg)|p(?:[aefghklmnrstwy]|ro)|qa|r[eosuw]|s[abcdeghijklmnortuvyz]|t(?:[cdfghjklmnoprtvwz]|(?:rav)?el)|u[agkmsyz]|v[aceginu]|w[fs]|y[etu]|z[amw])\\b){1,2}",
        "title": "Test"
    },
    {
        "description": "Validates US VIN. It could be between 10 and 17 character in length and should never contain i, l, o, O, q, Q, \u0027 or -.",
        "matches": [
            "12345awertasfggr"
        ],
        "nonMatches": [
            "12345qwertasfggr"
        ],
        "pattern": "^[^iIoOqQ\u0027-]{10,17}$",
        "title": "Test"
    },
    {
        "description": "I am using a repeating section to provide multi email check wherein the separator can be either a comma or a semi-colon. whitespaces are allowed after a delimiter.",
        "matches": [
            "elvis@mywebsite.com",
            "elvis@mywebsite.com;me@mywebsite.com",
            "elvis@mywebsite.com,me@mywebsite.com, elvis.furtado@mywebsite.net",
            "newyork@sydneyUniv.gov.us,elvis@mywebsite.com;me@mywebsite.com"
        ],
        "nonMatches": [
            "elvis@@mywebsite.com",
            "elvis@@mywebsite.c",
            "elvis @mywebsite.com.in.org"
        ],
        "pattern": "^(?:(?:[\\w\\.\\-_]+@[\\w\\d]+(?:\\.[\\w]{2,6})+)[,;]?\\s?)+$",
        "title": "Test"
    },
    {
        "description": "Intended for single line. JavaScript match() method (or equivalent) creates an array of values each of which is either an unquoted string of non-whitespace chars, or a quoted string which can contain whitespace, escaped quotes (\\\u0027 or \\\u0022), escaped escaped chars (\\\\), or be empty (\u0027\u0027 or \u0022\u0022). Splits on whitespace AND splits on opening and closing quotes. An unclosed quote matches all until end of input. The Matching Example is ready for enclosure in single quotes. Output of Matching Example: [0]=a [1]=\u0027 b\u0022\\\u0027b \u0027 [2]=\u0027b2\u0027 [3]=\u0022c\\\u0022\u0027c\u0022 [4]=\u0022d",
        "matches": [
            "a \\\u0027 b\u0022\\\\\\\u0027b \\\u0027\\\u0027b2\\\u0027\u0022c\\\\\u0022\\\u0027c\u0022\u0022d"
        ],
        "nonMatches": [
            "only strings with \u003C1 non-whitespace char"
        ],
        "pattern": "/\u0022(\\\\[\u0022\\\\]|[^\u0022])*(\u0022|$)|\u0027(\\\\[\u0027\\\\]|[^\u0027])*(\u0027|$)|(\\\\[\u0022\u0027\\\\]|[^\\s\u0022\u0027])+/g",
        "title": "Test"
    },
    {
        "description": "All emails listed below are to be created and You can try all of them on the domain name listed!",
        "matches": [
            "a12.__.--@live.com",
            "info@1234.com"
        ],
        "nonMatches": [
            "1test@gmail.com",
            "test.@yahoo.com",
            "test@test_test.com"
        ],
        "pattern": "^[A-Za-z0-9](\\.[\\w\\-]|[\\w\\-][\\w\\-])(\\.[\\w\\-]|[\\w\\-]?[\\w\\-]){0,30}[\\w\\-]?@[A-Za-z0-9\\-]{3,63}\\.[a-zA-Z]{2,6}$",
        "title": "Test"
    },
    {
        "description": "Telephone and Mobile number for the Maltese islands including an optional 00356 for country code",
        "matches": [
            "0035621223344",
            "0035679776655",
            "99887766"
        ],
        "nonMatches": [
            "35621223344",
            "88776655",
            "0035655"
        ],
        "pattern": "/(00356)?(99|79|77|21|27|22|25)[0-9]{6}/g",
        "title": "Test"
    },
    {
        "description": "this expression is one of the best username regular expressions",
        "matches": [
            "a.f",
            "joe",
            "mehdi2_ghasemi",
            "mr-green123"
        ],
        "nonMatches": [
            "a._f",
            "1mehdi",
            "ab",
            "mehdi..ghasemi",
            "mehdi_"
        ],
        "pattern": "[A-Za-z](\\.[A-Za-z0-9]|\\-[A-Za-z0-9]|_[A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9])(\\.[A-Za-z0-9]|\\-[A-Za-z0-9]|_[A-Za-z0-9]|[A-Za-z0-9])*",
        "title": "Test"
    },
    {
        "description": "Validates a Philippine mobile phone number without International code. Includes country\u0027s six area codes for mobile phones: Express Telecom, Globe Telecom, Next Mobile, Red Mobile, Smart Communications and Sun Cellular",
        "matches": [
            "09171234567",
            "0905 123 4567"
        ],
        "nonMatches": [
            "+639111111",
            "09011234567",
            "0915 1234 23 2"
        ],
        "pattern": "^09(73|74|05|06|15|16|17|26|27|35|36|37|79|38|07|08|09|10|12|18|19|20|21|28|29|30|38|39|89|99|22|23|32|33)\\d{3}\\s?\\d{4}",
        "title": "Test"
    },
    {
        "description": "This regex matches all (14.095.120.151.883.281.746.489.830.170.974.347.714.655.937) valid IPv6 address _representations_ as described by RFC 4291. Current regex is valid for PCRE only, for Perl/Java/Ruby/Phython/.NET/ECMA(JavaScript)/XML specific regex visit http://home.deds.nl/~aeron/regex/",
        "matches": [
            "1:2:3:4:5:6:7:8",
            "1:2:3:4:5:6:1.2.3.4",
            "1::8",
            "1::1.2.3.4",
            "::",
            "::1.2.3.4",
            "0000:000:00:0::0.0.0.0"
        ],
        "nonMatches": [
            "::01.02.03.04",
            "::001.002.003.004",
            "::011.022.033.044"
        ],
        "pattern": "/^(((?=.*(::))(?!.*\\3.+\\3))\\3?|([\\dA-F]{1,4}(\\3|:\\b|$)|\\2))(?4){5}((?4){2}|(((2[0-4]|1\\d|[1-9])?\\d|25[0-5])\\.?\\b){4})\\z/i",
        "title": "Test"
    },
    {
        "description": "http://en.wikipedia.org/wiki/National_Drug_Code",
        "matches": [
            "1234-5678-90",
            "12345-678-90",
            "12345-6789-0",
            "49981-*007-01"
        ],
        "nonMatches": [
            "1234-56-8-90",
            "123-45678-90",
            "1-345-6789-0"
        ],
        "pattern": "\\d{4}-\\d{4}-\\d{2}|\\d{5}-\\d{3}-\\d{2}|\\d{5}-\\d{4}-\\d{1}|\\d{5}-\\*\\d{3}-\\d{2}",
        "title": "Test"
    },
    {
        "description": "US IRS Employee ID Number, aka Federal Tax ID Number",
        "matches": [
            "01-1234567, 011234567"
        ],
        "nonMatches": [
            "00-1234567, 49-1234567, 123-45-6789"
        ],
        "pattern": "^([07][1-7]|1[0-6]|2[0-7]|[35][0-9]|[468][0-8]|9[0-589])-?\\d{7}$",
        "title": "Test"
    },
    {
        "description": "Its 10 digits Indian Mobile Number validation.",
        "matches": [
            "9829373514"
        ],
        "nonMatches": [
            "919829373514, 09829373514"
        ],
        "pattern": "^([9]{1})([234789]{1})([0-9]{8})$",
        "title": "Test"
    },
    {
        "description": "This is just a simple US states and territories in 2 character regex. Requires valid 2 letter abbreviations. It accepts the Lower and Upper Case Entries.",
        "matches": [
            "MN",
            "tx",
            "Tx"
        ],
        "nonMatches": [
            "M",
            "23",
            "Alaska",
            "zz"
        ],
        "pattern": "^([Aa][LKSZRAEPlkszraep]|[Cc][AOTaot]|[Dd][ECec]|[Ff][LMlm]|[Gg][AUau]|[Hh][Ii]|[Ii][ADLNadln]|[Kk][SYsy]|[Ll][Aa]|[Mm][ADEHINOPSTadehinopst]|[Nn][CDEHJMVYcdehjmvy]|[Oo][HKRhkr]|[Pp][ARWarw]|[Rr][Ii]|[Ss][CDcd]|[Tt][NXnx]|[Uu][Tt]|[Vv][AITait]|[Ww][AIVYaivy])$",
        "title": "Test"
    },
    {
        "description": "Focused on the website url validation",
        "matches": [
            "www.domain.com, http://www.domain.com,http://domain.com, www.domain.co.cc"
        ],
        "nonMatches": [
            "domain.com, domain"
        ],
        "pattern": "^((http:\\/\\/www\\.)|(www\\.)|(http:\\/\\/))[a-zA-Z0-9._-]+\\.[a-zA-Z.]{2,5}$",
        "title": "Test"
    },
    {
        "description": "Parses a C++ function, including return type, declaration type, namespace, class, method, exposure (public, private, protected) and params.",
        "matches": [
            "public: void __thiscall myClass::method(int, class myOtherClass * )",
            "public: void __thiscall myNamespace::myClass::method(void)",
            "protected: class std::string __cdecl Library::Class::Method(class Param *, enum Type \u0026 const)"
        ],
        "nonMatches": [
            "myfunc(3)",
            "object::myFunc(9, 4)",
            "object-\u003Emethod(var)"
        ],
        "pattern": "(?\u003Cexpo\u003Epublic\\:|protected\\:|private\\:) (?\u003Cret\u003E(const )*(void|int|unsigned int|long|unsigned long|float|double|(class .*)|(enum .*))) (?\u003Cdecl\u003E__thiscall|__cdecl|__stdcall|__fastcall|__clrcall) (?\u003Cns\u003E.*)\\:\\:(?\u003Cclass\u003E(.*)((\u003C.*\u003E)*))\\:\\:(?\u003Cmethod\u003E(.*)((\u003C.*\u003E)*))\\((?\u003Cparams\u003E((.*(\u003C.*\u003E)?)(,)?)*)\\)",
        "title": "Test"
    },
    {
        "description": "Used in my SVG parser. Explanation: May start with + or -. This is followed by either an integer, or a float (\u0022dot numbers\u0022, \u0022numbers dot numbers\u0022 or \u0022numbers dot\u0022 followed by an optional scientific postfix (+ or - followed by numbers) ) I\u0027m using it to parse lists of floats, add ^$ boundaries if you want it to match whole lines.",
        "matches": [
            "10.2",
            ".0",
            "3.9265e+2",
            "5"
        ],
        "nonMatches": [
            "-one",
            ".",
            "whatever"
        ],
        "pattern": "[-+]?((\\.[0-9]+|[0-9]+\\.[0-9]+)([eE][-+][0-9]+)?|[0-9]+)",
        "title": "Test"
    },
    {
        "description": "This expression shows result for the alphanumeric value starts with only alpha bates.",
        "matches": [
            "shailesh123,shailesh,s123ailesh"
        ],
        "nonMatches": [
            "123shailesh,1Shailesh123"
        ],
        "pattern": "^([a-zA-Z][a-zA-Z0-9]{1,100})$",
        "title": "Test"
    },
    {
        "description": "Needing a way to shrink HTML based email to the smallest amount of characters, we wanted to remove any extra unnecessary white space characters in attributes such as style. This finds any space with a proceeding comma, semi-colon, or colon, and then checks with a lookahead for the closing \u003E with a negative lookbehind to make sure that a \u003C opening does not exist. The secondary trailing look behind is done to make sure that it does not change any content contained in the element.",
        "matches": [
            "\u003Ctable width=\u0022750px\u0022 cellpadding=\u00220\u0022 cellspacing=\u00220\u0022 style=\u0022font-family: Arial , Helvetica , Sans-Serif ; font-size: 10pt;\u0022\u003E"
        ],
        "nonMatches": [
            "\u003Ctd\u003E1, 2, 3\u003C/td\u003E"
        ],
        "pattern": "(?\u003C=(,|;|:))\\s(?=((?:(?!\u003C).)*\u003E))",
        "title": "Test"
    },
    {
        "description": "Limited by proper dialing codes as per http://en.wikipedia.org/wiki/Telephone_numbers_in_South_Africa. It will match phone numbers in most common formats that users normally type their phone number. Tested with Perl engine regex in PHP.",
        "matches": [
            "+27121234567 +2712 123 4567 012 123 4567 (012) 123 4567 (012) 123-4567"
        ],
        "nonMatches": [
            "27621234567"
        ],
        "pattern": "^(?:(?:\\(|)0|\\+27|27)(?:1[12345678]|2[123478]|3[1234569]|4[\\d]|5[134678])(?:\\) | |-|)\\d{3}(?: |-|)\\d{4}$",
        "title": "Test"
    },
    {
        "description": "Get all images in html string, ignore white space, tabs and is case insensitive. the result is iMG sRc =\u0022ricardo.gif, after this just split the string and Enjoy it!",
        "matches": [
            "\u0022\u003Chtml\u003E\u003CiMG sRc = \\\u0022ricardo.gif\\\u0022 alt=\\\u00221\\\u0022/\u003E\u003Cimg src=\\\u0022whatever.gif\\\u0022 /\u003E\u003Cimg src =\\\u0022teste.gif\\\u0022 alt=\\\u00221\\\u0022/\u003E\u003C/html\u003E\u0022"
        ],
        "nonMatches": [
            "i don\u00B4t know"
        ],
        "pattern": "\u0022\u003C[ \\t]*[iI][mM][gG][ \\t]*[sS][rR][cC][ \\t]*=[ \\t]*[\u0027\\\u0022]([^\u0027\\\u0022]+)\u0022",
        "title": "Test"
    },
    {
        "description": "divides an url into the different parts: protocol, subdomain, tld, port, folder, file, anchor, parameter",
        "matches": [
            "http://www.example.com/folder/file.php#anchor?parameter=value"
        ],
        "nonMatches": [
            "www.example.com"
        ],
        "pattern": "(http|ftp|https):\\/\\/(\\w[\\w\\-_\\.]*\\.)?([_\\-\\w]+)(:[0-9]+)?([\\/[\\w_\\.-]+]*)\\/(\\.?\\w[\\w._-]*[\\w_-])?(#\\w+)?([\\w\\-\\.,@?^=%&:\\~\\+#]*[\\w\\-\\@?^=%&\\/\\~\\+#])?",
        "title": "Test"
    },
    {
        "description": "This .NET regular expression matches all valid dates in dd/MM/yyyy , dd-MM-yyyy or dd MM yyyy formats between 1/1/0000 and 31/12/9999 with the leading zero for the day and month portions being optional. The century for the year is optional for all dates except for the 29th of February of century years divisible by 400. This expression also validates the 29th of February for leap years, defined as (year % 4 == 0 \u0026\u0026 year % 100 != 0) || (year % 400 == 0).",
        "matches": [
            "29-2-2000",
            "31/12/9999",
            "1 1 0000",
            "29/02/0000",
            "8/3/9841"
        ],
        "nonMatches": [
            "29/2/1900",
            "29/02/2001",
            "31/04/2000",
            "28/02-1934",
            "1/13/1978"
        ],
        "pattern": "^\\s*((31([-/ ])((0?[13578])|(1[02]))\\3(\\d\\d)?\\d\\d)|((([012]?[1-9])|([123]0))([-/ ])((0?[13-9])|(1[0-2]))\\12(\\d\\d)?\\d\\d)|(((2[0-8])|(1[0-9])|(0?[1-9]))([-/ ])0?2\\22(\\d\\d)?\\d\\d)|(29([-/ ])0?2\\25(((\\d\\d)?(([2468][048])|([13579][26])|(0[48])))|((([02468][048])|([13579][26]))00))))\\s*$",
        "title": "Test"
    },
    {
        "description": "Allows only positive integers that are greater than 0. Also allows for infinite zeros leading the integer Based on William Powell\u0027s Pattern Title, but modified to allow for leading zeros.",
        "matches": [
            "1",
            "12",
            "124",
            "01",
            "0012",
            "000124"
        ],
        "nonMatches": [
            "-1",
            "a",
            "1.0",
            "0000"
        ],
        "pattern": "^[0-9]*[1-9]+[0-9]*$",
        "title": "Test"
    },
    {
        "description": "Pattern to verify Codice Fiscale Italiano (TIN, Tax Identification Number). Include verification of Codice Fiscale to natural, artificial, legal and juristic person, with and without OMOCODIA (verifica del codice fiscale per persone fisiche e persone giuridiche, anche in caso di omocodia). Codice Fiscale, CF, omocodia, persone fisiche, persone giuridiche, italian fiscal code, TIN, Tax Identification Number.",
        "matches": [
            "VRDGPP13R10B293P",
            "VRDGPP13R10B29PP",
            "12345678901"
        ],
        "nonMatches": [
            "VRDGPP13R10B293",
            "VRDGPP13R10B29BP",
            "1234567890"
        ],
        "pattern": "^([A-Za-z]{6}[0-9lmnpqrstuvLMNPQRSTUV]{2}[abcdehlmprstABCDEHLMPRST]{1}[0-9lmnpqrstuvLMNPQRSTUV]{2}[A-Za-z]{1}[0-9lmnpqrstuvLMNPQRSTUV]{3}[A-Za-z]{1})|([0-9]{11})$",
        "title": "Test"
    },
    {
        "description": "Pattern to verify email addresses. Take a look at match / not match. It works very well. E-mail, email, mail, e-mail address, email address, mail address.",
        "matches": [
            "john-smith@example.com",
            "john.smith@example.com",
            "john_smith@x-ample.com"
        ],
        "nonMatches": [
            ".john-smith@example.com",
            "@example.com",
            "johnsmith@example."
        ],
        "pattern": "^[0-9a-zA-Z]+([0-9a-zA-Z]*[-._+])*[0-9a-zA-Z]+@[0-9a-zA-Z]+([-.][0-9a-zA-Z]+)*([0-9a-zA-Z]*[.])[a-zA-Z]{2,6}$",
        "title": "Test"
    },
    {
        "description": "allows validation of phone numbers in different formats, including local dialing code (eg 033 or 076) or international dialing code in the formats +12 or 0012 or 0912.",
        "matches": [
            "073-386-2612 , 0443862612 , 076 858 7777 , +27 76 858 7777 , 0027 765877777 , 0956 33 8881234"
        ],
        "nonMatches": [
            "invalid numbers"
        ],
        "pattern": "[0](\\d{9})|([0](\\d{2})( |-|)((\\d{3}))( |-|)(\\d{4}))|[0](\\d{2})( |-|)(\\d{7})|(\\+|00|09)(\\d{2}|\\d{3})( |-|)(\\d{2})( |-|)((\\d{3}))( |-|)(\\d{4})",
        "title": "Test"
    },
    {
        "description": "This could be most complete and readable URL-finder regex. I built it from several good examples. Works with PHP preg_match_all(). Finds whatever string that resembles a URL with scheme://, user:password, subdomains.domain (with up to 6 chars top-domain) or IP address xxx.xxx.xxx.xxx, :port, /file/path/, ?request, and #anchor",
        "matches": [
            "google.com"
        ],
        "nonMatches": [
            "file://hello.txt"
        ],
        "pattern": "/((https?|ftp)\\:\\/\\/)?([a-z0-9+!*(),;?\u0026=\\$_.-]+(\\:[a-z0-9+!*(),;?\u0026=\\$_.-]+)?@)?(([a-z0-9-.]*)\\.([a-z]{2,6}))|(([0-9]{1,3}\\.){3}[0-9]{1,3})(\\:[0-9]{2,5})?(\\/([a-z0-9+\\$_-]\\.?)+)*\\/?(\\?[a-z+\u0026\\$_.-][a-z0-9;:@\u0026%=+\\/\\$_.-]*)?(#[a-z_.-][a-z0-9+\\$_.-]*)?/i",
        "title": "Test"
    },
    {
        "description": "This regular expression allows to verify mobile phone numbers (600) and telephone numbers (900). Not provide premium charging phones (line 800). The number may be separated by spaces in groups of three digits, or one group of three number plus two groups of three numbers for fixed phones.",
        "matches": [
            "952 566 009",
            "+34 615 977 911",
            "967 90 23 44"
        ],
        "nonMatches": [
            "802 59 23 09",
            "677 90 23 44",
            "67 7 809 235"
        ],
        "pattern": "(([+]?34) ?)?(6(([0-9]{8})|([0-9]{2} [0-9]{6})|([0-9]{2} [0-9]{3} [0-9]{3}))|9(([0-9]{8})|([0-9]{2} [0-9]{6})|([1-9] [0-9]{7})|([0-9]{2} [0-9]{3} [0-9]{3})|([0-9]{2} [0-9]{2} [0-9]{2} [0-9]{2})))",
        "title": "Test"
    },
    {
        "description": "Matches the UK Drivers License format as laid down by the DVLA / dvla. See http ://www.govtalk.gov.uk/gdsc/html/frames/default.htm Matches:",
        "matches": [
            "tom99808275m99sc23 sugar654155a98lw59"
        ],
        "nonMatches": [
            "tom89808275m99sc23 9ugar654155a98lw59"
        ],
        "pattern": "^([A-Z]{2}[9]{3}|[A-Z]{3}[9]{2}|[A-Z]{4}[9]{1}|[A-Z]{5})[0-9]{6}([A-Z]{1}[9]{1}|[A-Z]{2})[A-Z0-9]{3}[0-9]{2}$",
        "title": "Test"
    },
    {
        "description": "Get code in between php tag \u003C?php and ?\u003E or until end of string if end of tag not found. Singleline option must be enabled!",
        "matches": [
            "\u003C?php this is code in php ?\u003E"
        ],
        "nonMatches": [
            "text outside php tag"
        ],
        "pattern": "(\\\u003C\\?php\\s+.*?((\\?\\\u003E)|$))",
        "title": "Test"
    },
    {
        "description": "Matches decimals and integer in efficient way with minimal grouping allowing you to get the match as a whole decimal/integar",
        "matches": [
            "123",
            ".75",
            "123.212",
            "123.12",
            "-.752",
            "-.75",
            "-.7",
            "-1",
            "12",
            "-0.75",
            "1",
            "123",
            "0.75",
            "123.00"
        ],
        "nonMatches": [
            "123.",
            "$123",
            "$123.00",
            "(123.0)",
            "1,234.00",
            "123,23"
        ],
        "pattern": "(-?(\\d*\\.\\d{1}?\\d*|\\d{1,}))",
        "title": "Test"
    },
    {
        "description": "This will validate all of the most common email addresses, and then others that are not so common.",
        "matches": [
            "jeremiah@superman.cupcake.french.com",
            "jeremiah.jeremiah@live.com",
            "jeremiah@hotmail.com ... etc"
        ],
        "nonMatches": [
            "bill(at)hotmail.com",
            "john@hotmail.corndog"
        ],
        "pattern": "^[a-zA-Z0-9._%-]+@[a-zA-Z0-9._%-]+\\.[a-zA-Z]{2,4}\\s*$",
        "title": "Test"
    },
    {
        "description": "Inspired by Dalibor Kalna\u0027s regexp, this one accepts numbers with the dot as required thousands separator, comma as decimal separator, and exactly digits after the comma. Minus as sign is optional.",
        "matches": [
            "-23.456.789,01",
            "5,01",
            "123.123.123.123.123.123.123,45",
            "0,23"
        ],
        "nonMatches": [
            "1",
            "1,234",
            "+1,23",
            "12345,67",
            "1,",
            ",23"
        ],
        "pattern": "^-?\\d{1,3}\\.(\\d{3}\\.)*\\d{3},\\d\\d$|^-?\\d{1,3},\\d\\d$",
        "title": "Test"
    },
    {
        "description": "Erkl\u00E4rt Stra\u00DFe-Hausnummer-Kombinationen nach folgenden Regeln f\u00FCr g\u00FCltig: Stra\u00DFe muss mit einem dt. Buchstaben beginnen, vor der Hausnummer muss (mind.) ein Whitespace stehen, der Nummer d\u00FCrfen andere Zeichen folgen (\u00221/2\u0022, \u0022c\u0022 etc.).",
        "matches": [
            "Am Plan 3c",
            "Hauptstr. 4 1/2",
            "A-Weg 8"
        ],
        "nonMatches": [
            "Am Plan",
            "Hauptstr.5",
            "Heideweg Drei"
        ],
        "pattern": "^(([a-zA-Z\u00E4\u00F6\u00FC\u00C4\u00D6\u00DC]\\D*)\\s+\\d+?\\s*.*)$",
        "title": "Test"
    },
    {
        "description": "Versioning in XX.YY.ZZ format",
        "matches": [
            "01.02.23"
        ],
        "nonMatches": [
            "1.2.3"
        ],
        "pattern": "^([0-9][0-9])[.]([0-9][0-9])[.]([0-9][0-9])$",
        "title": "Test"
    },
    {
        "description": "If it is more then 7 numbers then it will not detect.",
        "matches": [
            "M1234567, b1234567"
        ],
        "nonMatches": [
            "c12345678"
        ],
        "pattern": "^[A-Za-z]{1}[0-9]{7}$",
        "title": "Test"
    },
    {
        "description": "Regular expression to validate mobile numbers in Jordan provided by Zain, Orange, and Umnia.",
        "matches": [
            "079-5675777, 078-6543289, 077-7698435"
        ],
        "nonMatches": [
            "075-787653"
        ],
        "pattern": "^07[789]-\\d{7}$",
        "title": "Test"
    },
    {
        "description": "This regex accepts date and time values, taking into account 29/30/31 day months. 00 hours (midnight) must have both zeros, but hours 01-09 can leave 0 off, months 1-9 can also leave 0 off.",
        "matches": [
            "12/31/2001 10:30:00, 3/19/1988 19:41:25"
        ],
        "nonMatches": [
            "4/31/2010 09:31:00, 1/30/1999 24:00:00"
        ],
        "pattern": "^((0?[2])/(0?[1-9]|[1-2][0-9])|(0?[469]|11)/(0?[1-9]|[1-2][0-9]|30)|(0?[13578]|1[02])/(0?[1-9]|[1-2][0-9]|3[0-1]))/([1][9][0-9]{2}|[2-9][0-9]{3}) (00|0?[1-9]|1[0-9]|2[0-3])\\:([0-5][0-9])\\:([0-5][0-9])$",
        "title": "Test"
    },
    {
        "description": "this expression validates a date-time field in yyyy/m/d or yyyy-m-d format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00",
        "matches": [
            "2008/2/29",
            "2010/12/31",
            "2400-02-29"
        ],
        "nonMatches": [
            "2009/2/29",
            "2010/11/31",
            "2100-02-29"
        ],
        "pattern": "^(((1[6-9]|[2-9]\\d)\\d{2}([-|\\/])(((0?[13578]|1[02])([-|\\/])31)|((0?[1,3-9]|1[0-2])([-|\\/])(29|30))))|((((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))([-|\\/])0?2([-|\\/])29)|((1[6-9]|[2-9]\\d)\\d{2})([-|\\/])((0?[1-9])|(1[0-2]))([-|\\/])(0?[1-9]|1\\d|2[0-8]))$",
        "title": "Test"
    },
    {
        "description": "This regex validates a persons last name. Acceptable names can include a single quote, compound names seperated by a hyphen, or followed by \u0022Jr.\u0022 or \u0022I\u0022, \u0022II\u0022, \u0022III\u0022.",
        "matches": [
            "O\u0027Leary",
            "Smith-Barney",
            "Scott Jr.",
            "Smith III"
        ],
        "nonMatches": [
            "SMITH",
            "o\u0027leary",
            "Scott jr",
            "Smith i"
        ],
        "pattern": "(/^[A-Z][a-z]*(([\\\u0027\\,\\.\\-]?[A-Z])?[a-z]*)((\\s)?((Jr.(\\.))|I|II|III]))?$/,",
        "title": "Test"
    },
    {
        "description": "Simple email expression. Doesn\u0027t allow numbers in the email name.",
        "matches": [
            "jagnarain@jns.com, jagnarain@jns.coms"
        ],
        "nonMatches": [
            "jagnarain@jns.comss, 123jagnarain@jns.comss"
        ],
        "pattern": "^([a-zA-Z0_\\-\\.]+)@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.)|(([a-zA-Z0-9\\-]+\\.)+))([a-zA-Z]{2,3}|[0-9]{1,3})(\\]?)$",
        "title": "Test"
    },
    {
        "description": "Finally, an expression that can reliably match any valid URL/URN! Future proof against vanity TLDs, doesn\u0027t require a schema, can parse IPv4s with or without port, can parse regular URLs with/without port, can accept extra baggage at the end, and, with a slight modification (a la ^$ and changing the final rule around a bit) this can be used to find and activate URLs in bodies of text safely and reliably. Have fun (tell me if it could be improved)!",
        "matches": [
            "http://www.google.com/#sclient=psy\u0026hl=en\u0026q=this+is+a+google+serach+%5E((Csftp)%3A%2F%2F)%3F((%5Ba-zA-Z0-9%5C._-%5D%2B%5C.%5Ba-zA-Z%5D%7B2%2C7%7D)%7C((%5B0-9%5D%7B1%2C3%7D%5C.)%7B3%7D%5B0-9%5D%7B1%2C3%7D))(%3A%5Cd%2B)%3F(%2F%5Ba-zA-Z0-9%5C%26amp%3B%25_%5C.%2F-~-%23%5D*)%3F%24\u0026aq=f\u0026aqi=\u0026aql=\u0026oq=\u0026gs_rfai=\u0026pbx=1\u0026fp=ca05a7bb65e82229",
            "http://192.168.1.1:5649"
        ],
        "nonMatches": [
            "htttp://google.com",
            "http://google-.com",
            "http://google.123",
            "http://google.commmmmm",
            "http://123.456.789.1231"
        ],
        "pattern": "^((nntp|sftp|ftp(s)?|http(s)?|gopher|news|file|telnet):\\/\\/)?(([a-zA-Z0-9\\._-]*([a-zA-Z0-9]\\.[a-zA-Z0-9])[a-zA-Z]{1,6})|(([0-9]{1,3}\\.){3}[0-9]{1,3}))(:\\d+)?(\\/[^:][^\\s]*)?$",
        "title": "Test"
    },
    {
        "description": "Match to just about any valid human name you could think of.",
        "matches": [
            "Dr. Tre-Tre Morgan V. Copperstone Mc\u0027Giles Jr.",
            "Tre Giles"
        ],
        "nonMatches": [
            "@#$#"
        ],
        "pattern": "^\\s*([A-Za-z]{2,4}\\.?\\s*)?([\u0027\\-A-Za-z]+\\s*){1,2}([A-Za-z]+\\.?\\s*)?([\u0027\\-A-Za-z]+\\s*){1,2}(([jJsSrR]{2}\\.)|([XIV]{1,6}))?\\s*$",
        "title": "Test"
    },
    {
        "description": "After searching for one, I just said \u0022screw it\u0022 and wrote my own, and here she is. A regular expression to match against phone numbers, both international and USA! Very VERY flexible, if I do say so myself (and I do).",
        "matches": [
            "555-955-5555",
            "5555555555",
            "+1(773).9554-8946",
            "+1-(773)+95548946 ext 8875",
            "1/(773)/9554/8946x563",
            "(00)7-901-759-92-61ext15"
        ],
        "nonMatches": [
            "$%^\u0026* (of course not)"
        ],
        "pattern": "^((\\+)?[1-9]{1,4})?([-\\s\\.\\/])?((\\(\\d{1,4}\\))|\\d{1,4})(([-\\s\\.\\/])?[0-9]{1,6}){2,6}(\\s?(ext|x)\\s?[0-9]{1,6})?$",
        "title": "Test"
    },
    {
        "description": "A regex that hits on a multi-line sequence that starts with a START phrase on a line, and ends with an END phrase on a different line, which contains a MIDDLE phrase on a line between the START and END lines. Needs Multi-Line and Single-Line options enabled in PCRE.",
        "matches": [
            "http://gyazo.com/ffa94f5e0cac61a72f0264fceace4a1f.png"
        ],
        "nonMatches": [
            "http://gyazo.com/ffa94f5e0cac61a72f0264fceace4a1f.png"
        ],
        "pattern": "^START(?=(?:.(?!END|START))*MIDDLE).*?END[^\\n]+",
        "title": "Test"
    },
    {
        "description": "allow to insert input for polish tax identyfication number (NIP). Mask accepted: XXX-XX-XX-XXX ; XXX-XXX-XX-XX ; XXX XX XX XXX ; XXX XXX XX XX",
        "matches": [
            "222-22-22-222",
            "222-222-22-22",
            "222 22 22 222",
            "222 222 22 22"
        ],
        "nonMatches": [
            "2222222222",
            "XXXXXXXXXX"
        ],
        "pattern": "^((\\d{3}[- ]\\d{3}[- ]\\d{2}[- ]\\d{2})|(\\d{3}[- ]\\d{2}[- ]\\d{2}[- ]\\d{3}))$",
        "title": "Test"
    },
    {
        "description": "UK phone number for both Geographic (landline) and Non-Geographic (Cell) numbering. It validates a complete range of combination of area code, location and formate , it also allows international number starting from +44 or 0044 and it also allows () with area code and spaces.",
        "matches": [
            "+44 20 xxxx xxxx",
            "0044 20 xxxx xxxx",
            "020 xxxx xxxx",
            "(020) xxxx xxxx",
            "(020)xxxxxxx",
            "020 xxxx xxxxx",
            "(01xxx) xxxxxx",
            "(01xxx) xxxxx",
            "(01x1) xxx xxxx",
            "(011x) xxx xxxx",
            "(02x) xxxx xxxx",
            "(01xxxx) xxxxx and (01xxxx) xxxx",
            "05x xxxx xxxx",
            "03xx xxx xxxx",
            "07xxx xxxxxx",
            "08xx xxx xxxx and 09xx xxx xxxx"
        ],
        "nonMatches": [
            "+44 020 xxxx xxxx",
            "+44 (20) xxxx xxxx"
        ],
        "pattern": "^(((\\+44\\s?|0044\\s?)?|(\\(?0))((2[03489]\\)?\\s?\\d{4}\\s?\\d{4})|(1[23456789]1\\)?\\s?\\d{3}\\s?\\d{4})|(1[23456789][234578][0234679]\\)?\\s?\\d{6})|(1[2579][0245][0467]\\)?\\s?\\d{5})|(11[345678]\\)?\\s?\\d{3}\\s?\\d{4})|(1[35679][234689]\\s?[46789][234567]\\)?\\s?\\d{4,5})|([389]\\d{2}\\s?\\d{3}\\s?\\d{4})|([57][0-9]\\s?\\d{4}\\s?\\d{4})|(500\\s?\\d{6})|(7[456789]\\d{2}\\s?\\d{6})))$",
        "title": "Test"
    },
    {
        "description": "This is a slightly modified version of Kurt\u0027s DMS Coordinate regex so all the credit should go to Kurt - I just modified it to match a second character that may commonly be used to represent degrees",
        "matches": [
            "37\u00BA41\u002726\u0022N,97\u00BA20\u00270\u0022W (comma delimited, commas do not match...obviously :)"
        ],
        "nonMatches": [
            "\u221E , \u03C6, \u03C0 ....etc.... see Kurt\u0027s documentation"
        ],
        "pattern": "[0-9]{1,2}[:|\u00B0|\u00BA][0-9]{1,2}[:|\u0027](?:\\b[0-9]+(?:\\.[0-9]*)?|\\.[0-9]+\\b)\u0022?[N|S|E|W]",
        "title": "Test"
    },
    {
        "description": "It is useful to validate Expiry date in mm/yyyy format. But it not support when year comes like 2020,2030,2040etc",
        "matches": [
            "12/2011 12/2099"
        ],
        "nonMatches": [
            "12/2020 12/2030"
        ],
        "pattern": "\u0027^((0[1-9])|(1[0-2]))\\/*((2011)|(20[1-9][1-9]))$\u0027",
        "title": "Test"
    },
    {
        "description": "This regular expression will validate against a valid MAC address. The 6 bytes are hexadecimal and separated by semi colon or dash caracters.",
        "matches": [
            "01:23:45:67:89:AB"
        ],
        "nonMatches": [
            "01:23:45:67:89:X9"
        ],
        "pattern": "^([0-9A-F]{2}[:-]){5}([0-9A-F]{2})$",
        "title": "Test"
    },
    {
        "description": "Matches any positive decimal number \u003E 0 with optional leading \u0027+\u0027 symbol and optional leading or trailing zeros on both sides of the decimal point. Decimal point is also optional and either side of the decimal is optional.",
        "matches": [
            "010",
            "010.",
            ".010",
            "010.010"
        ],
        "nonMatches": [
            ".",
            "0",
            "0.",
            ".0",
            "0.0",
            "0.00",
            "00.0",
            "00.00",
            "-0",
            "-1",
            "a"
        ],
        "pattern": "^[+]?((\\d*[1-9]+\\d*\\.?\\d*)|(\\d*\\.\\d*[1-9]+\\d*))$",
        "title": "Test"
    },
    {
        "description": "This expression validation for price.",
        "matches": [
            "$123,123.00,$ 123,123,123.00"
        ],
        "nonMatches": [
            "12,1234 , 123.1234"
        ],
        "pattern": "^(([$])?((([0-9]{1,3},)+[0-9]{3})|[0-9]+)(\\.[0-9]{2})?)$",
        "title": "Test"
    },
    {
        "description": "Here\u0027s my relaxed version of an URL regex. This one accepts just about anything but a double dot but still must resemble an URL to pass. Unlike my other URL validater this one accepts a port. Doesn\u0027t accept out of place meta characters.",
        "matches": [
            "http://domain.com/",
            "ftp://foo.bar/dir",
            "https://me.us/file.pl?arg=1"
        ],
        "nonMatches": [
            "http://domain",
            "ftp://foo.bar//dir",
            "https://me.us/file..pl"
        ],
        "pattern": "^(\\w{3,6}\\:\\/\\/[\\w\\-]+(?:\\.[\\w\\-]+)+(?:\\:\\d{2,4})*(?:\\/?|(?:\\/[\\w\\-]+)*)(?:\\/?|\\/\\w+\\.\\w{2,4}(?:\\?[\\w]+\\=[\\w\\-]+)?)?(?:\\\u0026[\\w]+\\=[\\w\\-]+)*)$",
        "title": "Test"
    },
    {
        "description": "Matches yyyy/MM/dd",
        "matches": [
            "2010/12/09 1987-01-01 1988.2.1"
        ],
        "nonMatches": [
            "1888/12/09 198/1/1 1987/12/33"
        ],
        "pattern": "^(19|20)\\d\\d[-/.]([1-9]|0[1-9]|1[012])[- /.]([1-9]|0[1-9]|[12][0-9]|3[01])$",
        "title": "Test"
    },
    {
        "description": "This is a Perl regular expression which matches any valid URI. I\u0027ve extensively tested it (with the help of Wikipedia, and the actual URI specification written by Sir Tim Burners Lee himself), and it seems to work in all cases. Whether it will actually work to validate a URI is questionable... But any URI that is valid, will match. Including those with IPv6 addresses.",
        "matches": [
            "ftp://ftp.is.co.za/rfc/rfc1808.txt",
            "http://www.ietf.org/rfc/rfc2396.txt",
            "ldap://[2001:db8::7]/c=GB?objectClass?one",
            "mailto:John.Doe@example.com",
            "news:comp.infosystems.www.servers.unix",
            "tel:+1-816-555-1212",
            "telnet://192.0.2.16:80/",
            "urn:oasis:names:specification:docbook:dtd:xml:4.1.2"
        ],
        "nonMatches": [
            "asdf?fdjdf:blah",
            "dskjf:///////blah",
            "google.com"
        ],
        "pattern": "#^([a-z0-9+\\-.]+):([/]{0,2}([a-z0-9\\-._~%!\\$\u0026\u0027\\(\\)\\*+,;=:]+@)?([\\[\\]a-z0-9\\-._~%!\\$\u0026\u0027\\(\\)\\*+,;=:]+(:[0-9]+)?))([a-z0-9\\-._~%!\\$\u0026\u0027\\(\\)\\*+,;=:@/]*)(\\?[\\?/a-z0-9\\-._~%!\\$\u0026\u0027\\(\\)\\*+,;=:@]+)?(\\#[a-z0-9\\-._~%!\\$\u0026\u0027\\(\\)\\*+,;=:@/\\?]+)?#i",
        "title": "Test"
    },
    {
        "description": "Regular expression for find date with time.",
        "matches": [
            "dd/mm/yyyy HH:MM format, 10/10/2010 05:30"
        ],
        "nonMatches": [
            "dd/mm/yy HH:MM"
        ],
        "pattern": "((\\(\\d{2}\\) ?)|(\\d{2}/))?\\d{2}/\\d{4} ([0-2][0-9]\\:[0-6][0-9])",
        "title": "Test"
    },
    {
        "description": "Validate Hijri Dates thanks to tutoweb",
        "matches": [
            "24/02/1431 02/12/1400 12/3/1499"
        ],
        "nonMatches": [
            "31/02/1431 03/13/1400 12/3/1500"
        ],
        "pattern": "^([1-9]|(0|1|2)[0-9]|30)(/|-)([1-9]|1[0-2]|0[1-9])(/|-)(14[0-9]{2})$",
        "title": "Test"
    },
    {
        "description": "[-90.000000 ... 90.000000] Decimal places: up to 6. You can increase precision by replacing {1,6} with {1,your_number}",
        "matches": [
            "-90; -90.0; -89.99; 0; 0.000; 89.99; 90.0; 90"
        ],
        "nonMatches": [
            "-100; -90.1; 90.01; 100"
        ],
        "pattern": "^-?(?:90(?:(?:\\.0{1,6})?)|(?:[0-9]|[1-8][0-9])(?:(?:\\.[0-9]{1,6})?))$",
        "title": "Test"
    },
    {
        "description": "[-180.000000 ... 180.000000] Decimal places: up to 6. You can increase precision by replacing {1,6} with {1,your_number}",
        "matches": [
            "-180; -180.0; -179.99; 0.000; 179.99; 180.0; 180"
        ],
        "nonMatches": [
            "-200; -180.1; 180.1; 200"
        ],
        "pattern": "^-?(?:180(?:(?:\\.0{1,6})?)|(?:[0-9]|[1-9][0-9]|1[1-7][0-9])(?:(?:\\.[0-9]{1,6})?))$",
        "title": "Test"
    },
    {
        "description": "Will not validate numbers starting with 0 or 1. Only validates digits. I cannot take credit for this. I do not remember where I found it.",
        "matches": [
            "2035551212"
        ],
        "nonMatches": [
            "1035551212",
            "555-1212",
            "(123) 456-7890"
        ],
        "pattern": "^[2-9]{2}[0-9]{8}$",
        "title": "Test"
    },
    {
        "description": "Regular expression to validate Persian(Jalali) date, that supports days in month except isfand(espand) in leap years",
        "matches": [
            "1379/05/31,1379/6/3,1379/07/29,1379/10/30,1379/11/30,1379/12/30,1379/12/29"
        ],
        "nonMatches": [
            "1379/05/32,1379/6/0,1379/7/31,1379/11/31,1379/12/31"
        ],
        "pattern": "^[1-4]\\d{3}\\/((0?[1-6]\\/((3[0-1])|([1-2][0-9])|(0?[1-9])))|((1[0-2]|(0?[7-9]))\\/(30|([1-2][0-9])|(0?[1-9]))))$",
        "title": "Test"
    },
    {
        "description": "Validating a Facebook page can be a little bit tricky. This is because there are two valid formats. The first is facebook.com/pages/USERNAME/numbers/, the second is designed for big business which grants them a clean url such as facebook.com/coca-cola/. I see this regex being used in a user profile admin page and I think it does a good enough job for this purpose. The problem is bad urls could slip through which meet the criteria for the clean facebook page url but aren\u0027t in valid pages on the site. The main example being that an incomplete numbered url could slip through as http://www.facebook.com/pages/ would validate. Facebook also uses various subdomains such as en-gb.facebook.com to provide localised versions of the site. This regex will accept a prefix of either www or a locale code of two letters dash two letters. It doesn\u0027t validate the actual country code though. [UPDATED] Added full stop to list of valid characters for page names.",
        "matches": [
            "http://www.facebook.com/pages/Andy-Worthington/196377860390800",
            "http://en-gb.facebook.com/pages/Andy-Worthington/196377860390800",
            "http://www.facebook.com/pages/",
            "http://www.facebook.com/coca-cola/",
            "http://www.facebook.com/thesimpsons/"
        ],
        "nonMatches": [
            "http://facebook.com/pages/Andy-Worthington/196377860390800",
            "www.facebook.com/pages/Andy-Worthington/196377860390800",
            "http://www.facebook.com/people/Andy-Worthington/738143803"
        ],
        "pattern": "http[s]?://(www|[a-zA-Z]{2}-[a-zA-Z]{2})\\.facebook\\.com/(pages/[a-zA-Z0-9\\.-]+/[0-9]+|[a-zA-Z0-9\\.-]+)[/]?$",
        "title": "Test"
    },
    {
        "description": "validate mobile and land phone numbers. Allow space - / or nothing number and area codes",
        "matches": [
            "02/583725",
            "3471231231",
            "02 12345678"
        ],
        "nonMatches": [
            "+3902/583725",
            "0 2998765",
            "02 996 876"
        ],
        "pattern": "^(([0-9]{2,4})([-\\s\\/]{0,1})([0-9]{4,8}))?$",
        "title": "Test"
    },
    {
        "description": "This matches all 5 digit numbers whose first three digits match valid US ZIP code prefixes.",
        "matches": [
            "10038 11205 20723"
        ],
        "nonMatches": [
            "09911 26942 98763"
        ],
        "pattern": "(?!00[02-5]|099|213|269|34[358]|353|419|42[89]|51[789]|529|53[36]|552|5[67]8|5[78]9|621|6[348]2|6[46]3|659|69[4-9]|7[034]2|709|715|771|81[789]|8[3469]9|8[4568]8|8[6-9]6|8[68]7|9[02]9|987)\\d{5}",
        "title": "Test"
    },
    {
        "description": "The expression matches any month name (english) in short or full style. Use it with case insensitive mode in your date matching expressions.",
        "matches": [
            "Jan",
            "April"
        ],
        "nonMatches": [
            "Febr"
        ],
        "pattern": "(Jan(uary)?|Feb(ruary)?|Mar(ch)?|Apr(il)?|May|Jun(e)?|Jul(y)?|Aug(ust)?|Sep(tember)?|Oct(ober)?|(Nov|Dec)(ember)?)",
        "title": "Test"
    },
    {
        "description": "Validate alpha-numeric international names with no more than one space between them",
        "matches": [
            "Tom Jones, Liam Le\u0027Brok, Joesh \u00D6lensky"
        ],
        "nonMatches": [
            "Tom Jones (two spaces), Jo#, E-L33T"
        ],
        "pattern": "^([\\u00c0-\\u01ffa-zA-Z\u0027\\-]+[ ]?[\\u00c0-\\u01ffa-zA-Z\u0027\\-]*)+$",
        "title": "Test"
    },
    {
        "description": "The following is a powerful regular expression for e-mail address\u0027s validation. It was wrote respecting the e-mail addresses\u0027 syntax reported in the RFCs and supports both hostnames with multiple sub domains and IP addresses.",
        "matches": [
            "sample@domain1.domain2.domain3.museum s?a=m^p!l#e@ola.comip_address_test@192.168.1.1"
        ],
        "nonMatches": [
            ".sample@domain.com.sample.@domain.comsample.@domain.comsample@192.168.1.1234sample@domain..domsample@.domain.dom"
        ],
        "pattern": "^([\\!#\\$%\u0026\u0027\\*\\+/\\=?\\^\u0060\\{\\|\\}~a-zA-Z0-9_-]+[\\.]?)+[\\!#\\$%\u0026\u0027\\*\\+/\\=?\\^\u0060\\{\\|\\}~a-zA-Z0-9_-]+@{1}((([0-9A-Za-z_-]+)([\\.]{1}[0-9A-Za-z_-]+)*\\.{1}([A-Za-z]){1,6})|(([0-9]{1,3}[\\.]{1}){3}([0-9]{1,3}){1}))$",
        "title": "Test"
    },
    {
        "description": "Checks whether the price is the correct format",
        "matches": [
            "123,45",
            "123.45",
            "12345"
        ],
        "nonMatches": [
            "123,123,45",
            "1234.123.123",
            "123.456",
            "123,234"
        ],
        "pattern": "^[0-9]+([\\,|\\.]{0,1}[0-9]{2}){0,1}$",
        "title": "Test"
    },
    {
        "description": "Tries to match the format of phone numbers within South Africa. Does not try to validate phone numbers based on actual numbers (e.g. cell networks or other landline prefixes)",
        "matches": [
            "(011) 123 4543,(011) 123-4543,(011) 212 8765,011 876 8789,0118768789,011-876-8789,082 821 9090,+27 11 123 1231,+27 (11) 123-1231,+27 (11) 123 1231,+27(11)123-1231,+27 11 1238765"
        ],
        "nonMatches": [
            "011 1234 242"
        ],
        "pattern": "(\\(0\\d\\d\\)\\s\\d{3}[\\s-]+\\d{4})|(0\\d\\d[\\s-]+\\d{3}[\\s-]+\\d{4})|(0\\d{9})|(\\+\\d\\d\\s?[\\(\\s]\\d\\d[\\)\\s]\\s?\\d{3}[\\s-]?\\d{4})",
        "title": "Test"
    },
    {
        "description": "This expression is pretty simple. It validates for mobile phone numbers in mainland China. I needed phone numbers in a certain format for use with an SMS gateway. The formatting is rather strict. Area codes taken from here: http://en.wikipedia.org/wiki/Telephone_numbers_in_China#Mobile_phones",
        "matches": [
            "+8613812345678",
            "+8613012345678",
            "+8618212345678"
        ],
        "nonMatches": [
            "+8614012345678",
            "+8615412345678",
            "+8619012345678"
        ],
        "pattern": "^(\\+86)(13[0-9]|145|147|15[0-3,5-9]|18[0,2,5-9])(\\d{8})$",
        "title": "Test"
    },
    {
        "description": "First digit can be 7 or 8 or 9. No. can have any of the following prefixes 0 91 91- (91)- +91 (+91) (+91)-",
        "matches": [
            "9876543210",
            "09876543210",
            "919876543210",
            "+919876543210",
            "91-9876543210",
            "+91-9876543210",
            "(91)9876543210",
            "(+91)9876543210",
            "(91)-9876543210",
            "(+91)-9876543210"
        ],
        "nonMatches": [
            "9198279",
            "6789123456",
            "0-9876543210",
            "+(91)-9876543210"
        ],
        "pattern": "^(((0|((\\+)?91(\\-)?))|((\\((\\+)?91\\)(\\-)?)))?[7-9]\\d{9})?$",
        "title": "Test"
    },
    {
        "description": ".NET 3.5 Tested. Used to extract the YouTubeID from a fully qualified YouTube URL. Dim _Regex As New Regex(\u0022(?:[Yy][Oo][Uu][Tt][Uu][Bb][Ee]\\.[Cc][Oo][Mm]/watch\\?v=)([\\w-]{11})\u0022, RegexOptions.IgnoreCase Or RegexOptions.Compiled) Dim _RegexMatch As Match = _Regex.Match(\u0022http://www.youtube.com/watch?v=pW2GSdxxwDg\u0022) Dim _YouTubeVideoID As System.String = _RegexMatch.Groups(1).Value",
        "matches": [
            "http://www.youtube.com/watch?v=pW2GSdxxwDg",
            "http://www.youtube.com/watch?v=-7P7_kxZQ5I",
            "http://www.youtube.com/watch?v=7sPKHwsupmQ\u0026playnext=1\u0026list=PL40CB7986D1A9A285",
            "http://www.youtube.com/watch?v=r-di4gJvq4Q\u0026feature=channel_video_title"
        ],
        "nonMatches": [
            "http://www.youtu.be/watch?v=pW2GSdxxwDg"
        ],
        "pattern": "(?:[Yy][Oo][Uu][Tt][Uu][Bb][Ee]\\.[Cc][Oo][Mm]/watch\\?v=)([\\w-]{11})",
        "title": "Test"
    },
    {
        "description": "to accept only alphanumeric with all special characters except (double/single Quotes). and if numbers then only positive numbers",
        "matches": [
            "65 ghf, 65% - consumed, hello, 64 - 56"
        ],
        "nonMatches": [
            "-65 ghf, -164, 65% - \u0022consumed\u0022"
        ],
        "pattern": "^[^-]{1}?[^\\\u0022\\\u0027]*$",
        "title": "Test"
    },
    {
        "description": "I\u0027ve created this regex expression to parse portuguese phone numbers from an webpage. As this was made with a very specific purpose, the expression expects the number to be preceded and followed by any character that\u0027s not a digit or a letter (basically space or \u0022special\u0022 character). This way I can parse any page with confidence that the results will be adequate. I\u0027d also recommend that you strip any spaces and \u0022new line\u0022 from the haystack before matching it with this regex. Here\u0027s an example: http://paste2.org/p/1610446",
        "matches": [
            "\u003Cli\u003E+351963345676\u003C/li\u003E\u003Ca href=\u0022#\u0022\u003E214664332\u003C/a\u003E\u002600351923456321\u0026"
        ],
        "nonMatches": [
            "213322134 letters932213332 00351932213332letters"
        ],
        "pattern": "/(?\u003C=[^a-zA-Z0-9])((\\+351|00351|351)?)(2\\d{1}|(9(3|6|2|1)))\\d{7}(?=[^a-zA-Z0-9])/",
        "title": "Test"
    },
    {
        "description": "Validate a date according to the ISO 8601 standard (no time part) considering long-short months to allow 31st day of month and leap years to allow 29th February. I took Ted Cambron\u0027s implementation, simplified and added support for leap years and long-short months.",
        "matches": [
            "1600-02-29"
        ],
        "nonMatches": [
            "2011-02-29"
        ],
        "pattern": "^(?:(?=[02468][048]00|[13579][26]00|[0-9][0-9]0[48]|[0-9][0-9][2468][048]|[0-9][0-9][13579][26])\\d{4}(?:(-|)(?:(?:00[1-9]|0[1-9][0-9]|[1-2][0-9][0-9]|3[0-5][0-9]|36[0-6])|(?:01|03|05|07|08|10|12)(?:\\1(?:0[1-9]|[12][0-9]|3[01]))?|(?:04|06|09|11)(?:\\1(?:0[1-9]|[12][0-9]|30))?|02(?:\\1(?:0[1-9]|[12][0-9]))?|W(?:0[1-9]|[1-4][0-9]|5[0-3])(?:\\1[1-7])?))?)$|^(?:(?![02468][048]00|[13579][26]00|[0-9][0-9]0[48]|[0-9][0-9][2468][048]|[0-9][0-9][13579][26])\\d{4}(?:(-|)(?:(?:00[1-9]|0[1-9][0-9]|[1-2][0-9][0-9]|3[0-5][0-9]|36[0-5])|(?:01|03|05|07|08|10|12)(?:\\2(?:0[1-9]|[12][0-9]|3[01]))?|(?:04|06|09|11)(?:\\2(?:0[1-9]|[12][0-9]|30))?|(?:02)(?:\\2(?:0[1-9]|1[0-9]|2[0-8]))?|W(?:0[1-9]|[1-4][0-9]|5[0-3])(?:\\2[1-7])?))?)$",
        "title": "Test"
    },
    {
        "description": "Moblie Number which starts from 7/8/9 (Indian Mobile No.) \u0026 11 digit Landline number",
        "matches": [
            "9890124589 , 0207256984"
        ],
        "nonMatches": [
            "6523145897"
        ],
        "pattern": "([0-9]{11}$)|(^[7-9][0-9]{9}$)",
        "title": "Test"
    },
    {
        "description": "Will match valid Hexadecimal characters in a string.",
        "matches": [
            "12FFc"
        ],
        "nonMatches": [
            "12FGFc"
        ],
        "pattern": "/^[0-9a-fA-F]+$/",
        "title": "Test"
    },
    {
        "description": "UK VAT Validation Conforms to format outlined below: Country code GB followed by either: standard: 9 digits (block of 3, block of 4, block of 2 \u2013 e.g. GB999 9999 73) branch traders: 12 digits (as for 9 digits, followed by a block of 3 digits) government departments: the letters GD then 3 digits from 000 to 499 (e.g. GBGD001) health authorities: the letters HA then 3 digits from 500 to 999 (e.g. GBHA599) For the 9-digit scheme, the 2-digit block containing the 8th and 9th digits is always in the range 00 to 96 and is derived from a weighted modulus-97 check number (an identical algorithm is used for the 12-digit scheme, ignoring the extra 3-digit block)",
        "matches": [
            "GB 123 4567 89",
            "123456789 123",
            "GD 123",
            "HA123"
        ],
        "nonMatches": [
            "GB 123 4567 97",
            "HA 1234",
            "GB 1234567890"
        ],
        "pattern": "^(GB)?(\\ )?[0-9]\\d{2}(\\ )?[0-9]\\d{3}(\\ )?(0[0-9]|[1-8][0-9]|9[0-6])(\\ )?([0-9]\\d{2})?|(GB)?(\\ )?GD(\\ )?([0-4][0-9][0-9])|(GB)?(\\ )?HA(\\ )?([5-9][0-9][0-9])$",
        "title": "Test"
    },
    {
        "description": "This expression matches all fields from the format string of the printf/scanf functions. This is .NET version. It is based on Format Fields Specification at http://msdn.microsoft.com/en-us/library/56e442dc.aspx. According to format specification: %[flags][width][.precision][{h|l|ll|L|I|I32|I64|w}]type output matche groups will contain: #1 - flags, #2 - width, #3 - precision, #4 - size prefix, #5 - type.",
        "matches": [
            "%*.*s",
            "%.3d",
            "%lC",
            "%s%%%02d"
        ],
        "nonMatches": [
            "%5.f",
            "%++X",
            "%@d",
            "%232"
        ],
        "pattern": "(?\u003C!%)(?:%%)*%([\\-\\+0\\ \\#])?(\\d+|\\*)?(\\.\\*|\\.\\d+)?([hLIw]|l{1,2}|I32|I64)?([cCdiouxXeEfgGaAnpsSZ])",
        "title": "Test"
    },
    {
        "description": "European short hours",
        "matches": [
            "00:00",
            "0h",
            "0H00"
        ],
        "nonMatches": [
            "24:00",
            "112h",
            "0:"
        ],
        "pattern": "^((([0-9]|([0-1][0-9])|(2[0-3]))[hH:][0-5][0-9])|(([0-9]|(1[0-9])|(2[0-3]))[hH]))$",
        "title": "Test"
    },
    {
        "description": "Checking Iran\u0027s mobile no with or without country code.",
        "matches": [
            "09124455444 00989124455444 +989124455444"
        ],
        "nonMatches": [
            "9124455444"
        ],
        "pattern": "^(((\\+{1})|(0{2}))98|(0{1}))9[1-9]{1}\\d{8}\\Z$",
        "title": "Test"
    },
    {
        "description": "Regular Expression for Egypt Mobile Network [ Last update 11 numbers ]",
        "matches": [
            "01022334455",
            "01122334455",
            "01222334455"
        ],
        "nonMatches": [
            "0102233445",
            "01322334455",
            "m0122234455"
        ],
        "pattern": "^01[0-2]{1}[0-9]{8}",
        "title": "Test"
    },
    {
        "description": "Valid Pan card",
        "matches": [
            "ASDGF1234A",
            "ASDAF1234A",
            "ASDHA1234A"
        ],
        "nonMatches": [
            "ASDQF1234A",
            "asdfq1234a",
            "AsDa1231a"
        ],
        "pattern": "/^[A-Z]{3}[G|A|F|C|T|H|P]{1}[A-Z]{1}\\d{4}[A-Z]{1}$/;",
        "title": "Test"
    },
    {
        "description": "Parses most phone numbers into four groups: country code, area code, number, and extension.",
        "matches": [
            "011-656-555-1234",
            "(217)555-1234",
            "+82-10-5551-2345",
            "+(82) 10-5551-2345",
            "(907) 555-1234",
            "+886-2-55512345",
            "1-416-555-1234",
            "714 555 1234",
            "714 555 1234 / 1234",
            "+886-2-55512345 x 1234",
            "+886-2-55512345x1234",
            "1-416-555-1234 ext 1234"
        ],
        "nonMatches": [
            "7735551234",
            "+11231234567",
            "1(123)1234567"
        ],
        "pattern": "^(?:[\\+]?[\\(]?([\\d]{1,3})[\\s\\-\\.\\)]+)?(?:[\\(]?([\\d]{1,3})[\\s\\-\\/\\)]+)([2-9][0-9\\s\\-\\.]{6,}[0-9])(?:[\\s\\D]+([\\d]{1,5}))?$",
        "title": "Test"
    },
    {
        "description": "Matches full windows paths and UNC paths (allowing spaces in quoted text). For non quoted text, the extension of the file must be alphanumeric.",
        "matches": [
            "C:\\test_for_spaces\\test_extension",
            "C:\\test_for_spaces\\test_extension.t92",
            "\u0022C:\\test for spaces\\New Text Document.txt\u0022",
            "\\\\machine1\\shared_2\\hello_world.txt",
            "\u0022\\\\machine1\\c$\\shared 4\\hello world.txt\u0022"
        ],
        "nonMatches": [
            "\u0022\\\\machine1\\c$\\test",
            "pipe:colon.txt\u0022",
            "C:\\random space\\test.txt",
            "C\\\\bad\\test.t"
        ],
        "pattern": "(\u0022(([a-zA-Z]:)|(\\\\\\\\[^/\\\\:\\*\\?\u0022\u0022\u003C\u003E\\|]+(\\\\[a-zA-Z]\\$)?))\\\\([^/\\\\:\\*\\?\u0022\u0022\u003C\u003E\\|]+\\\\)*[^/\\\\:\\*\\?\u0022\u0022\u003C\u003E\\|]+(\\.[^/\\\\:\\*\\?\u0022\u0022\u003C\u003E\\|]+[^/\\\\:\\*\\?\u0022\u0022\u003C\u003E\\|\\s])?\u0022)|((([a-zA-Z]:)|(\\\\\\\\[^/\\\\:\\*\\?\u0022\u0022\u003C\u003E\\|\\s]+(\\\\[a-zA-Z]\\$)?))\\\\([^/\\\\:\\*\\?\u0022\u0022\u003C\u003E\\|\\s]+\\\\)*[^/\\\\:\\*\\?\u0022\u0022\u003C\u003E\\|\\s]+(\\.[a-zA-Z0-9]+)?)",
        "title": "Test"
    },
    {
        "description": "The above regex matches any phone number of the format (XXX-XXX-XXXX). (With or without hyphens)",
        "matches": [
            "001-233-4322, 0012334322, 001 233 4322"
        ],
        "nonMatches": [
            "001_233_4322"
        ],
        "pattern": "\\d{3})[- .]?(\\d{3}[- .]?\\d{4}",
        "title": "Test"
    },
    {
        "description": "Matches and returns the text provided the match string and the end string. Eg. I wonder why all programming languages start with a hello world program !!",
        "matches": [
            "wonder why all programming languages start with"
        ],
        "nonMatches": [
            "."
        ],
        "pattern": "wonder\\s*([^$]*)\\s*with",
        "title": "Test"
    },
    {
        "description": "Password validation with any two of combinations: [A-Z],[a-z],Punctuation Symbols with minimum user requirement without digits.If digit is added , it wont validate.As per requirement add \u0027.{n,m}\u0027 without quotes before the $ sign in the expression.",
        "matches": [
            "Sara,sA,%g,\u0026HHJ,G(*,hgh%"
        ],
        "nonMatches": [
            "Sa2,hjH7,7\u0026h"
        ],
        "pattern": "^((\\D*[a-z]\\D*[A-Z]\\D*)|(\\D*[A-Z]\\D*[a-z]\\D*)|(\\D*\\W\\D*[a-z])|(\\D*\\W\\D*[A-Z])|(\\D*[a-z]\\D*\\W)|(\\D*[A-Z]\\D*\\W))$",
        "title": "Test"
    },
    {
        "description": "Matches month and year in the specified format.",
        "matches": [
            "Apr 2003 January 2019 Jun 1992"
        ],
        "nonMatches": [
            "."
        ],
        "pattern": "((?:Jan(?:uary)?|Feb(?:ruary)?|Mar(?:ch)?|Apr(?:il)?|May|Jun(?:e)?|Jul(?:y)?|Aug(?:ust)?|Sep(?:tember)?|Sept|Oct(?:ober)?|Nov(?:ember)?|Dec(?:ember)?))(\\s+)[0-9]{2,4}",
        "title": "Test"
    },
    {
        "description": "This will parse a command line for the command and parameter",
        "matches": [
            "\u0022c:\\program files\\myapp\\app.exe\u0022 p1 p2 \u0022p3 with space\u0022",
            "app.exe p1 p2 \u0022p3 with space\u0022",
            "app.exe"
        ],
        "nonMatches": [
            "none"
        ],
        "pattern": "(?\u003Ccmd\u003E^\u0022[^\u0022]*\u0022|\\S*) *(?\u003Cprm\u003E.*)?",
        "title": "Test"
    },
    {
        "description": "it will validate phone number formats like - 1. (91)123-456-7890 2. +91-123-456-7890 3. 911234567890 4. 1234567890 5. (91)123/456/7890 6. +91/123/456/7890 7. (91)123.456.7890 8. +91.123.456.7890 There is no limitation on the repeating pattern",
        "matches": [
            "+91.123.456.7890"
        ],
        "nonMatches": [
            "symbols other than \u0027/\u0027\u0027.\u0027\u0027(\u0027\u0027)\u0027\u0027-\u0027 will not be allowed"
        ],
        "pattern": "([+(]?\\d{0,2}[)]?)([-/.\\s]?\\d+)+",
        "title": "Test"
    },
    {
        "description": "Validates 8 or 10 character Bank Idenifier Code (BIC) / SWIFT. Also validates 2-letter country ISO code (5th and 6th characters).",
        "matches": [
            "DEUTDEFF500, AIBKIE2D, RBOSGB2L, RBOSGB2LXXX"
        ],
        "nonMatches": [
            "83-00-01, SA03 8000 0000 6080 1016 7519"
        ],
        "pattern": "^([a-zA-Z]){4}(AF|AX|AL|DZ|AS|AD|AO|AI|AQ|AG|AR|AM|AW|AU|AZ|BS|BH|BD|BB|BY|BE|BZ|BJ|BM|BT|BO|BA|BW|BV|BR|IO|BN|BG|BF|BI|KH|CM|CA|CV|KY|CF|TD|CL|CN|CX|CC|CO|KM|CG|CD|CK|CR|CI|HR|CU|CY|CZ|DK|DJ|DM|DO|EC|EG|SV|GQ|ER|EE|ET|FK|FO|FJ|FI|FR|GF|PF|TF|GA|GM|GE|DE|GH|GI|GR|GL|GD|GP|GU|GT|GG|GN|GW|GY|HT|HM|VA|HN|HK|HU|IS|IN|ID|IR|IQ|IE|IM|IL|IT|JM|JP|JE|JO|KZ|KE|KI|KP|KR|KW|KG|LA|LV|LB|LS|LR|LY|LI|LT|LU|MO|MK|MG|MW|MY|MV|ML|MT|MH|MQ|MR|MU|YT|MX|FM|MD|MC|MC|MN|ME|MS|MA|MZ|MM|MA|NR|NP|NL|AN|NC|NZ|NI|NE|NG|NU|NF|MP|NO|OM|PK|PW|PS|PA|PG|PY|PE|PH|PN|PL|PT|PR|QA|RE|RO|RU|RW|SH|KN|LC|PM|VC|WS|SM|ST|SA|SN|RS|SC|SL|SG|SK|SI|SB|SO|ZA|GS|ES|LK|SD|SR|SJ|SZ|SE|CH|SY|TW|TJ|TZ|TH|TL|TG|TK|TO|TT|TN|TR|TM|TC|TV|UG|UA|AE|GB|US|UM|UY|UZ|VU|VE|VN|VG|VI|WF|EH|YE|ZM|ZW)([0-9a-zA-Z]){2}([0-9a-zA-Z]{3})$",
        "title": "Test"
    },
    {
        "description": "Validates name of months January, Febuary, ..., December. Also accepts short hand forms jan, feb,..., dec.",
        "matches": [
            "January, April, December"
        ],
        "nonMatches": [
            "january, janvier, dece, ramadan"
        ],
        "pattern": "^(Jan(uary)?|Feb(ruary)?|Mar(ch)?|Apr(il)?|May|Jun(e)?|Jul(y)?|Aug(ust)?|Sep(tember)?|Sept|Oct(ober)?|Nov(ember)?|Dec(ember)?)$",
        "title": "Test"
    },
    {
        "description": "This expression will match city.state.domain.com Into 4 capture groups.",
        "matches": [
            "city.state.domain.com"
        ],
        "nonMatches": [
            "asdasd.domain.com"
        ],
        "pattern": "^([^\\.]+).([^\\.]+).([^\\.]+).([^\\.]+)$",
        "title": "Test"
    },
    {
        "description": "This regular expression is designed just to extract the domain name from a URL. A domain name may neither start with nor end with a dash. I didn\u0027t take the time to add in this check and am actually not sure that it could be easily done. Try it for yourself to understand why.",
        "matches": [
            "http://happycatfish.com/",
            "http://happycatfish.com/our-work"
        ],
        "nonMatches": [
            "http://happycatfish.comm",
            "http://happycatfish.c"
        ],
        "pattern": "(http[s]?://)?([A-Za-z0-9-]\\.)*(?\u003CdomainName\u003E([A-Za-z0-9-]+\\.)[A-Za-z]{2,3})/?.$",
        "title": "Test"
    },
    {
        "description": "Date pattern for date format DD-MM-YYYY or DD/MM/YYYY or DD.MM.YYYY. Year value limited from 1900-2299",
        "matches": [
            "01/01/1900",
            "29/02/2012",
            "31/12/2101"
        ],
        "nonMatches": [
            "30/02/2012",
            "31/04/2010",
            "31.05.2300"
        ],
        "pattern": "^((((0[1-9]|[1-2][0-9]|3[0-1])[./-](0[13578]|10|12))|((0[1-9]|[1-2][0-9])[./-](02))|(((0[1-9])|([1-2][0-9])|(30))[./-](0[469]|11)))[./-]((19\\d{2})|(2[012]\\d{2})))$",
        "title": "Test"
    },
    {
        "description": "A stupid REGEXP that validate a binary number on more rows.",
        "matches": [
            "01001010101001"
        ],
        "nonMatches": [
            "010102002010010"
        ],
        "pattern": "^(0|1)+$",
        "title": "Test"
    },
    {
        "description": "Regexp for czech cellphone numbers",
        "matches": [
            "+420 123 456 789",
            "420123456789",
            "123 456 789"
        ],
        "nonMatches": [
            "a23456789",
            "123@456798",
            "123456"
        ],
        "pattern": "^(\\+?420)? ?[0-9]{3} ?[0-9]{3} ?[0-9]{3}$",
        "title": "Test"
    },
    {
        "description": "This will match Medicare Rail Road Board numbers.",
        "matches": [
            "A123456 XYZ123456"
        ],
        "nonMatches": [
            "123456A 123456789A 123456789T1"
        ],
        "pattern": "^[A-Z]{1,3}\\d{6}$",
        "title": "Test"
    },
    {
        "description": "Matches full textual date formats. Case insensitive, optional commas, short and long weekdays and months, optional weekdays, optional leading zeros in date.",
        "matches": [
            "Sun, Mar 7, 2012",
            "Sunday, March 7, 2012",
            "March 07, 2012",
            "SUN MARCH 7 2012"
        ],
        "nonMatches": [
            "07MAR2012",
            "03/07/2012",
            "Mar-07-2012"
        ],
        "pattern": "(?i)((sun(day)?|mon(day)?|tue(sday)?|wed(nesday)?|thu(rsday)?|fri(day)?|sat(urday)?),?\\s)?((jan(uary)?|feb(ruary)?|mar(ch)?|apr(il)?|may|jun(e)?|jul(y)?|aug(ust)?|sep(tember)?|oct(ober)?|nov(ember)?|dec(ember)?)\\s)+((0?[1-9]|[1-2][0-9]|3[0-1]),?\\s)+([1-2][0-9][0-9][0-9])",
        "title": "Test"
    },
    {
        "description": "This regex will remove all markup tag except \u003Cp\u003E\u003C/p\u003E and line break tag.",
        "matches": [
            "All Markup tags"
        ],
        "nonMatches": [
            "\u003Cp\u003E\u003C/p\u003E\u003Cbr\u003E\u003Cbr/\u003E"
        ],
        "pattern": "\u003C[^/bp][^\u003E\u003C]*\u003E|\u003Cp[a-z][^\u003E\u003C]*\u003E|\u003Cb[^r][^\u003E\u003C]*\u003E|\u003Cbr[a-z][^\u003E\u003C]*\u003E|\u003C/[^bp]+\u003E|\u003C/p[a-z]+\u003E|\u003C/b[^r]+\u003E|\u003C/br[a-z]+\u003E",
        "title": "Test"
    },
    {
        "description": "To find ISBN-10 or ISBN-13 text",
        "matches": [
            "ISBN-13 978-3-642-11746-6 SomeText",
            "ISBN 978-3-642-11746-6",
            "ISBN-10 3-642-11746-5 SomeText",
            "ISBN 3-642-11746-5",
            "ISBN: 978-3-642-11746-6"
        ],
        "nonMatches": [
            "ISBN : 978-3-642-11746-6",
            "ISBN-10 : 3-642-11746-5",
            "ISBN-13 : 978-3-642-11746-6"
        ],
        "pattern": "ISBN(-1(?:(0)|3))?:?\\x20(\\s)*[0-9]+[- ][0-9]+[- ][0-9]+[- ][0-9]*[- ]*[xX0-9]",
        "title": "Test"
    },
    {
        "description": "This regex matchs nearly all forms off swiss phone numbers, not only the official form.",
        "matches": [
            "0521112233, 052 111 22 33, +41 (0)52 111 22 33, +41 52 111 22 33, 0041 52 111 22 33"
        ],
        "nonMatches": [
            "0041 052 111 22 33, +41 11 22 33 44"
        ],
        "pattern": "^(((((\\+)?(\\s)?(\\d{2,4}))(\\s)?((\\(0\\))?)(\\s)?|0)(\\s|\\-)?)(\\s|\\d{2})(\\s|\\-)?)?(\\d{3})(\\s|\\-)?(\\d{2})(\\s|\\-)?(\\d{2})",
        "title": "Test"
    },
    {
        "description": "Verifies all valid Gregorian dates of the form DD MONTH YYYY, and short month names, taking days/month and leap years into account. Accepts space, -, . and / between paramters.",
        "matches": [
            "05 March 2012",
            "29-Feb-2012",
            "31.DEC.2011"
        ],
        "nonMatches": [
            "32 March 2012",
            "29-Feb-2011",
            "2011.DEC.31"
        ],
        "pattern": "^(0[1-9]|[12][0-9]|3[01])[\\s\\.\\-/](J(anuary|uly|an|AN)|M(arch|ar|AR|ay|AY)|A(ugust|ug|UG)|(O(ctober|ct|CT)|(D(ecember|ec|EC))))[\\s\\.\\-/][1-9][0-9]{3}|(0[1-9]|[12][0-9]|30)[\\s\\.\\-/](A(pril|pr|PR)|J(une|un|UN)|S(eptember|ep|EP)|N(ovember|ov|OV))[\\s\\.\\-/][1-9][0-9]{3}|(0[1-9]|1[0-9]|2[0-8])[\\s\\.\\-/]F(ebruary|eb|EB)[\\s\\.\\-/][1-9][0-9]{3}|29[\\s\\.\\-/]F(ebruary|eb|EB)[\\s\\.\\-/]((0[48]|[2468][048]|[13579][26])00|[0-9]{2}(0[48]|[2468][048]|[13579][26]))$",
        "title": "Test"
    },
    {
        "description": "also matches youtu.be/video_id, the video id is at $9",
        "matches": [
            "http://www.youtube.com/watch?v=lK-zaWCp-co\u0026feature=g-all-u\u0026context=G27a8a4aFAAAAAAAAAAA",
            "http://youtu.be/AXaoi6dz59A",
            "youtube.com/watch?gl=NL\u0026hl=nl\u0026feature=g-vrec\u0026context=G2584313RVAAAAAAAABA\u0026v=35LqQPKylEA",
            "https://youtube.com/watch?gl=NL\u0026hl=nl\u0026feature=g-vrec\u0026context=G2584313RVAAAAAAAABA\u0026v=35LqQPKylEA"
        ],
        "nonMatches": [
            "http://www.mytube.com/watch?v=35LqQPKylEA",
            "http://www.youtube.com/watch?b=35LqQPKylEA",
            "www.youtube.com"
        ],
        "pattern": "^(http(s?):\\/\\/)?(www\\.)?youtu(be)?\\.([a-z])+\\/(watch(.*?)(\\?|\\\u0026)v=)?(.*?)(\u0026(.)*)?$",
        "title": "Test"
    },
    {
        "description": "Validates dates in the format MM/DD/YYYY, M/D/YYYY, or any permutation in between. Takes into account leap year as well as the rule that century marks are leap years only if they are divisible by 400.",
        "matches": [
            "1/30/2012",
            "2/29/2012",
            "02/29/2400"
        ],
        "nonMatches": [
            "04/31/2000",
            "02/29/2100",
            "2/30/2012"
        ],
        "pattern": "^(?!0?2/3)(?!0?2/29/.{3}[13579])(?!0?2/29/.{2}[02468][26])(?!0?2/29/.{2}[13579][048])(?!(0?[469]|11)/31)(?!0?2/29/[13579][01345789]0{2})(?!0?2/29/[02468][1235679]0{2})(0?[1-9]|1[012])/(0?[1-9]|[12][0-9]|3[01])/([0-9]{4})$",
        "title": "Test"
    },
    {
        "description": "This expression matches two different formats of zip codes: 5 digit US ZIP code and 5 digit US ZIP code + 4.The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits.",
        "matches": [
            "12345",
            "12345-1234"
        ],
        "nonMatches": [
            "00000",
            "123451234",
            "12345-0000",
            "00000-0000",
            "00000-1234",
            "000001234"
        ],
        "pattern": "(^(?!0{5})(\\d{5})(?!-?0{4})(|-\\d{4})?$)",
        "title": "Test"
    },
    {
        "description": "indian mobile number perfect validation for three number series\u0027s that start with 9,8,7. if you want you can easily add one more series that you want in feature. it validates 10 digit number starting with 9,8,7 and followed by 9 digits 0-9 in any order.",
        "matches": [
            "9848012345,804812345,7000000000"
        ],
        "nonMatches": [
            "6897895648,+919848012345"
        ],
        "pattern": "^([987]{1})(\\d{1})(\\d{8})",
        "title": "Test"
    },
    {
        "description": "Jordan mobile numbers, Zain,Umniah and Orange provider .",
        "matches": [
            "0795144145,0786654433,0771471471"
        ],
        "nonMatches": [
            "0886547826,A078655555,951951753"
        ],
        "pattern": "((079)|(078)|(077)){1}[0-9]{7}",
        "title": "Test"
    },
    {
        "description": "matches australian phone numbers",
        "matches": [
            "131234, 13 1 2 3 4, 1300 1 2 3 4 5 6 7 8,130012345678,04 1 2 3 4 5 6 7 8,(04) 123 456 78,(08) 12 34 56 78,07 12345678"
        ],
        "nonMatches": [
            "(08 1234 5678,07)12345678"
        ],
        "pattern": "(^13((\\ )?\\d){4}$)|(^1[38]00((\\ )?\\d){6}$)|(^(((\\(0[23478]\\))|(0[23478]))(\\ )?)?\\d((\\ )?\\d){7}$)",
        "title": "Test"
    },
    {
        "description": "This regex will search for all relation types like father, mother, grand father, cousin, brother, etc..",
        "matches": [
            "Grandmother",
            "Grandpop",
            "granddaughters",
            "Mother",
            "Father"
        ],
        "nonMatches": [
            "Granmother",
            "Fath er",
            "Grand pa",
            "Grand Ma"
        ],
        "pattern": "(([Gg]rand)?([Ff]ather|[Mm]other|mom|pop|son|daughter|parent|((p|m)a)|uncle|aunt)s?)|(([cC]ousin)?((?\u003C=[cC]ousin)\\s+(?=brother|sister))?(?\u003Csiblings\u003Ebrother|sister)?((?\u003C=brother|sister)s?)?)",
        "title": "Test"
    },
    {
        "description": "This regular expression provides a way to get the value associated to the specified key in the specified section: replace with $1.",
        "matches": [
            "[section] \\n key=value"
        ],
        "nonMatches": [
            "[section] \\n [another] \\n key=value"
        ],
        "pattern": "[^]*\\[section\\][^\\[]*\\nkey=(.+)[^]*",
        "title": "Test"
    },
    {
        "description": "Validate date with arabic numeral of the form dd/mm/yy or dd/mm/yy or dd-mm-yy or dd-mm-yyyy or dd.mm.yy or dd.mm.yyyy",
        "matches": [
            "\u0661\u0661/\u0660\u0661/\u0662\u0660 \u0662\u0669-\u0662-\u0662\u0660 \u0662\u0669/\u0662/\u0662\u0660 \u0661\u0661/\u0661\u0661/\u0662\u0660\u0661\u0661"
        ],
        "nonMatches": [
            "\u0661\u0660/\u0663\u0660/\u0661\u0660"
        ],
        "pattern": "^((((\\u0660?[\\u0661-\\u0669]|[\\u0661\\u0662][\\u0660-\\u0669]|\\u0663[\\u0660\\u0661])[\\.\\-\\/](\\u0660?[\\u0661\\u0663\\u0665\\u0667\\u0668]|\\u0661[\\u0660\\u0662])[\\.\\-\\/]((\\u0661[\\u0666-\\u0669]|[\\u0662-\\u0669][\\u0660-\\u0669])?[\\u0660-\\u0669]{2}))|((\\u0660?[\\u0661-\\u0669]|[\\u0661\\u0662][\\u0660-\\u0669]|\\u0663\\u0660)[\\.\\-\\/](\\u0660?[\\u0661\\u0663\\u0664\\u0665\\u0666\\u0667\\u0668\\u0669]|\\u0661[\\u0660\\u0661\\u0662])[\\.\\-\\/]((\\u0661[\\u0666-\\u0669]|[\\u0662-\\u0669][\\u0660-\\u0669])?[\\u0660-\\u0669]{2}))|((\\u0660?[\\u0661-\\u0669]|\\u0661[\\u0660-\\u0669]|\\u0662[\\u0660-\\u0668])[\\.\\-\\/]\\u0660?\\u0662[\\.\\-\\/]((\\u0661[\\u0666-\\u0669]|[\\u0662-\\u0669][\\u0660-\\u0669])?[\\u0660-\\u0669]{2}))|(\\u0662\\u0669[\\.\\-\\/]\\u0660?\\u0662[\\.\\-\\/]((\\u0661[\\u0666-\\u0669]|[\\u0662-\\u0669][\\u0660-\\u0669])?(\\u0660[\\u0664\\u0668]|[\\u0662\\u0664\\u0666\\u0668][\\u0660\\u0664\\u0668]|[\\u0661\\u0663\\u0665\\u0667\\u0669][\\u0662\\u0666])|((\\u0661\\u0666|[\\u0662\\u0664\\u0666\\u0668][\\u0660\\u0664\\u0668]|[\\u0663\\u0665\\u0667\\u0669][\\u0662\\u0666])\\u0660\\u0660)|\\u0660\\u0660)))|(((\\u0660[\\u0661-\\u0669]|[\\u0661\\u0662][\\u0660-\\u0669]|\\u0663[\\u0660\\u0661])(\\u0660[\\u0661\\u0663\\u0665\\u0667\\u0668]|\\u0661[\\u0660\\u0662])((\\u0661[\\u0666-\\u0669]|[\\u0662-\\u0669][\\u0660-\\u0669])?[\\u0660-\\u0669]{2}))|((\\u0660[\\u0661-\\u0669]|[\\u0661\\u0662][\\u0660-\\u0669]|\\u0663\\u0660)(\\u0660[\\u0661\\u0663\\u0664\\u0665\\u0666\\u0667\\u0668\\u0669]|\\u0661[\\u0660\\u0661\\u0662])((\\u0661[\\u0666-\\u0669]|[\\u0662-\\u0669][\\u0660-\\u0669])?[\\u0660-\\u0669]{2}))|((\\u0660[\\u0661-\\u0669]|\\u0661[\\u0660-\\u0669]|\\u0662[\\u0660-\\u0668])\\u0660\\u0662((\\u0661[\\u0666-\\u0669]|[\\u0662-\\u0669][\\u0660-\\u0669])?[\\u0660-\\u0669]{2}))|(\\u0662\\u0669\\u0660\\u0662((\\u0661[\\u0666-\\u0669]|[\\u0662-\\u0669][\\u0660-\\u0669])?(\\u0660[\\u0664\\u0668]|[\\u0662\\u0664\\u0666\\u0668][\\u0660\\u0664\\u0668]|[\\u0661\\u0663\\u0665\\u0667\\u0669][\\u0662\\u0666])|((\\u0661\\u0666|[\\u0662\\u0664\\u0666\\u0668][\\u0660\\u0664\\u0668]|[\\u0663\\u0665\\u0667\\u0669][\\u0662\\u0666])\\u0660\\u0660)|\\u0660\\u0660))))$",
        "title": "Test"
    },
    {
        "description": "Validate date of the form dd/mm/yy or dd/mm/yy or dd-mm-yy or dd-mm-yyyy or dd.mm.yy or dd.mm.yyyy in Arabic or English numerals",
        "matches": [
            "1/12/2001 30/03/90 02/04/09 \u0661\u0661/\u0660\u0661-\u0662\u0660 \u0661\u0661/\u0660\u0661-\u0662\u0660 \u0662\u0669/\u0662/\u0662\u0660\u0661\u0661/\u0661\u0661/\u0662\u0660\u0661\u0661"
        ],
        "nonMatches": [
            "11/13/12 \u0661\u0660-\u0663\u0660-\u0661\u0660"
        ],
        "pattern": "^((((\\u0660?[\\u0661-\\u0669]|[\\u0661\\u0662][\\u0660-\\u0669]|\\u0663[\\u0660\\u0661])[\\.\\-\\/](\\u0660?[\\u0661\\u0663\\u0665\\u0667\\u0668]|\\u0661[\\u0660\\u0662])[\\.\\-\\/]((\\u0661[\\u0666-\\u0669]|[\\u0662-\\u0669][\\u0660-\\u0669])?[\\u0660-\\u0669]{2}))|((\\u0660?[\\u0661-\\u0669]|[\\u0661\\u0662][\\u0660-\\u0669]|\\u0663\\u0660)[\\.\\-\\/](\\u0660?[\\u0661\\u0663\\u0664\\u0665\\u0666\\u0667\\u0668\\u0669]|\\u0661[\\u0660\\u0661\\u0662])[\\.\\-\\/]((\\u0661[\\u0666-\\u0669]|[\\u0662-\\u0669][\\u0660-\\u0669])?[\\u0660-\\u0669]{2}))|((\\u0660?[\\u0661-\\u0669]|\\u0661[\\u0660-\\u0669]|\\u0662[\\u0660-\\u0668])[\\.\\-\\/]\\u0660?\\u0662[\\.\\-\\/]((\\u0661[\\u0666-\\u0669]|[\\u0662-\\u0669][\\u0660-\\u0669])?[\\u0660-\\u0669]{2}))|(\\u0662\\u0669[\\.\\-\\/]\\u0660?\\u0662[\\.\\-\\/]((\\u0661[\\u0666-\\u0669]|[\\u0662-\\u0669][\\u0660-\\u0669])?(\\u0660[\\u0664\\u0668]|[\\u0662\\u0664\\u0666\\u0668][\\u0660\\u0664\\u0668]|[\\u0661\\u0663\\u0665\\u0667\\u0669][\\u0662\\u0666])|((\\u0661\\u0666|[\\u0662\\u0664\\u0666\\u0668][\\u0660\\u0664\\u0668]|[\\u0663\\u0665\\u0667\\u0669][\\u0662\\u0666])\\u0660\\u0660)|\\u0660\\u0660)))|(((\\u0660[\\u0661-\\u0669]|[\\u0661\\u0662][\\u0660-\\u0669]|\\u0663[\\u0660\\u0661])(\\u0660[\\u0661\\u0663\\u0665\\u0667\\u0668]|\\u0661[\\u0660\\u0662])((\\u0661[\\u0666-\\u0669]|[\\u0662-\\u0669][\\u0660-\\u0669])?[\\u0660-\\u0669]{2}))|((\\u0660[\\u0661-\\u0669]|[\\u0661\\u0662][\\u0660-\\u0669]|\\u0663\\u0660)(\\u0660[\\u0661\\u0663\\u0664\\u0665\\u0666\\u0667\\u0668\\u0669]|\\u0661[\\u0660\\u0661\\u0662])((\\u0661[\\u0666-\\u0669]|[\\u0662-\\u0669][\\u0660-\\u0669])?[\\u0660-\\u0669]{2}))|((\\u0660[\\u0661-\\u0669]|\\u0661[\\u0660-\\u0669]|\\u0662[\\u0660-\\u0668])\\u0660\\u0662((\\u0661[\\u0666-\\u0669]|[\\u0662-\\u0669][\\u0660-\\u0669])?[\\u0660-\\u0669]{2}))|(\\u0662\\u0669\\u0660\\u0662((\\u0661[\\u0666-\\u0669]|[\\u0662-\\u0669][\\u0660-\\u0669])?(\\u0660[\\u0664\\u0668]|[\\u0662\\u0664\\u0666\\u0668][\\u0660\\u0664\\u0668]|[\\u0661\\u0663\\u0665\\u0667\\u0669][\\u0662\\u0666])|((\\u0661\\u0666|[\\u0662\\u0664\\u0666\\u0668][\\u0660\\u0664\\u0668]|[\\u0663\\u0665\\u0667\\u0669][\\u0662\\u0666])\\u0660\\u0660)|\\u0660\\u0660)))|(((0?[1-9]|[12]\\d|3[01])[\\.\\-\\/](0?[13578]|1[02])[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}))|((0?[1-9]|[12]\\d|30)[\\.\\-\\/](0?[13456789]|1[012])[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}))|((0?[1-9]|1\\d|2[0-8])[\\.\\-\\/]0?2[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}))|(29[\\.\\-\\/]0?2[\\.\\-\\/]((1[6-9]|[2-9]\\d)?(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)|00)))|(((0[1-9]|[12]\\d|3[01])(0[13578]|1[02])((1[6-9]|[2-9]\\d)?\\d{2}))|((0[1-9]|[12]\\d|30)(0[13456789]|1[012])((1[6-9]|[2-9]\\d)?\\d{2}))|((0[1-9]|1\\d|2[0-8])02((1[6-9]|[2-9]\\d)?\\d{2}))|(2902((1[6-9]|[2-9]\\d)?(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)|00))))$",
        "title": "Test"
    },
    {
        "description": "accepts malaysian mobile number example (011,012,013...) plus 7 additional numbers",
        "matches": [
            "0171234567",
            "0141234567",
            "0167791990"
        ],
        "nonMatches": [
            "0151234567",
            "0211234567",
            "1011234567"
        ],
        "pattern": "^([0])([1])([1,2,3,4,6,7,8,9])([0-9][0-9][0-9][0-9][0-9][0-9][0-9])",
        "title": "Test"
    },
    {
        "description": "allows the new 8 digit numbers aswell as 7 digit numbers without the 015",
        "matches": [
            "01712345677",
            "0141234567",
            "0167791990",
            "01277784921"
        ],
        "nonMatches": [
            "0151234567",
            "021567",
            "101123456734"
        ],
        "pattern": "^01[1,2,3,4,6,7,8,9]\\d{7,8}$",
        "title": "Test"
    },
    {
        "description": "Step 1: Test that the input is a UK phone number. Later patterns extract the prefix, NSN and extension, and further tests check the NSN for length and validity. The above pattern matches optional opening parentheses, followed by 00 or 011 and optional closing parentheses, followed by an optional space or hyphen, followed by optional opening parentheses. Alternatively, the opening parentheses are followed by a literal + without a following space or hyphen. Any of the previous options are then followed by 44 with optional closing parentheses, followed by optional space or hyphen, followed by optional 0 in optional parentheses, followed by optional space or hyphen, followed by optional opening parentheses (international format). Alternatively, the pattern matches optional opening parentheses followed by the 0 trunk code (national format). This is followed by the area code and phone number in 2+8, 3+7, 3+6, 4+6, 4+5, 5+5 or 5+4 format with or without spaces and/or hyphens. This also includes provision for optional closing parentheses and/or optional space or hyphen after where the user thinks the area code ends and the local number begins. The pattern allows any format to be used with any UK number. The display format must be corrected by later logic if the wrong format for this number has been used by the user on input. The pattern finally ends with optional space or hyphen followed by x, ext and optional period, or #, followed by a three or four digit extension number. Once the input has been confirmed as being a telephone number using the above pattern, another RegEx pattern should extract prefix, NSN and extension and then the NSN should be further tested for length and validity. (Order fixed for even greater efficiency: shorter area codes match first.)",
        "matches": [
            "020 3000 5555, (020) 3000 5555, +44 20 3000 5555, 00 44 20 3000 5555, 011 44 20 3000 5555, 0203 000 5555, 02030 005 555, (+44) 20 3000 5555, (+44 20) 3000 5555, and many others, any with NSN of 10 or 9."
        ],
        "nonMatches": [
            "01750 5555, 0203 5555 7777, +33 1 2345 6789"
        ],
        "pattern": "^\\(?(?:(?:0(?:0|11)\\)?[\\s-]?\\(?|\\+)44\\)?[\\s-]?\\(?(?:0\\)?[\\s-]?\\(?)?|0)(?:\\d{2}\\)?[\\s-]?\\d{4}[\\s-]?\\d{4}|\\d{3}\\)?[\\s-]?\\d{3}[\\s-]?\\d{3,4}|\\d{4}\\)?[\\s-]?(?:\\d{5}|\\d{3}[\\s-]?\\d{3})|\\d{5}\\)?[\\s-]?\\d{4,5}|8(?:00[\\s-]?11[\\s-]?11|45[\\s-]?46[\\s-]?4\\d))(?:(?:[\\s-]?(?:x|ext\\.?\\s?|\\#)\\d+)?)$",
        "title": "Test"
    },
    {
        "description": "Step 2: After step 1 has verified the input is likely to be a UK telephone number, this pattern extracts the NSN part of the number so that it can be passed to another routine that will check it for length and validity. $1 is 44 (international format) or null (use 0 for trunk code - national format). $2 is the NSN. $3 is the extension number.",
        "matches": [
            "020 3000 5555, (020) 3000 5555, +44 20 3000 5555, 00 44 20 3000 5555, 011 44 20 3000 5555, 0203 000 5555, 02030 005 555, (+44) 20 3000 5555, (+44 20) 3000 5555, and many others, any with NSN of 10 or 9."
        ],
        "nonMatches": [
            "01750 5555, 0203 5555 7777, +33 1 2345 6789"
        ],
        "pattern": "^\\(?(?:(?:0(?:0|11)\\)?[\\s-]?\\(?|\\+)(44)\\)?[\\s-]?\\(?(?:0\\)?[\\s-]?\\(?)?|0)([1-9]\\d{1,4}\\)?[\\s\\d-]+)(?:((?:x|ext\\.?\\s?|\\#)\\d+)?)$",
        "title": "Test"
    },
    {
        "description": "Step 3: Validate the NSN produced from the pattern in step 2 and check it for length and validity. The pattern here is fairly basic. More detailed patterns for each number type are available elsewhere. Step 4 is to format the number correctly. This needs a variety of RegEx patterns each based on the initial digits and number length.",
        "matches": [
            "20 3000 5555, 121 555 7777, 1750 618888, 1750 62555, 19467 55555, 16977 3555, 303 555 7788, 500 777999, 55 4455 7788, 70 7788 5577, 800 555777, 800 444 7799, 845 333 5577, 871 444 5577, 909 555 7788 after removing spaces"
        ],
        "nonMatches": [
            "20 444 666, 20 555 7777, 1999 5577, 1999 555 7799, 22 5000 7777, 800 55555, 803 555777, 815 555 7777, 845 8888 9999"
        ],
        "pattern": "^((1[1-9]|2[03489]|3[0347]|5[56]|7[04-9]|8[047]|9[018])\\d{8}|(1[2-9]\\d|[58]00)\\d{6}|8(001111|45464\\d))$",
        "title": "Test"
    },
    {
        "description": "Step 3: Validate the NSN produced from the pattern in step 2 and check it for length and validity. The pattern here is very detailed matching every valid UK prefix, and rejecting large numbers of non-valid ranges. Step 4 will be to format the number correctly. This needs a variety of RegEx patterns each based on the initial digits and number length as shown in the article mentioned below.",
        "matches": [
            "20 3000 5555, 121 555 7777, 1750 618888, 1750 62555, 19467 55555, 16977 3555, 303 555 7788, 500 777999, 55 4455 7788, 70 7788 5577, 800 555777, 800 444 7799, 845 333 5577, 871 444 5577, 909 555 7788 after removing spaces"
        ],
        "nonMatches": [
            "20 444 666, 20 555 7777, 1750 61555, 1999 55777, 1999 555777, 22 5000 7777, 800 55555, 803 555777, 805 555 7777, 845 8888 9999"
        ],
        "pattern": "^(2(?:0[01378]|3[0189]|4[017]|8[0-46-9]|9[012])\\d{7}|1(?:(?:1(?:3[0-48]|[46][0-4]|5[012789]|7[0-49]|8[01349])|21[0-7]|31[0-8]|[459]1\\d|61[0-46-9]))\\d{6}|1(?:2(?:0[024-9]|2[3-9]|3[3-79]|4[1-689]|[58][02-9]|6[0-4789]|7[013-9]|9\\d)|3(?:0\\d|[25][02-9]|3[02-579]|[468][0-46-9]|7[1235679]|9[24578])|4(?:0[03-9]|2[02-5789]|[37]\\d|4[02-69]|5[0-8]|[69][0-79]|8[0-5789])|5(?:0[1235-9]|2[024-9]|3[0145689]|4[02-9]|5[03-9]|6\\d|7[0-35-9]|8[0-468]|9[0-5789])|6(?:0[034689]|2[0-689]|[38][013-9]|4[1-467]|5[0-69]|6[13-9]|7[0-8]|9[0124578])|7(?:0[0246-9]|2\\d|3[023678]|4[03-9]|5[0-46-9]|6[013-9]|7[0-35-9]|8[024-9]|9[02-9])|8(?:0[35-9]|2[1-5789]|3[02-578]|4[0-578]|5[124-9]|6[2-69]|7\\d|8[02-9]|9[02569])|9(?:0[02-589]|2[02-689]|3[1-5789]|4[2-9]|5[0-579]|6[234789]|7[0124578]|8\\d|9[2-57]))\\d{6}|1(?:2(?:0(?:46[1-4]|87[2-9])|545[1-79]|76(?:2\\d|3[1-8]|6[1-6])|9(?:7(?:2[0-4]|3[2-5])|8(?:2[2-8]|7[0-4789]|8[345])))|3(?:638[2-5]|647[23]|8(?:47[04-9]|64[015789]))|4(?:044[1-7]|20(?:2[23]|8\\d)|6(?:0(?:30|5[2-57]|6[1-8]|7[2-8])|140)|8(?:052|87[123]))|5(?:24(?:3[2-79]|6\\d)|276\\d|6(?:26[06-9]|686))|6(?:06(?:4\\d|7[4-79])|295[567]|35[34]\\d|47(?:24|61)|59(?:5[08]|6[67]|74)|955[0-4])|7(?:26(?:6[13-9]|7[0-7])|442\\d|50(?:2[0-3]|[3-68]2|76))|8(?:27[56]\\d|37(?:5[2-5]|8[239])|84(?:3[2-58]))|9(?:0(?:0(?:6[1-8]|85)|52\\d)|3583|4(?:66[1-8]|9(?:2[01]|81))|63(?:23|3[1-4])|9561))\\d{3}|176888[234678]\\d{2}|16977[23]\\d{3})|7(?:[1-4]\\d\\d|5(?:0[0-8]|[13-9]\\d|2[0-35-9])|624|7(?:0[1-9]|[1-7]\\d|8[02-9]|9[0-689])|8(?:[014-9]\\d|[23][0-8])|9(?:[04-9]\\d|1[02-9]|2[0-35-9]|3[0-689]))\\d{6}|76(?:0[012]|2[356]|4[0134]|5[49]|6[0-369]|77|81|9[39])\\d{6}|80(?:0(?:1111|\\d{6,7})|8\\d{7})|500\\d{6}|87[123]|9(?:[01]\\d|8[0-3]))\\d{7}|8(?:4(?:5464\\d|[2-5]\\d{7})|70\\d{7})|70\\d{8}|56\\d{8}|3[0347]|55)\\d{8}$",
        "title": "Test"
    },
    {
        "description": "Regex for postal code in Portugal",
        "matches": [
            "4785-252"
        ],
        "nonMatches": [
            "12345"
        ],
        "pattern": "[0-9]{4}-[0-9]{3}",
        "title": "Test"
    },
    {
        "description": "Regex for valid folder name. 1. Do not allow \\ / : * ? \u0022\u003C\u003E | any where in the language (folder) name. 2. Do not allow . at beginning or end of text. \u0027.\u0027 can present in middle of text.",
        "matches": [
            "ValidFolder.Name",
            "Folder!@#$%^\u0026()",
            "New Folder"
        ],
        "nonMatches": [
            "InvalidFolderName\u003E",
            "InvalidFolder.",
            "Invalid\u003C\u003EFolder"
        ],
        "pattern": "^[^\\\\/:*?\u0022\u0022\u003C\u003E|.][^\\\\/:*?\u0022\u0022\u003C\u003E|]*(?\u003C!\\.)(^[^\\\\/:*?\u0022\u0022\u003C\u003E|]|$)|^$",
        "title": "Test"
    },
    {
        "description": "\\1 references the method signature (eg main(String[] args)), \\2 references the method name (eg main), \\3 references the args (eg String[] args), and \\4 and up reference each arg in turn (including type names). Supports @interfaces, java keywords/primitives, generic classes (including bounded and unbounded parameters), varargs, and array classes, but due to recursion limitations, generic types can only go one level deep (List\u003CString\u003E is ok, but List\u003CList\u003CString\u003E\u003E isn\u0027t). Does not match Constructors.",
        "matches": [
            "public static void main(String... args)"
        ],
        "nonMatches": [
            "public static void Main(string... args)"
        ],
        "pattern": "(?:@[A-Z]\\w*\\s+)*(?:(?:public|private|protected)\\s+)?(?:(?:(?:abstract|final|native|transient|static|synchronized)\\s+)*(?:\u003C(?:\\?|[A-Z]\\w*)(?:\\s+(?:extends|super)\\s+[A-Z]\\w*)?(?:(?:,\\s*(?:\\?|[A-Z]\\w*))(?:\\s+(?:extends|super)\\s+[A-Z]\\w*)?)*\u003E\\s+)?(?:(?:(?:[A-Z]\\w*(?:\u003C[A-Z]\\w*\u003E)?|int|float|double|char|byte|long|short|boolean)(?:(?:\\[\\]))*)|void)+)\\s+(([a-zA-Z]\\w*)\\s*\\(\\s*(((?:[A-Z]\\w*(?:\u003C(?:\\?|[A-Z]\\w*)(?:\\s+(?:extends|super)\\s+[A-Z]\\w*)?(?:(?:,\\s*(?:\\?|[A-Z]\\w*))(?:\\s+(?:extends|super)\\s+[A-Z]\\w*)?)*\u003E)?|int|float|double|char|boolean|byte|long|short)(?:(?:\\[\\])|\\.\\.\\.)?\\s+[a-z]\\w*)(?:,\\s*((?:[A-Z]\\w*(?:\u003C[A-Z]\\w*\u003E)?|int|float|double|char|byte|long|short|boolean)(?:(?:\\[\\])|\\.\\.\\.)?\\s+[a-z]\\w*))*)?\\s*\\))",
        "title": "Test"
    },
    {
        "description": "numeros telefonicos de venezuela",
        "matches": [
            "0416-1239977 0424-1115588"
        ],
        "nonMatches": [
            "0416-239977 04241115588 123 sapo"
        ],
        "pattern": "^0[0-9]{3}-[0-9]{7}$",
        "title": "Test"
    },
    {
        "description": "Validation to Brazilian telephone number (mobile or not), including DDD and allowing \u00229o D\u00EDgito\u0022 (on all DDDs). It also accept 2 or 3 digit DDD (11 or 011). ----- Valid to: ----- 11 98989-9090, 11 977777777, 83-8855-8981, 1199999888, 011 42511992, 01142511992, 011-42511992, 011 4251-1992, 011-4251-1992, 011 98989-9090, 011 977777777, 083-8855-8981, 011999998888, 083 4251-1010, 01192222-3333 ----- Invalid to: ----- 011 9898-90909, 08 98989-9090, 083 4251.1010",
        "matches": [
            "1142511992",
            "11 42511992",
            "11-42511992",
            "11 4251-1992",
            "11-4251-1992",
            "011 98989-9090"
        ],
        "nonMatches": [
            "08 98989-9090",
            "083 4251.1010",
            "011 9898-90909"
        ],
        "pattern": "^(0{0,1}[1-9][0-9]){1}(\\s){0,1}(\\-){0,1}(\\s){0,1}[1-9]{1}([0-9]{3}|[0-9]{4})(\\-){0,1}(\\s){0,1}[0-9]{4}$",
        "title": "Test"
    },
    {
        "description": "match isbn 10 and 13",
        "matches": [
            "978-1-4302-1998-9",
            "1\u2013931836\u201359\u20130",
            "1593270127",
            "0 321 15420 7",
            "978-0-07-162612-5"
        ],
        "nonMatches": [
            "978-0-07-1626125",
            "15932701X7",
            "970-0-596-52678-8"
        ],
        "pattern": "/((978[\\--\u2013 ])?[0-9][0-9\\--\u2013 ]{10}[\\--\u2013 ][0-9xX])|((978)?[0-9]{9}[0-9Xx])/",
        "title": "Test"
    },
    {
        "description": "This is the real regex for a non-railroad board HICN. All combinations are accounted for. This does not account for dashes as they are stripped out before I do the validation. This also only allows 001-772 as the first 3 numbers per spec. It does not take into consideration that 00 is not allowed for 4th and 5th digits and that 0000 is not allowed for last 4 digits.",
        "matches": [
            "123456789F1 123456789W"
        ],
        "nonMatches": [
            "1234567890 A000000 WCD000000 123-45-6789A"
        ],
        "pattern": "^(00[1-9]|0[1-9][0-9]|[1-7][0-9][0-9]|7[0-7][0-2]|77[0-2])(\\d{6})(A|B([1-9]?|[ADGHJKLNPQRTWY])|C([1-9]|[A-Z])|D([1-9]?|[ACDGHJKLMNPQRSTVWXYZ])|E([1-9]?|[ABCDFGHJKM])|F([1-8])|J([1-4])|K([1-9]|[ABCDEFGHJLM])|T([ABCDEFGHJKLMNPQRSTUVWXYZ2]?)|M|W([1-9]?|[BCFGJRT]))$",
        "title": "Test"
    },
    {
        "description": "Regular exp to match the VTU USN",
        "matches": [
            "3gn01cs009, 4PD09EC016"
        ],
        "nonMatches": [
            "gn000cde09"
        ],
        "pattern": "@\u0022^\\d[a-zA-Z]\\w{1}\\d{2}[a-zA-Z]\\w{1}\\d{3}$\u0022",
        "title": "Test"
    },
    {
        "description": "for cut links on PHP $text = preg_replace(\u0022/\u003Ca[\\s]+[^\u003E]*?.*?\u003E([^\u003C]+|.*?)?\u003C\\/a\u003E/s\u0022,\u0022\u0022,$text);",
        "matches": [
            "\u003Ca href=\u0022http://www.tss-s.ru/index.php?option=com_content&task=view&id=170&Itemid=75\u0022\u003E\u041A\u0410\u0417\u0410\u0425\u0421\u0422\u0410\u041D\u003C/a\u003E"
        ],
        "nonMatches": [
            "\u003Ca href=\u0022http://www.tss-s.ru/index.php?option=com_content&task=view&id=170&Itemid=75\u0022\u003E\u041A\u0410\u0417\u0410\u0425\u0421\u0422\u0410\u041D\u003C /a\u003E"
        ],
        "pattern": "\u003Ca[\\s]+[^\u003E]*?.*?\u003E([^\u003C]+|.*?)?\u003C\\/a\u003E",
        "title": "Test"
    },
    {
        "description": "Medicare number validation:XXXYYYYYYYYYZBBXXX- can be up to 3 letters. Not requiredYYY- 9 digits \u2013 requiredZ- must be letter. No number. Not requiredBB- can be letter or numbers. Not required. Can only exist if Z is exists.",
        "matches": [
            "ABC123456789A12"
        ],
        "nonMatches": [
            "CA1234567885"
        ],
        "pattern": "^([A-Z]{0,3}?[0-9]{9}($[0-9]{0}|[A-Z]{1}))",
        "title": "Test"
    },
    {
        "description": "This expression will fail if the host/domain does not end with @gmail.com",
        "matches": [
            "tester@gmail.com"
        ],
        "nonMatches": [
            "tester@gmail.nettester@bob.com"
        ],
        "pattern": "(\\w+([-+.\u0027]\\w+)*@(gmail.com))",
        "title": "Test"
    },
    {
        "description": "Validates yyyy.MM.dd and yyyy-MM-dd format date,and also verifying leap years.",
        "matches": [
            "2000.02.29",
            "1976.11.10",
            "1988-02-29"
        ],
        "nonMatches": [
            "2001.02.29",
            "1980.04.31",
            "1977-05-32"
        ],
        "pattern": "^((((19|20)(([02468][048])|([13579][26])).02.29))|((20[0-9][0-9])|(19[0-9][0-9])).((((0[1-9])|(1[0-2])).((0[1-9])|(1[0-9])|(2[0-8])))|((((0[13578])|(1[02])).31)|(((0[1,3-9])|(1[0-2])).(29|30)))))$",
        "title": "Test"
    },
    {
        "description": "Celeac management",
        "matches": [
            "Celiac management"
        ],
        "nonMatches": [
            "Management of Celiac"
        ],
        "pattern": "Celiac management",
        "title": "Test"
    },
    {
        "description": "Matches all valid mobile numbers, landline numbers, share call etc in all common phone number notations",
        "matches": [
            "+27-11-399-7206"
        ],
        "nonMatches": [
            "075-356-6364"
        ],
        "pattern": "^((0|(\\(0\\)))?|(00|(\\(00\\)))?(\\s?|-?)(27|\\(27\\))|((\\+27))|(\\(\\+27\\))|\\(00(\\s?|-?)27\\))( |-)?(\\(?0?\\)?)( |-)?\\(?(1[0-9]|2[1-4,7-9]|3[1-6,9]|4[0-9]|5[1,3,6-9]|7[1-4,6,8,9]|8[0-9])\\)?(\\s?|-?)((\\d{3}(\\s?|-?)\\d{4}$)|((\\d{4})(\\s?|-?)(\\d{3})$)|([0-2](\\s?|-?)(\\d{3}(\\s?|-?)\\d{3}$)))",
        "title": "Test"
    },
    {
        "description": "Validates completely for relative and absolute paths, and allows port definitions. Also contains parameter validation, and allows for anchors and URL escape characters.",
        "matches": [
            "http://www.google.com",
            "https://sub.domain.com:8080/ok",
            "mobi.yoursite.org/%e3498549843",
            "/relative_path/ok/home.aspx?id=4985\u0026x=5"
        ],
        "nonMatches": [
            "http://site.com/?id=4095?x=485",
            "http://site.com:3098594",
            "www.site.org?p=this is wrong"
        ],
        "pattern": "^((http(s){0,1}\\:\\/\\/){0,1}([a-z|A-Z|0-9|\\.|\\-|_]){4,255}(\\:\\d{1,5}){0,1}){0,1}((\\/([a-z|A-Z|0-9|\\.|\\-|_]|\\%[A-F|a-f|0-9]{2}){1,255}){1,255}\\/{0,1}){0,1}(|\\/{0,1}\\?[a-z|A-Z|0-9|\\.|\\-|_]{1,255}\\=([a-z|A-Z|0-9|\\.|\\-|_|\\+|\\:]|\\%[A-F|a-f|0-9]{2}|\\\u0026[a-z|A-Z]{2,12}\\;){0,255}){0,1}((\\\u0026[a-z|A-Z|0-9|\\.|\\-|_]{1,255}\\=([a-z|A-Z|0-9|\\.|\\-|_|\\+|\\:]|\\%[A-F|a-f|0-9]{2}|\\\u0026[a-z|A-Z]{2,12}\\;){0,255}){0,255})(\\/{0,1}|\\#([a-z|A-Z|0-9|\\.|\\-|_|\\+|\\:]|\\%[A-F|a-f|0-9]{2}|\\\u0026[a-z|A-Z]{2,12}\\;){0,255})$",
        "title": "Test"
    },
    {
        "description": "Password requires at least 1 lower case character, 1 upper case character, 1 number, 1 special character and must be at least 6 characters and at most 50",
        "matches": [
            "Abcde1!",
            "Abcde1$",
            "ABCDe1!"
        ],
        "nonMatches": [
            "abcde1!",
            "ABCDE1!",
            "abcdef"
        ],
        "pattern": "((?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[\\W_]).{6,50})",
        "title": "Test"
    },
    {
        "description": "Saudi mobile numbers must start with 05 and just accepts 10 digits",
        "matches": [
            "059ddddddd , 053dddddddd , 054dddddddd , 056dddddddd,053dddddd"
        ],
        "nonMatches": [
            "01dddddddd"
        ],
        "pattern": "05\\d{8}",
        "title": "Test"
    },
    {
        "description": "Match Text in square braces",
        "matches": [
            "I love [INDIA]"
        ],
        "nonMatches": [
            "i love india"
        ],
        "pattern": "(?\u003C=[[]).*?(?=[]])",
        "title": "Test"
    },
    {
        "description": "IFSC Code normally contains 11 characters.In that first 4 characters are alphabets,5th character is 0 and next 6 characters are numerics",
        "matches": [
            "CITI0344444"
        ],
        "nonMatches": [
            "CITI3444444"
        ],
        "pattern": "[A-Z|a-z]{4}[0][\\d]{6}$",
        "title": "Test"
    },
    {
        "description": "This Expression validates first 3 are alphabets and 4th character is specifically P,C,H,G,A,T,B,L,I,J,G and next 4 characters are numeric and last character is alphabet",
        "matches": [
            "ALUPC6117h"
        ],
        "nonMatches": [
            "ALUPC61171"
        ],
        "pattern": "^[\\w]{3}(p|P|c|C|h|H|f|F|a|A|t|T|b|B|l|L|j|J|g|G)[\\w][\\d]{4}[\\w]$",
        "title": "Test"
    },
    {
        "description": "Very secure RegEx pattern control for your date entries in english/us format YYYY/MM/DD or YYYY-MM-DD (very easy to only authorize / or -). 28,29,30,31 days month are controled according to the month \u0026 leap year. Check it ! Tested and functionnal !",
        "matches": [
            "2016-02-29",
            "2012-04-30",
            "2019/09/31"
        ],
        "nonMatches": [
            "2016-02-30",
            "2012-04-31",
            "2019/09/35"
        ],
        "pattern": "(((19|20)([2468][048]|[13579][26]|0[48])|2000)/02/29|((19|20)[0-9]{2}/(0[469]|11)/(0[1-9]|[12][0-9]|30)|(19|20)[0-9]{2}/(0[13578]|1[02])/(0[1-9]|[12][0-9]|3[01])|(19|20)[0-9]{2}/02/(0[1-9]|1[0-9]|2[0-8])))",
        "title": "Test"
    },
    {
        "description": "Very secure MySQL datetime RegEx pattern control. Strictly allow the following format only : \u0022YYYY-MM-DD HH:MM:SS\u0022 Verify if date is correct (28,29,30,31 days accoring to the month. Leap years with 29/02 also controled.",
        "matches": [
            "2013-04-05 17:59:59",
            "2013-07-30 01:22:42",
            "2099-12-30 23:59:59",
            "2016-02-28 00:00:00"
        ],
        "nonMatches": [
            "2016-02-29 -01:01:02",
            "3000-04-24 17:42:21",
            "2012-03-03 24:24:02",
            "2012-03-03 21:60:45"
        ],
        "pattern": "((((19|20)([2468][048]|[13579][26]|0[48])|2000)-02-29|((19|20)[0-9]{2}-(0[469]|11)-(0[1-9]|[12][0-9]|30)|(19|20)[0-9]{2}-(0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01])|(19|20)[0-9]{2}-02-(0[1-9]|1[0-9]|2[0-8])))\\s([01][0-9]|2[0-3]):([012345][0-9]):([012345][0-9]))",
        "title": "Test"
    },
    {
        "description": "Validates mobile and land-line numbers. Also validates international Portuguese code +351.",
        "matches": [
            "217896545",
            "+351214563214",
            "917894125",
            "00351917896352"
        ],
        "nonMatches": [
            "dfsdfdf9122222",
            "528521445",
            "+6542544545"
        ],
        "pattern": "((\\+351|00351|351)?)(2\\d{1}|(9(3|6|2|1)))\\d{7}",
        "title": "Test"
    },
    {
        "description": "An inefficient number validator. PHP and JavaScript compatible. Dashes [-] can be replaced by \u0022\u0022 or \u0022.\u0022 Support for extention /000",
        "matches": [
            "+000-000-000-0000",
            "(+000) 000 000 0000",
            "(+000) (000) 000-0000",
            "(000) 000-0000",
            "+1-800-0000000",
            "+1-800-RLYCOOL"
        ],
        "nonMatches": [
            "1-800-0000000",
            "1-800-RLYCOOL"
        ],
        "pattern": "^([(]?[+]{1}[0-9]{1,3}[)]?[ .\\-]?)?[(]?[0-9]{3}[)]?[ .\\-]?([0-9]{3}[ .\\-]?[0-9]{4}|[a-zA-Z0-9]{7})([ .\\-]?[/]{1}[ .\\-]?[0-9]{2,4})?$",
        "title": "Test"
    },
    {
        "description": "RFC822 email address validator. A bit outdated. Please confirm with current RFC document. PHP and JavaScript compatible.",
        "matches": [
            "See http://code.iamcal.com/php/rfc822/tests/"
        ],
        "nonMatches": [
            "See http://code.iamcal.com/php/rfc822/tests/"
        ],
        "pattern": "^(?!(?:(?:\\\\x22?\\\\x5C[\\\\x00-\\\\x7E]\\\\x22?)|(?:\\\\x22?[^\\\\x5C\\\\x22]\\\\x22?)){255,})(?!(?:(?:\\\\x22?\\\\x5C[\\\\x00-\\\\x7E]\\\\x22?)|(?:\\\\x22?[^\\\\x5C\\\\x22]\\\\x22?)){65,}@)(?:(?:[\\\\x21\\\\x23-\\\\x27\\\\x2A\\\\x2B\\\\x2D\\\\x2F-\\\\x39\\\\x3D\\\\x3F\\\\x5E-\\\\x7E]+)|(?:\\\\x22(?:[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7F]|(?:\\\\x5C[\\\\x00-\\\\x7F]))*\\\\x22))(?:\\\\.(?:(?:[\\\\x21\\\\x23-\\\\x27\\\\x2A\\\\x2B\\\\x2D\\\\x2F-\\\\x39\\\\x3D\\\\x3F\\\\x5E-\\\\x7E]+)|(?:\\\\x22(?:[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7F]|(?:\\\\x5C[\\\\x00-\\\\x7F]))*\\\\x22)))*@(?:(?:(?!.*[^.]{64,})(?:(?:(?:xn--)?[a-z0-9]+(?:-[a-z0-9]+)*\\\\.){1,126}){1,}(?:(?:[a-z][a-z0-9]*)|(?:(?:xn--)[a-z0-9]+))(?:-[a-z0-9]+)*)|(?:\\\\[(?:(?:IPv6:(?:(?:[a-f0-9]{1,4}(?::[a-f0-9]{1,4}){7})|(?:(?!(?:.*[a-f0-9][:\\\\]]){7,})(?:[a-f0-9]{1,4}(?::[a-f0-9]{1,4}){0,5})?::(?:[a-f0-9]{1,4}(?::[a-f0-9]{1,4}){0,5})?)))|(?:(?:IPv6:(?:(?:[a-f0-9]{1,4}(?::[a-f0-9]{1,4}){5}:)|(?:(?!(?:.*[a-f0-9]:){5,})(?:[a-f0-9]{1,4}(?::[a-f0-9]{1,4}){0,3})?::(?:[a-f0-9]{1,4}(?::[a-f0-9]{1,4}){0,3}:)?)))?(?:(?:25[0-5])|(?:2[0-4][0-9])|(?:1[0-9]{2})|(?:[1-9]?[0-9]))(?:\\\\.(?:(?:25[0-5])|(?:2[0-4][0-9])|(?:1[0-9]{2})|(?:[1-9]?[0-9]))){3}))\\\\]))$",
        "title": "Test"
    },
    {
        "description": "Validate Firstname or Lastname (PHP and JavaScript Compatible). Support for Local characters. Max Length 63 characters.",
        "matches": [
            "Name",
            "Name\u0027s",
            "N\u00E0m\u00E9",
            "Name Jr"
        ],
        "nonMatches": [
            "N_ame",
            "Name\u0022s"
        ],
        "pattern": "^[\\w\u00E0\u00E8\u00EC\u00F2\u00F9\u00C0\u00C8\u00CC\u00D2\u00D9\u00E1\u00E9\u00ED\u00F3\u00FA\u00FD\u00C1\u00C9\u00CD\u00D3\u00DA\u00DD\u00E2\u00EA\u00EE\u00F4\u00FB\u00C2\u00CA\u00CE\u00D4\u00DB\u00E4\u00EB\u00EF\u00F6\u00FC\u00FF\u00C4\u00CB\u00CF\u00D6\u00DC\u0178\u00E5\u00C5\u00E6\u00C6\u00E3\u00F1\u00F5\u00C3\u00D1\u00D5\u00E7\u00C7\u00F0\u00D0\u00F8\u00D8\u0153\u0161\u0160\u0152\u00DF\u00BF\u00A1]{1}[\\w \u00E0\u00E8\u00EC\u00F2\u00F9\u00C0\u00C8\u00CC\u00D2\u00D9\u00E1\u00E9\u00ED\u00F3\u00FA\u00FD\u00C1\u00C9\u00CD\u00D3\u00DA\u00DD\u00E2\u00EA\u00EE\u00F4\u00FB\u00C2\u00CA\u00CE\u00D4\u00DB\u00E4\u00EB\u00EF\u00F6\u00FC\u00FF\u00C4\u00CB\u00CF\u00D6\u00DC\u0178\u00E5\u00C5\u00E6\u00C6\u00E3\u00F1\u00F5\u00C3\u00D1\u00D5\u00E7\u00C7\u00F0\u00D0\u00F8\u00D8\u0153\u0161\u0160\u0152\u00DF\u00BF\u00A1\\\u0027]{4,62}$",
        "title": "Test"
    },
    {
        "description": "Matches two words or One company name. (PHP and JavaScript compatible). Support for local characters.",
        "matches": [
            "Firstname Lastname",
            "Company",
            "Company\u0027s Name",
            "F\u00ECrstn\u00E2m\u00E9_L\u00E0stn\u00E1m\u00E8",
            "F\u00ECrstn\u00E2m\u00E9.L\u00E0stn\u00E1m\u00E8"
        ],
        "nonMatches": [
            "_Firstname L_astname",
            "Company\u0022s Name"
        ],
        "pattern": "^[\\w\u00E0\u00E8\u00EC\u00F2\u00F9\u00C0\u00C8\u00CC\u00D2\u00D9\u00E1\u00E9\u00ED\u00F3\u00FA\u00FD\u00C1\u00C9\u00CD\u00D3\u00DA\u00DD\u00E2\u00EA\u00EE\u00F4\u00FB\u00C2\u00CA\u00CE\u00D4\u00DB\u00E4\u00EB\u00EF\u00F6\u00FC\u00FF\u00C4\u00CB\u00CF\u00D6\u00DC\u0178\u00E5\u00C5\u00E6\u00C6\u00E3\u00F1\u00F5\u00C3\u00D1\u00D5\u00E7\u00C7\u00F0\u00D0\u00F8\u00D8\u0153\u0161\u0160\u0152\u00DF\u00BF\u00A1]{2,24}[_ \\-.]{1}[\\w \u00E0\u00E8\u00EC\u00F2\u00F9\u00C0\u00C8\u00CC\u00D2\u00D9\u00E1\u00E9\u00ED\u00F3\u00FA\u00FD\u00C1\u00C9\u00CD\u00D3\u00DA\u00DD\u00E2\u00EA\u00EE\u00F4\u00FB\u00C2\u00CA\u00CE\u00D4\u00DB\u00E4\u00EB\u00EF\u00F6\u00FC\u00FF\u00C4\u00CB\u00CF\u00D6\u00DC\u0178\u00E5\u00C5\u00E6\u00C6\u00E3\u00F1\u00F5\u00C3\u00D1\u00D5\u00E7\u00C7\u00F0\u00D0\u00F8\u00D8\u0153\u0161\u0160\u0152\u00DF\u00BF\u00A1\\\u0027]{1,32}$",
        "title": "Test"
    },
    {
        "description": "Used for matching fuzzy timespans given in days, hours minutes, seconds and any combination thereof.",
        "matches": [
            "6 days 18 hrs 2 mins",
            "4 days 19 hrs 5 mins",
            "4 days 19 hrs 12 mins",
            "2 h 20 mins",
            "1 hr 20 mins",
            "1 hour",
            "12 m",
            "12 minutes 15 seconds",
            "12 mins 15 secs",
            "1 min",
            "1 mins 10 seconds",
            "1 min 35 secs",
            "1 m",
            "1 m 10 s",
            "1 m 35 secs",
            "24 seconds",
            "25 secs",
            "1 sec",
            "1 s",
            "1 secs"
        ],
        "nonMatches": [
            "7 apples 2 pears",
            "1 banana 2 banana",
            "3 banana 4",
            "5 banana 6 banana 7 banana more"
        ],
        "pattern": "(\\d+(?:\\s+d(?:ay)?s?))?\\s?(\\d+(?:\\s+h(?:ou)?r?s?))?\\s?(\\d+(?:\\s+m(?:in)?(?:ute)?s?))?\\s?(\\d+(?:\\s+s(?:ec)?(?:ond)?)?s?)?$",
        "title": "Test"
    },
    {
        "description": "Matches a currency value with or without the 3 letter currency code or the Dollar, Euro or Yen signs. The code or currency sign can be in front or in the end of the value. Also supports additional whitespace character between the number and the sign, either in front or in the end. Unicode (UTF-8) compatible and can be used in Java or .NET too.",
        "matches": [
            "\u20AC 55.78",
            "5,854.78USD",
            "854.78 \u00A5"
        ],
        "nonMatches": [
            "854.78 EURO",
            "DOLLAR 55"
        ],
        "pattern": "[\\u0024\\u20AC\\u00A5A-Z\\s]{0,4}[0-9.,]+[\\s\\u0024\\u20AC\\u00A5A-Z]{0,4}",
        "title": "Test"
    },
    {
        "description": "This Regex chceck an input string for persian unicode alphabet characters. For Example In C#.NET: Regex.IsMatch(Text, \u0022^[\\u0600-\\u06ff\\s]+$|[\\u0750-\\u077f\\s]+$|[\\ufb50-\\ufc3f\\s]+$|[\\ufe70-\\ufefc\\s]+$|[\\u06cc\\s]+$|[\\u067e\\s]+$|[\\u06af\\s]$|[\\u0691\\s]+$|^$\u0022);",
        "matches": [
            "\u0639\u0644\u06CC",
            "\u0639\u0644\u064A",
            "\u06AF\u0686",
            "\u067E\u0698\u0646\u06AF",
            "\u06AF\u0686 \u067E\u0698\u06CC"
        ],
        "nonMatches": [
            "123",
            "\u0645\u0647\u0631\u0627\u0646 1",
            "a\u0639\u0644\u06CC"
        ],
        "pattern": "^[\\u0600-\\u06ff\\s]+$|[\\u0750-\\u077f\\s]+$|[\\ufb50-\\ufc3f\\s]+$|[\\ufe70-\\ufefc\\s]+$|[\\u06cc\\s]+$|[\\u067e\\s]+$|[\\u06af\\s]$|[\\u0691\\s]+$|^$",
        "title": "Test"
    },
    {
        "description": "N\u00FAmero de telefones Brasileiros inclusive celular de S\u00E3o Paulo",
        "matches": [
            "(11) 9876-5432",
            "(11)9876-5432",
            "(11) 9876-54321",
            "11-9876-54321",
            "11 9876-5432",
            "11 987654321",
            "98765432",
            "9876-5432"
        ],
        "nonMatches": [
            "(11)",
            "(11-9876-5432",
            "(11) 9876",
            "1198765432"
        ],
        "pattern": "^(\\(\\d{2}\\)?\\s?|\\d{2}(\\-|\\s))?\\d{2,4}(\\-|\\s)?\\d{4,5}$",
        "title": "Test"
    },
    {
        "description": "Password expresion that requires one lower case letter, one upper case letter, one digit, one non-word character, 8\u003E= length and no spaces.",
        "matches": [
            "aA@1aaaa",
            "aA@1aaaaasfljs;lkfe"
        ],
        "nonMatches": [
            "aA@1a aaa",
            "aA1aaaaaaaa",
            "12345678"
        ],
        "pattern": "^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*\\W)(?!.*\\s).{8,}$",
        "title": "Test"
    },
    {
        "description": "This is any mobile in Iran validation MCI , Irancell , Rightel , Talia",
        "matches": [
            "9121234567",
            "+989121234567",
            "989211234567",
            "989121234567",
            "0098935134567",
            "09361234567"
        ],
        "nonMatches": [
            "+9361234567",
            "08121234567"
        ],
        "pattern": "^((\\+989)|(989)|(00989)|(09|9))([1|2|3][0-9]\\d{7}$)",
        "title": "Test"
    },
    {
        "description": "matches connection string with these parameters only with space",
        "matches": [
            "Server=Cfff400;Database=Lffff010; User Id=agdd7; Password= Zomb6666;Integrated Security=true;"
        ],
        "nonMatches": [
            "nothing"
        ],
        "pattern": "(?:(?:Data Source)|(?:Server))=([\\s*\\w\\.]+?);\\s*?(?:(?:Initial Catalog)|(?:Database))=(\\s*\\w+?);\\s*?(?:(?:User Id)|(?:Uid))=(\\s*\\w+?);\\s*?(?:(?:password)|(?:Pwd))=(\\s*\\w+?);\\s*?(?:(?:Integrated Security)|(?:Integrated security))=(\\s*\\w*);$",
        "title": "Test"
    },
    {
        "description": "Permite validar si una cadena contieneel formato \u0022hh:mm\u0022(formato de 24 horas)",
        "matches": [
            "00:00",
            "23:59",
            "16:14"
        ],
        "nonMatches": [
            "23:60",
            "23,59",
            "24:00"
        ],
        "pattern": "^(((0[0-9])|(1[0-9])|(2[0-3])):[0-5][0-9])$",
        "title": "Test"
    },
    {
        "description": "It Required Input of National ID Card Number with or without dash(-), Please Rate!",
        "matches": [
            "45506-6532448-5",
            "4551658624457"
        ],
        "nonMatches": [
            "AAA45-65AAA7-2",
            "AAAAA765A66AA",
            "AAAAAAAAAAAAA"
        ],
        "pattern": "^\\d{5}[- .]?\\d{7}[- .]?\\d{1}$",
        "title": "Test"
    },
    {
        "description": "This validates GUID strings. It is not case sensitive and requires the beginning and ending curly brackets - \u0027{\u0027 and \u0027}\u0027 - to be present.",
        "matches": [
            "{CA373C30-293E-4DB8-A5E4-07AEA8D3F16E}",
            "{01234567-8998-7654-3210-012345678998}",
            "{ABCDEFFE-DCBA-ABCD-EFFE-DCBAABCDEFFE}"
        ],
        "nonMatches": [
            "{ABCDEFGH-IJKL-MNOP-QRST-UVWXYZ123456}",
            "{0123-456789AB-CDEF-FEDC-BA9876543210}\u0022",
            "{0123456789ABCDEFFEDCBA9876543210}"
        ],
        "pattern": "^\\{[A-Fa-f\\d]{8}-[A-Fa-f\\d]{4}-[A-Fa-f0\\d]{4}-[A-Fa-f\\d]{4}-[A-Fa-f\\d]{12}\\}$",
        "title": "Test"
    },
    {
        "description": "Validate Russian phone number (mobile, landline) that accept a space, a dash between the numbers.",
        "matches": [
            "88002345675",
            "+7 (960) 000 00 00",
            "+7(4855)23-34-56"
        ],
        "nonMatches": [
            "+7(4855)23.34.56",
            "7 4855 aaa 234 526",
            "8(232)_232_23_12"
        ],
        "pattern": "([+]?\\d[ ]?[(]?\\d{3}[)]?[ ]?\\d{2,3}[- ]?\\d{2}[- ]?\\d{2})",
        "title": "Test"
    },
    {
        "description": "Using regular expressions, you can just use the English alphabet.",
        "matches": [
            "jan",
            "sara",
            "America",
            "how are you",
            ""
        ],
        "nonMatches": [
            "123",
            "jan12",
            "sara036",
            "zip code 985"
        ],
        "pattern": "\u0022^([a-zA-Z])*$\u0022",
        "title": "Test"
    },
    {
        "description": "I crafted this crazy regex for matching chords in song sheets you find online. It matches a ton of different combinations, including some very weird/advanced chords like double suspended and chords with extra flats/sharps. The whole matching part is enclosed in parentheses so I can quickly find chords in a document and wrap them with square brackets.",
        "matches": [
            "A",
            "Ab7#9b5",
            "G#6/9",
            "C#sus2sus4",
            "C6+G",
            "Cm/G"
        ],
        "nonMatches": [
            "Dm/9",
            "Aadd9aug13m6",
            "min",
            "Abs"
        ],
        "pattern": "(?\u003C=(\\s|-|\\/|\\\\|\\())([A-G][b#]?[m]?((6\\/9|11|13|[679]))?((dim|dom|aug|sus|min|maj|add|no|m|M|-|\\+)(11|13|15|[23456789])?){0,2}([b#\\-\\+][59]){0,2}(\\/[A-G][b#]?)?)(?=(\\s|-|\\/|\\\\|\\)|$))",
        "title": "Test"
    },
    {
        "description": "Expression to validate currency formatted numbers without the currency symbol. This is an updated version of my previous expression and now works in ASP.NET regular expression validators.",
        "matches": [
            "153",
            "33.48",
            "786.1",
            "1567863483.33"
        ],
        "nonMatches": [
            "-123",
            "8524.258",
            "eo45"
        ],
        "pattern": "^(\\d?)*\\.?(\\d{1}|\\d{2})?$",
        "title": "Test"
    },
    {
        "description": "Matches mobile telephone numbers in Republic of Ireland. Allows for spaces at any point after the initial 08x part. Will only validate legitimate mobile prefixes, will not validate old pager numbers (082).",
        "matches": [
            "0831234567 089 123 1234"
        ],
        "nonMatches": [
            "0841234567 081 123 1234"
        ],
        "pattern": "^0(83|85|86|87|88|89)\\s?\\d{1}\\s?\\d{1}\\s?\\d{1}\\s?\\d{1}\\s?\\d{1}\\s?\\d{1}\\s?\\d{1}$",
        "title": "Test"
    },
    {
        "description": "Good for JavaScript. Parses an ISO8601 Date into separate Date() object parts, so you can set a Date object by passing in an ISO8601 string. NOTE: Will not match illegal dates such as the 32nd day of a month or the 61st minute of an hour, etc. Use like this: if (regexFull.test(dString)) { matches = dString.toString().match(regexFull); offset = 0; date.setUTCDate(1); date.setUTCFullYear(parseInt(matches[1],10)); date.setUTCMonth(parseInt(matches[2],10) - 1); date.setUTCDate(parseInt(matches[3],10)); date.setUTCHours(parseInt(matches[4],10)); date.setUTCMinutes(parseInt(matches[5],10)); if (matches[6]) { date.setUTCSeconds(parseInt(matches[6],10)); } if (matches[7]) { date.setUTCMilliseconds(parseInt(matches[7])); } if (matches[8] != \u0027Z\u0027) { offset = (matches[10] * 60) + parseInt(matches[11],10); offset *= ((matches[9] == \u0027-\u0027) ? -1 : 1); date.setTime(date.getTime() - offset * 60 * 1000); } }",
        "matches": [
            "2013-12-01T04:33Z, 2013-12-01T04:33:12.234Z, 2013-12-01T23:12-07:00"
        ],
        "nonMatches": [
            "2013, 2013-12, 2013-12-01, 2013-99-99T99:99Z"
        ],
        "pattern": "^(\\d{4})(?:-([0]\\d|[1][0-2]))(?:-([0-2]\\d|[3][01]))(?:T([01]\\d|2[0-3]))(?::([0-5]\\d))(?::([0-5]\\d)(?:\\.(\\d{1,7}?)|)|)(Z|([+-])([01]\\d|2[0-3])(?::([0-5]\\d)))$",
        "title": "Test"
    },
    {
        "description": "Matches bitcoin payment (public-key) address. Address must begin with a 1 or 3 and have 27-34 total alphanumeric characters. Will exclude Litecoin addresses. Does NOT do a checksum.",
        "matches": [
            "1EEVBLgg4h4TTLv76QiQ1Thcvvk3Be7VPV"
        ],
        "nonMatches": [
            "31uEbMgunupShBVTewXjtqbBv5MndwfXhbzz, L12332liteoinaddress"
        ],
        "pattern": "^[13][a-zA-Z0-9]{26,33}$",
        "title": "Test"
    },
    {
        "description": "Matches litecoin payment (public-key) address. Address must begin with a L and have 27-34 total alphanumeric characters. Will exclude bitcoin address since they begin with 1 or 3. Does NOT do a checksum.",
        "matches": [
            "Lg6GPVfPsmPAbTWYuKBQXtdGnBuCWcxHcr"
        ],
        "nonMatches": [
            "19RsSjVgob3JgU9cP9PPEiySftNpbU49Xm, qwerty, __**"
        ],
        "pattern": "^L[a-zA-Z0-9]{26,33}$",
        "title": "Test"
    },
    {
        "description": "This expression mathes dates formatted as YYYY-MM-DD from 0000-01-01 to 9999-12-31. It checks leap year including all modulo 400, modulo 100 and modulo 4 rules.",
        "matches": [
            "2013-01-14",
            "2000-02-29",
            "0000-12-12"
        ],
        "nonMatches": [
            "2012-02-29",
            "966-04-30",
            "2013-01-32"
        ],
        "pattern": "^(((\\d{4}-((0[13578]-|1[02]-)(0[1-9]|[12]\\d|3[01])|(0[13456789]-|1[012]-)(0[1-9]|[12]\\d|30)|02-(0[1-9]|1\\d|2[0-8])))|((([02468][048]|[13579][26])00|\\d{2}([13579][26]|0[48]|[2468][048])))-02-29)){0,10}$",
        "title": "Test"
    },
    {
        "description": "Singular Expression standalone or starting with new line, any whitespace or a colon",
        "matches": [
            "4916 3337 5336 2425"
        ],
        "nonMatches": [
            "8024007142161982"
        ],
        "pattern": "(^|([:]|\\n|\\s))(4[0-9]{3}[ -]*[0-9]{4}[ -]*[0-9]{4}[ -]*[0-9]{4}|5[12345][0-9]{2}[ -]*[0-9]{4}[ -]*[0-9]{4}[ -]*[0-9]{4}|3[47][0-9]{2}[ -]*[0-9]{6}[ -]*[0-9]{5}|3(?:0[012345]|[68][0-9])[0-9][ -]*[0-9]{6}[ -]*[0-9]{4}|6(?:011|5[0-9]{2})[ -]*[0-9]{4}[ -]*[0-9]{4}[ -]*[0-9]{4}|35[0-9]{2}[ -]*[0-9]{4}[ -]*[0-9]{4}[ -]*[0-9]{4}|(?:2131|1800)[ -]*[0-9]{6}[ -]*[0-9]{5})",
        "title": "Test"
    },
    {
        "description": "Find the price",
        "matches": [
            "$1 $2 $20 $100 $1.00 $100.00 $1,000.00"
        ],
        "nonMatches": [
            "1,2,3,100,1,000 needs the $"
        ],
        "pattern": "[$][0 -9]+",
        "title": "Test"
    },
    {
        "description": "This expression will accept only for characters both case(upper and lower)",
        "matches": [
            "lalu",
            "LALU",
            "LAlu"
        ],
        "nonMatches": [
            "lalu123",
            "LALU #$#$",
            "Lalu$%"
        ],
        "pattern": ".*[a-zA-Z]$",
        "title": "Test"
    },
    {
        "description": "this regular expression accepts date and optinal time with format (dd)[.-/](MM)[.-/](yyyy)[ ] (hh)[:](mm)[:](ss)",
        "matches": [
            "01-01-2014 10:50",
            "01/01/2014 10:50:59",
            "11-10-2012"
        ],
        "nonMatches": [
            "01-01-2014 10:60",
            "32-01-2014 10:50",
            "01-13-2014 10:50"
        ],
        "pattern": "^(([0][1-9]|[1|2][0-9]|[3][0|1])[./-]([0][1-9]|[1][0-2])[./-]([0-9]{4})|(([0][1-9]|[1|2][0-9]|[3][0|1])[./-]([0][1-9]|[1][0-2])[./-]([0-9]{4}))[ ]([0|1][0-2])[:](([0-5][0-9]))([:](([0-5][0-9])))?)$",
        "title": "Test"
    },
    {
        "description": "Parses heading record of HNB\u0027s Exchange rates formated list",
        "matches": [
            "037210220142202201413"
        ],
        "nonMatches": [
            "O37210220142202201413"
        ],
        "pattern": "(?\u003Clist_no\u003E\\d\\d\\d)(?\u003Cdate_created_dd\u003E\\d\\d)(?\u003Cdate_created_mm\u003E\\d\\d)(?\u003Cdate_created_yyyy\u003E\\d\\d\\d\\d)(?\u003Cdate_applicable_dd\u003E\\d\\d)(?\u003Cdate_applicable_mm\u003E\\d\\d)(?\u003Cdate_applicable_yyyy\u003E\\d\\d\\d\\d)(?\u003Crecords_count\u003E\\d+)",
        "title": "Test"
    },
    {
        "description": "Parses body on Croatian National Bank (HNB) Echange rates formated record",
        "matches": [
            "036AUD001 5,018783 5,033885 5,048987"
        ],
        "nonMatches": [
            "036 AUD 001 5.018783 5.033885 5.048987"
        ],
        "pattern": "(?\u003Ccurrency_no\u003E\\d\\d\\d)(?\u003Ccurrency_code\u003E\\w\\w\\w)(?\u003Cparity\u003E\\d\\d\\d)(?\u003Cask_price\u003E\\s+\\d+\\,\\d+)(?\u003Caverage_price\u003E\\s+\\d+\\,\\d+)(?\u003Cbid_price\u003E\\s+\\d+\\,\\d+)",
        "title": "Test"
    },
    {
        "description": "\u00D0\u00E2y l\u00E0 b?n R.E cho d?u s? di?n tho?i di d?ng c?a Vi?t Nam. Trong bi?u th?c quy d?nh s? di?n tho?i ph?i: - B?t d?u l\u00E0 s? 0 (VD:091,092,0122,0186,099...) - S? ? v? tr\u00ED th? 2 ph?i l\u00E0 s? 1 ho?c 9 (m\u00ECnh nh? k l?m ch? c\u00F3 2 lo?i n\u00E0y (VD: 091,092,0122,0186...) - C\u00E1c s? c\u00F2n l?i th\u00EC c\u00F3 th? ch?y t? 0 d?n 9 nhung gi?i h?n t? 8 d?n 9 s? d? c?ng th\u00EAm 2 s? check l\u00FAc d?u tr? th\u00E0nh s? dt d?ng 10 s? (0909.123.456) hay 11 s? (0123.123.4567) ============================= This is the RE for the mobile phone number of Vietnam. In the expression specified telephone number to: - Starting with the number 0 (Eg 091,092,0122,0186,099 ...) - 2nd number is number from 1 or 9 (if I don\u0027t have mistakes for remember this one) (Eg 091,092,0122,0186 ...) - The remaining numbers can flow from 0 to 9 but limited to 8 to 9 numbers for plus a check at the first two numbers become 10-digit number DT (0909.123.456) or No. 11 (0123.123.4567) Good Luck...and discuss",
        "matches": [
            "0909123456, 01231234567"
        ],
        "nonMatches": [
            "0009123456, 0909123456111, 03231234567, 01231234567134"
        ],
        "pattern": "^[0]{1}[19]{1}[0-9]{8,9}$",
        "title": "Test"
    },
    {
        "description": "all ip address should be accepted within this range 0-255",
        "matches": [
            "192.168.10.10"
        ],
        "nonMatches": [
            "256.256.256.256"
        ],
        "pattern": "regexp {[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+}",
        "title": "Test"
    },
    {
        "description": "Get the arguments data of a .NET composite format string using explicit capture",
        "matches": [
            "{0}",
            "{3,12:#}",
            "{{{6}}}"
        ],
        "nonMatches": [
            "{{5}}"
        ],
        "pattern": "(?\u003C!(?\u003C!\\{)\\{)\\{(?\u003Cindex\u003E\\d+)(,(?\u003Calignment\u003E\\d+))?(:(?\u003CformatString\u003E[^\\}]+))?\\}(?!\\}(?!\\}))",
        "title": "Test"
    },
    {
        "description": "Regular expression for any format Russian mobile phone numbers. Any non-existent format will not work",
        "matches": [
            "+7(912)2517699",
            "8(912)2517699",
            "7(912)2517699",
            "7-912-251-76-99",
            "8-(912)-251-76-99",
            "9122517699",
            "8-912-25-17-699",
            "7(912)-251-7699",
            "..."
        ],
        "nonMatches": [
            "x"
        ],
        "pattern": "/^(8-?|\\+?7-?)?(\\(?\\d{3}\\)?)-?(\\d-?){6}\\d$/",
        "title": "Test"
    },
    {
        "description": "Validate first letter of each word must capital.",
        "matches": [
            "Amit Chandrakantbhai Rami"
        ],
        "nonMatches": [
            "Amit chandrakantbhai Rami"
        ],
        "pattern": "^((\\b[A-Z0-9](\\w)*\\b)|\\s)*$",
        "title": "Test"
    },
    {
        "description": "The correspective VAT code for indian companies is the CIN Number. It is a composition of: - First char( U or L) - 5 numbers - 2 chars (province code) - 4 numbers (company registration year) - 3 chars (company type like LTD) - 6 numbers",
        "matches": [
            "U12345AA1234AAA123456, L12345AA1234AAA123456, u12345aa1234aaa123456"
        ],
        "nonMatches": [
            "X12345AA1234AAA123456"
        ],
        "pattern": "^([L|U]{1})([0-9]{5})([A-Za-z]{2})([0-9]{4})([A-Za-z]{3})([0-9]{6})$",
        "title": "Test"
    },
    {
        "description": "YYYY-MM-DD",
        "matches": [
            "1951-01-8, 2000-3-02, 2014-9-19"
        ],
        "nonMatches": [
            "1949-13-26, 0000-08-01, 2015-12-44"
        ],
        "pattern": "\\b(?:19[5-9][0-9]|200[0-9]|201[0-4])([-,.])(?:0?[1-9]|1[12])\\1(?:0?[1-9]|[12][0-9]|3[01])\\b",
        "title": "Test"
    },
    {
        "description": "validate amount or price check: Double value",
        "matches": [
            "10",
            "10.00",
            "0.50",
            "0.01"
        ],
        "nonMatches": [
            "01",
            "10.0",
            "0.5",
            "10.500"
        ],
        "pattern": "/^(?!0,?\\d)(?:\\d{1,3}(?:([, .])\\d{2})?(?:\\1\\d{2})*|(?:\\d+))((?!\\1)[,.]\\d{1,2})?$/u",
        "title": "Test"
    },
    {
        "description": "This regular expression is used to check the correct input of Mexican CURP, this regex has been modified over the years to correct some bugs. Esta expresi\u00F3n regular la uso para checar la captura de curp en un sistema donde es utilizada como llave universal y se ha actualizado para arreglar peque\u00F1os errores como X en el segundo caracter y que la fecha de nacimiento sea valida.",
        "matches": [
            "CUJM540331MZSNRX09",
            "SASD760229HDFNRV04",
            "PXTA920430HSLNRN02"
        ],
        "nonMatches": [
            "FRJU450324HBSKJD09",
            "POLO530229MJCJWSD04",
            "LOOR540932MOCKLD00"
        ],
        "pattern": "^[A-Z]{1}[AEIOUX]{1}[A-Z]{2}((\\d{2}((0[13578]|1[02])(0[1-9]|[12][0-9]|3[01])|(0[13-9]|1[0-2])(0[1-9]|[12][0-9]|30)|02(0[1-9]|1[0-9]|2[0-8])))|([02468][048]|[13579][26])0229)[HM]{1}(AS|BC|BS|CC|CS|CH|CL|CM|DF|DG|GT|GR|HG|JC|MC|MN|MS|NT|NL|OC|PL|QT|QR|SP|SL|SR|TC|TS|TL|VZ|YN|ZS|NE)[B-DF-HJ-NP-TV-Z]{3}[0-9A-Z]{1}[0-9]$",
        "title": "Test"
    },
    {
        "description": "Kyrgyzstan Phone numbers: (+996)XXX-XXX-XXX.",
        "matches": [
            "+996702068026",
            "(+996)702068026",
            "+(996)702-068-026"
        ],
        "nonMatches": [
            "+991702068026",
            "(996)702068026",
            "+(99)702-068-026"
        ],
        "pattern": "^\\(?\\+([9]{2}?[6])\\)?[-. ]?([0-9]{3})[-. ]?([0-9]{3})[-. ]?([0-9]{3})$",
        "title": "Test"
    },
    {
        "description": "Matches file paths to any valid format. Matches both \u0022\\\u0022 and \u0022/\u0022 as valid separators in file path. Extension (\u0022[a-zA-Z0-9]+\u0022) can be changed to any specific extension like (txt|jpg|png) and so on.Does NOT match relative file paths. Feel free to write any comments about bugs or anything, since this is my first contribution to regexlib",
        "matches": [
            "/asdjd/jhsdh.ajsd",
            "E:\\drive.txt",
            "\\\\usr\\home\\docs.jpg",
            "\\users\\assassin\\home/yp.r15"
        ],
        "nonMatches": [
            "//home/boo/",
            "foo/bar.bmp"
        ],
        "pattern": "^(([a-zA-Z]:)|((\\\\|/){1,2}\\w+)\\$?)((\\\\|/)(\\w[\\w ]*.*))+\\.([a-zA-Z0-9]+)$",
        "title": "Test"
    },
    {
        "description": "Microsoft telephone number format: +AAAA (BBBB) CCCCCCCCC",
        "matches": [
            "+44 (123) 456789 , (123) 456789 , 456789"
        ],
        "nonMatches": [
            "+44 456789 , +44 123) 456789 , 44 (123) 456789 , +44 (123)"
        ],
        "pattern": "^((\\+[1-9]{1}[0-9]{0,3})?\\s?(\\([1-9]{1}[0-9]{0,3}\\)))?\\s?(\\b\\d{1,9}\\b)$",
        "title": "Test"
    },
    {
        "description": "A Danish phone number can be written in three ways (if you don\u0027t include the country code +45). Either one block of 8 digits or two blocks of four digits or four blocks of two digits.",
        "matches": [
            "12345678",
            "1234 5678",
            "12 34 56 78"
        ],
        "nonMatches": [
            "123 456 78",
            "12 3456 78",
            "1 23 45 67 8",
            "55 ab 66 xy"
        ],
        "pattern": "((^\\d{8})|(^\\d{2}[ ]\\d{2}[ ]\\d{2}[ ]\\d{2})|(^\\d{4}[ ]\\d{4}))$",
        "title": "Test"
    },
    {
        "description": "No leading zeroes. Must have 2 digits after the decimal comma \u0027,\u0027",
        "matches": [
            "0,00",
            "12,34",
            "2014,08"
        ],
        "nonMatches": [
            "00,00",
            "12",
            "12,3",
            "12,345",
            "08,20"
        ],
        "pattern": "^(?!0\\d)([0-9]{1,}(,[0-9]{2}))$",
        "title": "Test"
    },
    {
        "description": "Extract a variable name and range from text containing expressions like: \u0022car travelling 30 \u003C mph \u003C 80\u0022 or \u0022acid solution pH \u003C 3\u0022 or \u0022net income 40000\u003Csalary\u003C=60000\u0022 or \u0022executive salary \u003E 120000\u0022. Recognises comparisons before and or after the variable name. Tolerates white space between elements. Recognises =, \u003C, \u003C=, =\u003C, \u003E, \u003E=, =\u003C comparison symbols. LIMITATIONS: * Intended to extract information for a limited number of variable names from text that has not been diligently formatted. * Numeric value portions of the pattern could be refined. * Add/change variable names (mph, ph etc) to match your requirements. * When editing varname list put longer names first to avoid confusion between ph and mph (for example mph will be returned as ph if ph is listed first in the pattern).",
        "matches": [
            "30\u003Cmph\u003C60",
            "3\u003CPH",
            "pH \u003C 3",
            "40000\u003Csalary\u003C=60000"
        ],
        "nonMatches": [
            "30\u003Cspeed\u003C60",
            "ph 3 to 5",
            "salary over 120000",
            "income\u003E60000"
        ],
        "pattern": "(((?\u003Cnumb1\u003E[\\d\\.-]+)([\\s]*?)(?\u003Coper1\u003E(\\\u003E=|\\\u003C=|=\\\u003E|=\\\u003C|\\\u003C|\\\u003E|=){1})([\\s]*?)){0,1})(?\u003Cvarname\u003E(salary|mph|kph|ph){1})((([\\s]*?)(?\u003Coper2\u003E(\\\u003E=|\\\u003C=|=\\\u003E|=\\\u003C|\\\u003C|\\\u003E|=){1})([\\s]*?)(?\u003Cnumb2\u003E[\\d\\.-]+)){0,1})",
        "title": "Test"
    },
    {
        "description": "Can be used for Turkey phone styles.",
        "matches": [
            "0(216) 472 15 30",
            "+90(216) 6721530",
            "03126751530"
        ],
        "nonMatches": [
            "(0312)8721530",
            "0312 872 15.30"
        ],
        "pattern": "(([\\+]90?)|([0]?))([ ]?)((\\([0-9]{3}\\))|([0-9]{3}))([ ]?)([0-9]{3})(\\s*[\\-]?)([0-9]{2})(\\s*[\\-]?)([0-9]{2})",
        "title": "Test"
    },
    {
        "description": "Divides a single line address into detail, street number, street name , street type, town, postcode, state, country. designed for Australian addresses but can be modified. switches: ignore expression whitespace, case insensitive. teseted using silverlight tester from regexlib. based on regex by Zijian http://regexlib.com/REDetails.aspx?regexp_id=1964",
        "matches": [
            "Shop S1, Sussex Centre, 401 Sussex St, Sydney; 28 Lidco Street, Arndell Park, Sydney 2148; Level 1, 198 Elizabeth St, Surry Hills 2010; Room 2, Level 1, 198 Elizabeth St, Surry Hills, NSW 2010; 541 Pittwater Rd, Brookvale 2100; 2 Maniangi Court, Macedon, 3440; PO Box 1531, Keveland, QLD 4163; St Lucia Golf Links, 22 St George St, St Lucia, QLD; PO Box 1531, St Lucia, QLD 4163;"
        ],
        "nonMatches": [
            "M/S 1014 Bell 4408; Kingswood Hostel Ramsay Street Toowoomba 4350; 15osborne Court Logan Holme 4129; Miamba Condamine 4416; Crows Nest Nursing Home Crows Nest 4352; 30 Skyline Drive M/S 617 Toowoomba Mail 4352; M/S 1945 Peranga 4352; 22a Wirra Wirra Toowoomba 4350; C/- Blue Care, Stenner Street Toowoomba 4350; Carline\u0027 M/S 848 Warwick 4370; 336 Oakey-Biddeston Rd, Ms 212 Oakey 4401; Kingswood Hostel Ramsay Toowoomba 4350; Shalom N/H - Rosalie \u0026 Lockyer Toowoomba 4350; Unit 2 Glenfield Grange,110 Spring Stree Toowoomba 4350; Villa 65 Westhaven Retirement Village Toowoomba 4350; Y"
        ],
        "pattern": "^ (?\u003CFullStreet\u003E (?\u003CDetail\u003E(?:C/[-O]?[a-z\\ ]*?)?\\ *)? (?\u003CPOBox\u003EP[\\.\\ ]?O[\\.\\ ]?\\ ?Box\\ *\\d+) | (?:(?\u003CDetail\u003E(?:C/[-O]?)?[\\w\\ ,\\.\u0027]+?),?/?\\ *?)? \\ *?\\b(?\u003CStreetNum\u003E(?:\\d+-)?\\d+[a-z]?)[\\ ] (?\u003CStreetFullName\u003E (?\u003CStreetName\u003E(?:[\\w\\ \u0027-]|st)+) (?:\\b(?\u003CStreetType\u003EALLEY|ALLY|APPROACH|APP|ARCADE|ARC|AVENUE|AVE|BOULEVARD|BLVD|BROW|BYPASS|BYPA|CAUSEWAY|CWAY|CIRCUIT|CCT|CIRCUS|CIRC|CLOSE|CL|COPSE|CPSE|CORNER|CNR|COVE|COURT|CRT|CT|CRESCENT|CRES|DRIVE|DR|END|ESPLANANDE|ESP|FLAT|FREEWAY|FWAY|FRONTAGE|FRNT|GARDENS|GDNS|GLADE|GLD|GLEN|GREEN|GRN|GROVE|GR|HEIGHTS|HTS|HIGHWAY|HWY|LANE|LINK|LOOP|MALL|MEWS|PACKET|PCKT|PARADE|PDE|PARK|PARKWAY|PKWY|PLACE|PL|PROMENADE|PROM|RESERVE|RES|RIDGE|RDGE|RISE|ROAD|RD|ROW|SQUARE|SQ|STREET|ST|STRIP|STRP|TARN|TERRACE|TCE|THOROUGHFARE|TFRE|TRACK|TRAC|TRUNKWAY|TWAY|VIEW|VISTA|VSTA|WALK|WAY|WALKWAY|WWAY|YARD )\\b) ) ) (?:,?\\ *?(?\u003CTown\u003E[a-z\u0027.]+(?:,?\\ +[a-z\u0027.]+)*?))? (?:,?\\ *?(?\u003CState\u003EVictoria|VIC|New South Wales|NSW|South Australia|SA|Northern Territory|NT|West Australia|WA|Tasmania|TAS|Australian Capital Territory|ACT|Queensland|QLD))? (?:,?\\ *?(?\u003CPostalCode\u003E\\d{3,4}))? (?:,?\\ *?(?\u003CCountry\u003EAu(?:stralia)?))? (?:(?=[^$])\\s)* $",
        "title": "Test"
    },
    {
        "description": "This regular expression validates all country phone number formats with country code, plus(+) sign, allowed brackets(\u0027(\u0027, \u0027)\u0027), dots(.), dashes(-). Plus (+) and country code is optional. Above expression allows alphabetical characters. To prevent alphabetical characters first check with this expression /^[^a-z]+$/i then check the main expression.",
        "matches": [
            "+91 999 888 7777, 999 888 7777, 9998887777, +91 (999) 888 7777, (999) 888-7777",
            "999-888-7777"
        ],
        "nonMatches": [
            "Doesn\u0027t allow alphabetic characters",
            "0010011212",
            "1991991212",
            "123) not-good"
        ],
        "pattern": "^\\+?\\d{2}|\\0(?:\\-?|\\ ?)(?:\\([2-9]\\d{2}\\)\\ ?|[2-9]\\d{2}(?:\\-?|\\ ?))[2-9]\\d{2}[- ]?\\d{4}$",
        "title": "Test"
    },
    {
        "description": "This regex will detect XML Injection in the input built around CDATA. So if the input is something like, \u003C![CDATA[ / ]]\u003E - this regex will detect and return true",
        "matches": [
            "\u003C![CDATA[ / ]]\u003E",
            "a\u003C![CDATA[ / ]]\u003E",
            "a \u003C![CDATA[ / ]]\u003E",
            "]]\u003E",
            "\u003C![CDATA[/]]\u003E",
            "1\u003C![CDATA[ / ]]\u003E",
            "abc\u003C![CDATA[ / ]]\u003E",
            "123\u003C![CDATA[ / ]]\u003E",
            "123 \u003C![CDATA[ / ]]\u003E",
            "\u003C![CDATA[\u003Cscript\u003Ealert(\u0027hi\u0027);\u003C/script\u003E]]\u003E",
            "\u003C![CDATA[a]]\u003E",
            "A\u003C![CDATA[ / ]]\u003E",
            "A \u003C![CDATA[ / ]]\u003E",
            "ABC\u003C![CDATA[ / ]]\u003E",
            "ABC \u003C![CDATA[ / ]]\u003E",
            "ABC123\u003C![CDATA[ / ]]\u003E",
            "ABC123 \u003C![CDATA[ / ]]\u003E",
            "ABC123 \u003C![CDATA[123]]\u003E",
            "\u003C![CDATA[ / ]]\u003E13",
            "FABC-FIXED-25\u003C![CDATA[ / ]]\u003E",
            "\u003C![CDATA[ / ]]\u003EABC-FIXED-25",
            "\u0027;dfsdfd",
            "] CDATA !",
            "\u003C ! [ CDATA [ / ] ] \u003E",
            "TEST CENTER 30/7 ]]\u003E",
            "]]\u003Easd=ads",
            "]]\u003ECITY TEST MAX 30=7 TEST"
        ],
        "nonMatches": [
            "asd",
            "123",
            "1000000.1",
            "asd asd",
            "ASD ASD ASD ASD ASD",
            "123 123 123 ASD 123",
            "123.33",
            "asd=ads"
        ],
        "pattern": "([a-zA-Z0-9\\\\-\\\\$\\\\s\\\\.#@%^*(){}|:;,?+=/]*[\u003C\u003E\u0027\\\u0022!\u0026\\\\[\\\\]]+((\\\\s|)CDATA(\\\\s|))*[a-zA-Z0-9\u003C\u003E\u0027\\\u0022!\u0026\\\\[\\\\]\\\\-\\\\$\\\\s\\\\.#@%^*(){}|:;,?+=/]*)+",
        "title": "Test"
    },
    {
        "description": "Regular expression for Google\u0027s format of Latitude and Longitude (if you were to copy and paste from either the Maps application or the web address). Allows 7 decimal places, and an optional space after the comma. A really small extension to Juergen Jungwirth\u0027s expression, to allow an optional space between the commas, and an additional decimal place, which is the format that Google often gives.",
        "matches": [
            "\u00220,0\u201C, \u201E48.05, 11.9666679, \u201E90,0\u201C, \u201E-90,-180\u201C"
        ],
        "nonMatches": [
            "\u201E05.12345,0\u201C, \u201E90.1234,1\u201C, \u201E1,-180.1\u201C, \u201E0,1.1234567\u201C"
        ],
        "pattern": "^(?\u003Clat\u003E(-?(90|(\\d|[1-8]\\d)(\\.\\d{1,6}){0,1})))\\,{1}\\s?(?\u003Clong\u003E(-?(180|(\\d|\\d\\d|1[0-7]\\d)(\\.\\d{1,6}){0,1})))$",
        "title": "Test"
    },
    {
        "description": "This expression allows Brazilian phone numbers as they have 4 or 5 prefix digits and with/without regional code. Not perfect but simplifies. Also allows space or dot or hyphen as optional separator in the number as parenthesis in regional code.",
        "matches": [
            "(13)98145-5566",
            "(11)8854-3236",
            "(11) 8854-3236",
            "(11).8854.3236",
            "(11)-8854-3236",
            "1177854425",
            "11.5642-3115"
        ],
        "nonMatches": [
            "(13654854",
            "01 9854-4253",
            "11.456758-525"
        ],
        "pattern": "^((\\(([1-9]{2})\\))(\\s)?(\\.)?(\\-)?([0-9]{0,1})?([0-9]{4})(\\s)?(\\.)?(\\-)?([0-9]{4})|(([1-9]{2}))(\\s)?(\\.)?(\\-)?([0-9]{0,1})?([0-9]{4})(\\s)?(\\.)?(\\-)?([0-9]{4}))$",
        "title": "Test"
    },
    {
        "description": "This regex supports international praefix, the national (0) and extension numbers.",
        "matches": [
            "+49 (0)40/529 567-31; 529 567-31"
        ],
        "nonMatches": [
            "529"
        ],
        "pattern": "[0-9.\\-/+() ]{4,}",
        "title": "Test"
    },
    {
        "description": "German postal code with or without national praefix.",
        "matches": [
            "D-25335; 25335"
        ],
        "nonMatches": [
            "5335"
        ],
        "pattern": "[D]?[-D]?[0-9]{5}",
        "title": "Test"
    },
    {
        "description": "Matches isbn10 or isbn13",
        "matches": [
            "1234123412",
            "123412341X",
            "ISBN 0 93028 923 4",
            "ISBN 1-56389-668-0",
            "ISBN 1-56389-016-X",
            "123456789X",
            "ISBN 9-87654321-2",
            "ISBN 123 456-789X",
            "ISBN 90-70002-34-5",
            "ISBN 90-70002-34-x",
            "ISBN 90-70002-34-5x",
            "ISBN 90-700-02-34-5",
            "0672317249",
            "9780672317248",
            "0-672-31724-9",
            "5555555555555",
            "ISBN 0-596-00681-0",
            "ISBN-13: 978-1-4028-9462-6",
            "ISBN: 1284233-2-1-1",
            "ISBN-13: 978-1-4028-9462-6",
            "ISBN-10: 1-4028-9462-7",
            "ISBN-13 978-3-642-11746-6 SomeText",
            "ISBN 978-3-642-11746-6",
            "ISBN-10 3-642-11746-5 SomeText",
            "ISBN 3-642-11746-5",
            "ISBN: 978-3-642-11746-6",
            "ISBN : 978-3-642-11746-6",
            "ISBN-10 : 3-642-"
        ],
        "nonMatches": [
            "Haven\u0027t tested this part"
        ],
        "pattern": "(ISBN[-]*(1[03])*[ ]*(: ){0,1})*(([0-9Xx][- ]*){13}|([0-9Xx][- ]*){10})",
        "title": "Test"
    },
    {
        "description": "Matches all C # Guid ToString representationens except the hexadecimal notation.",
        "matches": [
            "ACFE7A48-717D-4345-90C6-E6BC568B2F32",
            "{ACFE7A48-717D-4345-90C6-E6BC568B2F32}",
            "(ACFE7A48-717D-4345-90C6-E6BC568B2F32)",
            "ACFE7A48717D434590C6E6BC568B2F32"
        ],
        "nonMatches": [
            "(ACFE7A48-717D-4345-90C6-E6BC568B2F32}",
            "{ACFE7A48-717D-4345-90C6-E6BC568B2F32)",
            "{ACFE7A48-717D-434590C6-E6BC568B2F32}",
            "{ACFE7A48717D434590C6E6BC568B2F32}",
            "(ACFE7A48717D434590C6E6BC568B2F32)"
        ],
        "pattern": "(?i)^(?\u003Cbrace\u003E(?\u003Ccurly\u003E\\{)|(?\u003Cround\u003E\\())?[\\dA-F]{8}(?(brace)(?\u003Csep\u003E-)|(?\u003Csep\u003E-)?)(?:[\\dA-Z]{4}(?(sep)-)){3}[\\dA-F]{12}(?(curly)\\})(?(round)\\))$",
        "title": "Test"
    },
    {
        "description": "Match TCP/UDP port number between 1 and 65535",
        "matches": [
            "1",
            "23",
            "1024",
            "65535"
        ],
        "nonMatches": [
            "0",
            "65536"
        ],
        "pattern": "^([1-9]\\d{0,3}|[1-5]\\d{4}|6[0-4]\\d{3}|65[0-4]\\d{2}|655[0-2]\\d|6553[0-5])$",
        "title": "Test"
    },
    {
        "description": "Year, month and day with dashes.Year starts from 1900 to 2015 and must be 4 digits.",
        "matches": [
            "2012-05-21",
            "1960-12-14",
            "1910-5-3"
        ],
        "nonMatches": [
            "2011/5/21",
            "60-12-14",
            "2021-5-3"
        ],
        "pattern": "^((19[0-9][0-9])|(20[0-1][0-5]))\\-((0?[1-9])|(1[0-2]))\\-((0?[1-9])|([1-2][0-9])|(3[0-1]))$",
        "title": "Test"
    },
    {
        "description": "Prevent to use any text that can be executed on the database, it limits many options on the text but is safer than let all on the framework",
        "matches": [
            "example\u0027 OR 1=1, drop all the walls and drop table"
        ],
        "nonMatches": [
            "this is an example regex"
        ],
        "pattern": "(=)|(\u003C)|(\u003E)|(\u0027)|(--)|(/)|(\\+)|(;)|(\\*)|(!)|({)|(})|(drop table)|(drop stored)|(alter table)|(alter stored)|(sp_)|(xp_)|(exec )|(execute )|(fetch)|(select)|(kill)|(selectsys)|(sysobjects)|(syscolumns)|(isnull)|(coalesce)|(dbo)|(tbl)|(usp)",
        "title": "Test"
    },
    {
        "description": "Verifies YouTube video links AND pulls the video ID from them in a matching group. Works with all capitalizations. It also matches the WHOLE link but sorts the video ID into a group. Works with JavaScript, PHP and Python. (Not tested with any other Regex engine) WARNING: youtu.be links have their ID group as the second group.",
        "matches": [
            "http://www.youtube.com/watch?v=something",
            "https://www.youtube.com/watch?v=something",
            "http://youtu.BE/something",
            "https://www.YOUTUBE.com/watch?en=gb\u0026vari=abc\u0026v=something\u0026another=yes"
        ],
        "nonMatches": [
            "http://www.anothersite.com/watch?v=something",
            "http://www.youtube.com/wat?v=something"
        ],
        "pattern": "(?:[hH][tT]{2}[pP][sS]{0,1}:\\/\\/)?[wW]{0,3}\\.{0,1}[yY][oO][uU][tT][uU](?:\\.[bB][eE]|[bB][eE]\\.[cC][oO][mM])?\\/(?:(?:[wW][aA][tT][cC][hH])?(?:\\/)?\\?(?:.*)?[vV]=([a-zA-Z0-9--]+).*|([A-Za-z0-9--]+))",
        "title": "Test"
    },
    {
        "description": "Simple, but effective; including .com.mt, .co.uk etc. To include more characters for the email name: ^[A-Z0-9._(ADD HERE)-]+@[A-Z0-9.-]+\\.[A-Z0-9.-]+$ remove brackets obviously.",
        "matches": [
            "testemail@testdomain.co.uk"
        ],
        "nonMatches": [
            "test%email@testdomain.co.uk, test*#@gmail.com test@test"
        ],
        "pattern": "/^[A-Z0-9._-]+@[A-Z0-9.-]+\\.[A-Z0-9.-]+$/i",
        "title": "Test"
    },
    {
        "description": "This regex make you extract all numbers format i develope it now and i want to share with you guys i know you will see it and thanks me later",
        "matches": [
            "800-555-5555",
            "+212642477919",
            "(800)-555-5555"
        ],
        "nonMatches": [
            "0000"
        ],
        "pattern": "(\\+)?(\\()?(\\d+){1,4}(\\))?(\\s)?(-)?(\\d+){1,3}(\\s)?(-)?(\\d+){1,4}(\\s)?(-)?(\\d+){1,4}(\\s)?(-)?(\\d+){1,4}",
        "title": "Test"
    },
    {
        "description": "This regular expression will match any valid twitter user name.",
        "matches": [
            "username, @user_name"
        ],
        "nonMatches": [
            "u$ername, user name, @daniel*junyszek, abcdefabcdefabcdefa"
        ],
        "pattern": "\\A([0-9a-zA-Z_]{1,15})|(@([0-9a-zA-Z_]{1,15}))\\Z",
        "title": "Test"
    },
    {
        "description": "Parse and validate Street Addresses. It works in PCRE and .net.",
        "matches": [
            "54a Lakeview Rd",
            "P.O. Box 12345 Los Angeles, CA 12304",
            "101, 5th St. N",
            "123 Anywhere Dr. apt #99 Somewhere, AR 55789",
            "6806 5th Ave NW Apt. 12B, Bradenton, FL 34209"
        ],
        "nonMatches": [
            "123 Street City, ST 00000",
            "2015 Best Street Name Parser",
            "123 Street City, ST 00000"
        ],
        "pattern": "/(?:(?\u003C=^)|(?\u003C=[;:.,|][ ])|(?\u003C=[[(\u0027\u0022]))(?:[)]?P\\.?O\\.?(?:(?i)[ ]?Box)?[ ]{0,2}(?\u003CPO\u003E\\d{1,5})[)]?|(?\u003CHouseNumber\u003E(?\u003E(?:(?\u003CNumberException\u003E(?:19[789]|20[0123])\\d)|\\d+?(?:[-\\\\\\/]\\d{1,3})?)(?=(?:[;,]|[-\\\\\\/]?[A-Za-z]\\d?)?\\s)))(?:(?\u003CDoorSide\u003E[-\\\\\\/]?[A-Za-z]\\d{0,2}))?,?\\s{0,2}(?\u003E(?:(?:^|[ ]{1,2})(?\u003CStreetPrefix\u003EAU|EI?|GR|H[AW]|JO|K|M[AEM]|N[EOW]?|O[HLMV]|RD|S[EW]?|TE|W)\\b)?)(?:(?:^|[ ]{1,2})(?\u003CStreetName\u003E(?:\\p{Lu}[-\u0027\\p{L}]*?(?:\\.?[ ]{1,2}\\p{Lu}[-\u0027\\p{L}]*?){0,8}?(?\u003E(?\u003CStreetNameIndicator\u003E(?i)BOULEVARD|PLAZA|ROAD|STR(?:ASSE|EET)|WA(?:LK|Y))?)|(?\u003CStreetOrdinal\u003E\\d{1,3}(?:[. ]?(?:\u00B0|st|[nr]d|th))))\\b))(?:(?:(?\u003E[ ]{1,2}(?i)(?\u003CStreetType\u003EA(?:C(?:CESS|RES)|LLEY|NX|PPROACH|R(?:CADE|TERY)|VE(?:NUE)?)|B(?:A(?:NK|SIN|Y)|CH|E(?:ACH|ND)|L(?:DG|VD)?|O(?:ULEVARD|ARDWALK|WL)|R(?:ACE|AE|EAK|IDGE|O(?:ADWAY|OK|W))?|YPASS)|C(?:A(?:NAL|USEWAY)|ENTRE(?:WAY)?|H(?:A(?:NN?EL|SE)?)?|I(?:R(?:C(?:LET?|U(?:IT|S)))?)?|L(?:B|OSE)?|O(?:MMON|NCOURSE|OP|PSE|R(?:[DK]|NER|S[OT])|UR(?:[VS]E|T(?:YARD)?)|VE)?|R(?:ES(?:CENT|T)?|IEF|OSS(?:ING)?)|T[RS]?|U(?:LDESAC|RVE)|V)|D(?:ALE|EVIATION|I[PV]|M|OWNS|R(?:IVE(?:WAY)?)?)|E(?:ASEMENT|DGE|LBOW|N(?:D|TRANCE)|S(?:PLANADE|T(?:ATE|S))|X(?:P(?:(?:(?:RESS)?WA)?Y)|T(?:ENSION)?))|F(?:AIRWAY|I(?:ELDS?|RETRAIL)|L(?:DS?|S)|O(?:LLOW|R(?:D|MATION))|R(?:D|EEWAY|ONT(?:AGE|ROAD)?))|G(?:A(?:P|RDENS?|TE(?:S|WAY)?)|L(?:ADE|EN)|R(?:ANGE|EEN|O(?:UND|V(?:ET?)?))?)|H(?:AVEN|BR|E(?:ATH|IGHTS)|I(?:GHWAY|LL)|L|OUSE|TS|UB|WY)|I(?:NTER(?:CHANGE)?|SLAND)|J(?:C|UNCTION)|K(?:EY|NOLL)|L(?:A(?:NE(?:WAY)?)?|DG|IN(?:E|K)|N|O(?:O(?:KOUT|P)|WER)?)|M(?:A(?:LL)?|DWS?|E(?:A(?:D|NDER)|WS)|L|NR|OT(?:EL|ORWAY))|NO(?:OK)?|O(?:L|UTLOOK|V(?:ERPASS)?)|P(?:A(?:R(?:ADE|K(?:LANDS|WAY)?)|SS|TH(?:WAY)?)?|DE|I(?:ER|[KN]E)|KW?Y|L(?:A(?:CE|ZA)|Z)?|O(?:CKET|INT|RT)|RO(?:MENADE|PERTY)|T|URSUIT)?|QUA(?:D(?:RANT)?|YS?)|R(?:A?(?:MBLE|NCH)|DG?|E(?:ACH|S(?:ERVE|T)|T(?:REAT|URN))|I(?:D(?:E|GE)|NG|S(?:E|ING))|O(?:AD(?:WAY)?|TARY|U(?:ND|TE)|W)|R|UN)|S(?:CH|(?:ER(?:VICE)?WAY)|IDING|LOPE|MT|P(?:PGS|UR)|Q(?:UARE)?|T(?:A(?:TE)?|CT|EPS|HY|PL|RAND|R(?:EET|IP)|TER)?|UBWAY)|T(?:ARN|CE|E(?:R(?:RACE)?)?|HRO(?:UGHWAY|WAY)|O(?:LLWAY|P|R)|R(?:A(?:CK|IL)|FY|L)?|URN)|UN(?:DERPASS|IV)?|V(?:AL(?:E|LEY)|I(?:EW|S(?:TA)?)?|L(?:GS?|Y))|W(?:A(?:L[KL](?:WAY)?|Y)|HARF|YND)|XING)\\b\\.?){1,2})??(?\u003E(?:[ ]{1,2}(?\u003CStreetSuffix\u003EE|N[EW]?|S[EW]?|W)\\b)?))(?:(?:^|[ ]{1,2}|[;,.]\\s{0,2}?)(?i)(?\u003CApt\u003E(?:[#]?\\d{1,5}(?:[. ]{0,2}(?:\u00B0|st|[nr]d|th))?[;,. ]{0,2})?(?:(?:(?\u003E(?:A|DE)P(?:AR)?T(?:MENT)?S?|B(?:UI)?LD(?:IN)?G?|FL(?:(?:OO)?R)?|HA?NGS?R|LOT|PIER|RM|S(LIP|PC|T(E|OP))|TRLR|UNIT|(?=[#]))(?:[ ]{1,2}[#]?\\w{1,5})??|BA?SE?ME?N?T|FRO?NT|LO?BBY|LOWE?R|OF(?:C|FICE)|P\\.?H|REAR|SIDE|UPPR)){1,3}(?:[#;,. ]{1,3}(?:[-.]?[A-Z\\d]){1,3})?)[;,.]?)?)(?\u003CCityState\u003E[-;,.[(]?\\s{1,4}(?\u003CCity\u003E[A-Z][A-Za-z]{1,16}[.]?(?:[- ](?:[A-Z][A-Za-z]{0,16}|[a-z]{1,3})(?:(?:[- ][A-Za-z]{1,17}){1,7})?)?)(?\u003C!\\s[ACDF-IK-PR-W][AC-EHI-PR-Z])[)]?(?\u003E(?\u003CState\u003E[-;,.]?\\s{1,4}[[(]?(?\u003CStateAbbr\u003EA[LKSZRAP]|C[AOT]|D[EC]|F[LM]|G[AU]|HI|I[ADLN]|K[SY]|LA|M[ADEHINOPST]|N[CDEHJMVY]|O[HKR]|P[ARW]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY])\\b[])]?|[-;,.]\\s{0,3}[ ][[(]?(?=[A-Z])(?\u003CStateName\u003E(?i)Ala(?:bam+a|[sz]ka)|Ari[sz]ona|Arkan[sz]as|California|Colorado|Con+ec?t+icut+|Delaw[ae]re?|Flori?da|Georgia|Haw+ai+|Idaho|Ill?inois|Indiana|Iowa|Kansas|Kentu[ck]+[iy]|Louis+ian+a|Ma(?:ine|r[iy]land|s+achuset+s)|Mi(?:chigan|n+es+ot+a|s+is+ip+i|s+ouri)|Montana|Ne(?:bra[sz]ka|vada|w[ ]?(?:Hamp?shire|Jerse[iy]|Mexico|York))|[NS](?:o[ru]th|[.])[ ]?(?:Carolina|Dakota)|Ohio|Oklahoma|Oregon|Pen+s[iy]lvan+[iy]a|Rh?oa?de?[ ]?Island|Ten+es+e+|Texas|Ut+ah?|Vermont|Washington|(?:W(?:est|[.])?[ ]?)?Virginia|Wi[sz]cou?nsin|W[iy]om[iy]+ng?)[])]?)?)(?(State)|(?:(?\u003C=[)])|(?! [A-Z]))))?(?\u003E(?:[-;,.\\s]{0,4}(?:^|[ ]{1,2})[[(]?(?\u003CZipCode\u003E(?!0{5})\\d{5}(?:-\\d{4})?)[])]?)?)(?(State)|(?(ZipCode)|(?(City)(?!)|(?(PO)|(?(NumberException)(?!)|(?(StreetNameIndicator)|(?(StreetType)|(?(StreetPrefix)|(?!)))))))))(?=[]).?!\u0027\u0022\\s]|$)(?![ ]+\\d)/gmx",
        "title": "Test"
    },
    {
        "description": "Matches currency input with or without dots.",
        "matches": [
            "\u20AC3.023.123,34",
            "9.876.453",
            "12345678",
            "123456,78"
        ],
        "nonMatches": [
            "\u20AC3,023,123.34",
            "9,876,453",
            "123456",
            "123456,780",
            "abc"
        ],
        "pattern": "^\\\u20AC?(\\d{1,3}[.](\\d{3}[.])*\\d{3}|\\d+)([,]\\d{1,2})?$",
        "title": "Test"
    },
    {
        "description": "Email (your-name@example.com). From http://tools.twainscanning.com/getmyregex",
        "matches": [
            "hello.me_1@email.com",
            "Jean+Francois@anydomain.museum"
        ],
        "nonMatches": [
            "foo.bar#gmail.co.uk"
        ],
        "pattern": "[\\w!#$%&\u0026apos;*+./=?\u0060{|}~^-]+@[\\d.A-Za-z-]+",
        "title": "Test"
    },
    {
        "description": "you can type the name consist of 4 parts .",
        "matches": [
            "\u062D\u0633\u0627\u0645 \u062D\u0633\u0646 \u0639\u0644\u0649 \u062D\u0633\u0646"
        ],
        "nonMatches": [
            "\u062D\u0633\u0627\u0645 \u062D\u0633\u0646 \u0639\u0644\u0649"
        ],
        "pattern": "^(([\\u0600-\\u065F\\u066A-\\u06EF\\u06FA-\\u06FF]+)\\s){3}([\\u0600-\\u065F\\u066A-\\u06EF\\u06FA-\\u06FF]+)$",
        "title": "Test"
    },
    {
        "description": "Parses Standard Latitude, Longitude notation for identifying earth co-ordinates (as per google maps etc). Allows values in format dd.dddddd,ddd.dddddd (lat, lng) where lat can be in range -90 to 90 and lng in range -180 - 180",
        "matches": [
            "-89.999999,180",
            "0.01234,-12.32",
            "90,180",
            ""
        ],
        "nonMatches": [
            "-90.01,0.121",
            "15.00001,181",
            "90.1,-181"
        ],
        "pattern": "\\-?(90|[0-8]?[0-9]\\.[0-9]{0,6})\\,\\-?(180|(1[0-7][0-9]|[0-9]{0,2})\\.[0-9]{0,6})",
        "title": "Test"
    },
    {
        "description": "Unique reference for each company registered with Companies House in the UK",
        "matches": [
            "1234567BR123456",
            "7654321LP654321"
        ],
        "nonMatches": [
            "1234567BB123456",
            "765432LP6543211"
        ],
        "pattern": "(0[0-9]{7}|(AC|BR|FC|GE|GN|GS|IC|IP|LP|NA|NF|NI|NL|NO|NP|NR|NZ|OC|RC|SA|SC|SF|SI|SL|SO|SP|SR|SZ|ZC|R)[0-9]{6})",
        "title": "Test"
    },
    {
        "description": "Format AA-999-AA First 2 chars cannot be combination SS, while 000 is not allowed as the digits. Chars I,O,Q and V are not allowed.",
        "matches": [
            "AA-123-AA",
            "BW-001-EW",
            "AR-934-WWW"
        ],
        "nonMatches": [
            "AA-000-AA",
            "BQ-001-EW",
            "IS-045-AA"
        ],
        "pattern": "^(?=.*[1-9].*)((?!SS)[AHJ-NPR-UW-Z]{2})\\-[0-9]{3}\\-[AHJ-NPR-UW-Z]{2}$",
        "title": "Test"
    },
    {
        "description": "Matches any valid flight number",
        "matches": [
            "AB123",
            "1A123B",
            "B1B1234"
        ],
        "nonMatches": [
            "11A123",
            "123456B",
            "123B2"
        ],
        "pattern": "([A-Za-z]{2}|[A-Za-z]\\d|\\d[A-Za-z])[A-Za-z]{0,1}\\d(\\d{0,3})[A-Za-z]{0,1}",
        "title": "Test"
    },
    {
        "description": "Extract variables out of a sass file",
        "matches": [
            "$primary: #000000;",
            "$nav-color-highlight: darken($nav-color-main, 5%);",
            "$disable-secondary-accent: true; //don\u0027t forget!"
        ],
        "nonMatches": [
            "/*****Common Themes*****/",
            "//$secondary-accent: #fffa0a;",
            "Lorem ipsum"
        ],
        "pattern": "^\\$(?\u003Ckey\u003E.+):\\s*(?\u003Cvalue\u003E.+);",
        "title": "Test"
    },
    {
        "description": "Matches the Egyptian National ID Number with captured named groups, optional spaces between codes and leap year support. (C# Flavor)",
        "matches": [
            "29502200502853",
            "2 95 02 20 05 0285 3",
            "3 00 02 29 01 0492 6"
        ],
        "nonMatches": [
            "3 01 02 29 01 0492 6",
            "3 01 02 29 01 0492",
            "3010229010492-6"
        ],
        "pattern": "(?\u003CBirthMillennium\u003E[23])\\x20?(?:(?\u003CBirthYear\u003E[0-9]{2})\\x20?(?:(?:(?\u003CBirthMonth\u003E0[13578]|1[02])\\x20?(?\u003CBirthDay\u003E0[1-9]|[12][0-9]|3[01]))\\x20?|(?:(?\u003CBirthMonth\u003E0[469]|11)\\x20?(?\u003CBirthDay\u003E0[1-9]|[12][0-9]|30))\\x20?|(?:(?\u003CBirthMonth\u003E02)\\x20?(?\u003CBirthDay\u003E0[1-9]|1[0-9]|2[0-8]))\\x20?)|(?:(?\u003CBirthYear\u003E04|08|[2468][048]|[13579][26]|(?\u003C=3)00)\\x20?(?\u003CBirthMonth\u003E02)\\x20?(?\u003CBirthDay\u003E29)\\x20?))(?\u003CProvinceCode\u003E0[1-34]|[12][1-9]|3[1-5]|88)\\x20?(?\u003CRegistryDigit\u003E[0-9]{3}(?\u003CGenderDigit\u003E[0-9]))\\x20?(?\u003CCheckDigit\u003E[0-9])",
        "title": "Test"
    },
    {
        "description": "Matches the strict datetime format for Common Alerting Protocol v1.2 (might be same as earlier versions too). Inspiration and some code came from Michael Ash\u0027s http://regexlib.com/REDetails.aspx?regexp_id=610 with tweaks of my own",
        "matches": [
            "2016-04-07T12:29:00-04:00",
            "2016-04-07T11:13:00-05:00",
            "2016-04-05T00:53:35-04:00"
        ],
        "nonMatches": [
            "31/12/2003 11:59:59 PM",
            "2016-04-07 22:00:01+00:00",
            "2016-04-07T22:00:01Z"
        ],
        "pattern": "^(?:[2-9]\\d\\d\\d)-(?:1[012]|0?[1-9])?-(?:31(?!.(?:0?[2469]|11))|(?:30|29)(?!.0?2)|29(?=.0?2.(?:(?:(?:1[6-9]|[2-9]\\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00)))(?:T))|(?:2[0-8]|1\\d|0?[1-9]))T(2[01234]|[01]\\d):[0-5]\\d:[0-5]\\d[+-][01]\\d:[0-5]\\d$",
        "title": "Test"
    },
    {
        "description": "Case sensitive: -8-20 characters -at least 1 letter -at least 1 numeric or special -these special chars only ~ ! @ # $ % ^ \u0026 ? * +",
        "matches": [
            "P@SSw0rd~!@#$%^\u0026?*+"
        ],
        "nonMatches": [
            "Password"
        ],
        "pattern": "^(?=.*[a-zA-Z])(?=.*[0-9!@#$%^\u0026*\\?\\+])(?!.*[()_\\-\\\u0060\\\\/\\\u0022\\\u0027|\\[\\]}{:;\u0027/\u003E.\u003C,])(?!.*\\s)(?!.*\\s).{8,20}$",
        "title": "Test"
    },
    {
        "description": "Using this to validate street addresses, eg from yelp API https://regex101.com/r/sW5iI3/2",
        "matches": [
            "2255 140th Ave NE",
            "535 Bellevue Sq",
            "14008 NE 8th St",
            "15615 NE 8th St",
            "555 108th Ave NE",
            "12821 SE 38th St",
            "15920 NE 8th St",
            "4065 Factoria Blvd SE",
            "1829 130th Ave Ne",
            "3720 Factoria Blvd SE",
            "150 112th Ave NE",
            "16640 Redmond Way",
            "730 NW Gilman Blvd",
            "15220 SE 37th St",
            "1328 156th Ave NE",
            "5905 Airport Way S",
            "600 E Pine St"
        ],
        "nonMatches": [
            "",
            "Crossroads Mall",
            "Hungry Bear Market"
        ],
        "pattern": "^(?\u003Caddress1\u003E(?\u003E\\d{1,6}(?\u003E\\ 1\\/[234])?( (N(orth)?|S(outh)?)? ?(E(ast)?|W(est)?))?((?\u003E \\d+ ?(th|rd|st|nd))|(?\u003E [A-Z](?\u003E[a-z])+)+) (?\u003E(?i)THROUGHWAY|TRAFFICWAY|CROSSROADS|EXPRESSWAY|BOULEVARD|CROSSROAD|EXTENSION|JUNCTIONS|MOUNTAINS|STRAVENUE|UNDERPASS|CAUSEWAY|CRESCENT|CROSSING|JUNCTION|MOTORWAY|MOUNTAIN|OVERPASS|PARKWAYS|TURNPIKE|VILLIAGE|VILLAGES|CENTERS|CIRCLES|COMMONS|CORNERS|ESTATES|EXPRESS|FORESTS|FREEWAY|GARDENS|GATEWAY|HARBORS|HIGHWAY|HOLLOWS|ISLANDS|JUNCTON|LANDING|MEADOWS|MOUNTIN|ORCHARD|PARKWAY|PASSAGE|PRAIRIE|RANCHES|SPRINGS|SQUARES|STATION|STRAVEN|STRVNUE|STREETS|TERRACE|TRAILER|TUNNELS|VALLEYS|VIADUCT|VILLAGE|ALLEE|ARCADE|AVENUE|BLUFFS|BOTTOM|BRANCH|BRIDGE|BROOKS|BYPASS|CANYON|CAUSWA|CENTER|CENTRE|CIRCLE|CLIFFS|COMMON|CORNER|COURSE|COURTS|CRSENT|CRSSNG|DIVIDE|DRIVES|ESTATE|EXTNSN|FIELDS|FOREST|FORGES|FREEWY|GARDEN|GATEWY|GATWAY|GREENS|GROVES|HARBOR|HIGHWY|HOLLOW|ISLAND|ISLNDS|JCTION|JUNCTN|KNOLLS|LIGHTS|MANORS|MEADOW|MEDOWS|MNTAIN|ORCHRD|PARKWY|PLAINS|POINTS|RADIAL|RADIEL|RAPIDS|RIDGES|SHOALS|SHOARS|SHORES|SKYWAY|SPRING|SPRNGS|SQUARE|STRAVN|STREAM|STREME|STREET|SUMITT|SUMMIT|TRACES|TRACKS|TRAILS|TUNNEL|TURNPK|UNIONS|VALLEY|VIADCT|VILLAG|ALLEE|ALLEY|ANNEX|AVENU|AVNUE|BAYOO|BAYOU|BEACH|BLUFF|BOTTM|BOULV|BRNCH|BRDGE|BROOK|BURGS|BYPAS|CANYN|CENTR|CNTER|CIRCL|CRCLE|CLIFF|COURT|COVES|CREEK|CRSNT|CREST|CURVE|DRIVE|FALLS|FERRY|FIELD|FLATS|FORDS|FORGE|FORKS|FRWAY|GARDN|GRDEN|GRDNS|GTWAY|GLENS|GREEN|GROVE|HARBR|HRBOR|HAVEN|HIWAY|HILLS|HOLWS|ISLND|ISLES|JCTNS|KNOLL|LAKES|LNDNG|LIGHT|LOCKS|LODGE|LOOPS|MANOR|MILLS|MISSN|MOUNT|MNTNS|PARKS|PKWAY|PKWYS|PATHS|PIKES|PINES|PLAIN|PLAZA|POINT|PORTS|RANCH|RNCHS|RAPID|RIDGE|RIVER|ROADS|ROUTE|SHOAL|SHOAR|SHORE|SPRNG|SPNGS|SPURS|STATN|STRAV|STRVN|SUMIT|TRACE|TRACK|TRAIL|TRLRS|TUNEL|TUNLS|TUNNL|TRNPK|UNION|VALLY|VIEWS|VILLG|VILLE|VISTA|WALKS|WELLS|ALLY|ANEX|ANNX|AVEN|BEND|BLUF|BLVD|BOUL|BURG|BYPA|BYPS|CAMP|CNYN|CAPE|CSWY|CENT|CNTR|CIRC|CRCL|CLFS|CLUB|CORS|CRSE|COVE|CRES|XING|DALE|DRIV|ESTS|EXPR|EXPW|EXPY|EXTN|EXTS|FALL|FRRY|FLDS|FLAT|FLTS|FORD|FRST|FORG|FORK|FRKS|FORT|FRWY|GRDN|GDNS|GTWY|GLEN|GROV|HARB|HIWY|HWAY|HILL|HLLW|HOLW|INLT|ISLE|JCTN|JCTS|KEYS|KNOL|KNLS|LAKE|LAND|LNDG|LANE|LOAF|LOCK|LCKS|LDGE|LODG|LOOP|MALL|MNRS|MDWS|MEWS|MILL|MSSN|MNTN|MTIN|NECK|ORCH|OVAL|PARK|PKWY|PASS|PATH|PIKE|PINE|PNES|PLNS|PLZA|PORT|PRTS|RADL|RAMP|RNCH|RPDS|REST|RDGE|RDGS|RIVR|ROAD|SHLS|SHRS|SPNG|SPGS|SPUR|SQRE|SQRS|STRA|STRM|STRT|TERR|TRCE|TRAK|TRKS|TRLS|TRLR|TUNL|VLLY|VLYS|VDCT|VIEW|VILL|VLGS|VIST|VSTA|WALK|WALL|WAYS|WELL|ALY|ANX|ARC|AVE|AVN|BCH|BND|BLF|BOT|BTM|BRG|BRK|BYP|CMP|CPE|CEN|CTR|CIR|CLF|CLB|COR|CTS|CRK|DAM|DIV|DVD|DRV|EST|EXP|EXT|FLS|FRY|FLD|FLT|FRD|FRG|FRK|FRT|FWY|GLN|GRN|GRV|HBR|HVN|HTS|HWY|HLS|ISS|JCT|KEY|KYS|KNL|LKS|LGT|LCK|LDG|MNR|MDW|MNT|MTN|NCK|OVL|PRK|PKY|PLN|PLZ|PTS|PRT|PRR|RAD|RPD|RST|RDG|RIV|RVR|RDS|ROW|RUE|RUN|SHL|SHR|SPG|SQR|SQU|STA|STN|STR|SMT|TER|TRK|TRL|VLY|VIA|VWS|VLG|VIS|VST|WAY|WLS|AV|BR|CP|CT|CV|DL|DM|DV|DR|FT|HT|HL|IS|KY|LK|LN|LF|MT|PL|PT|PR|RD|SQ|ST|UN|VW|VL|WY))( (N(orth)?|S(outh)?)? ?(E(ast)?|W(est)?)?)?)$",
        "title": "Test"
    },
    {
        "description": "Matches the CEP (address code in Brazil) formatted or not.",
        "matches": [
            "12345-678",
            "12345678"
        ],
        "nonMatches": [
            "12345-67",
            "1234567",
            "123456789"
        ],
        "pattern": "^(\\d{5}\\-\\d{3})|(\\d{8})$",
        "title": "Test"
    },
    {
        "description": "Regular expression to validate a mobile phonenumber inside The Netherlands.",
        "matches": [
            "0612345678, 06-12345678"
        ],
        "nonMatches": [
            "05-12345678, 06-123456789"
        ],
        "pattern": "^0[6]{1}(\\-)?[^0\\D]{1}\\d{7}$",
        "title": "Test"
    },
    {
        "description": "Validate an International Bank Account Number (IBAN) without formatting. The first two characters represent the country code, coded according ISO 3166-1. ISO 3166-1",
        "matches": [
            "NL91ABNA0417164300"
        ],
        "nonMatches": [
            "91ABNA0417164300, NL91 ABNA 0417164300"
        ],
        "pattern": "^NL\\d{2}[A-Z]{4}0\\d{9}$",
        "title": "Test"
    },
    {
        "description": "Creating a Hotmail account is easy and simple, but once error appears while creating or doing other stuff with Hotmail, it\u0027s very hard to get rid of. Dialing Hotmail customer service number is always wise and helpful in order to resolve undesirable Hotmail issues. It provides an immediate solution and rectifies all your issues within a minute. The Hotmail support phone number can be reached by calling +1-800-611-2573 or visiting http://customercarenumber.us/hotmail-customer-care-usa.html",
        "matches": [
            "Hotmail",
            "Customer",
            "Care"
        ],
        "nonMatches": [
            "Yahoo",
            "Customer",
            "Care"
        ],
        "pattern": "Are you looking for Tech Help?",
        "title": "Test"
    },
    {
        "description": "Christophe is pipo de clown",
        "matches": [
            "pipo de clown"
        ],
        "nonMatches": [
            "pipo de clown"
        ],
        "pattern": "pipo de clown",
        "title": "Test"
    },
    {
        "description": "Matches all types of time declaration with \u0027:\u0027 separator.",
        "matches": [
            "0:26:12 aM",
            "00:26:12 Pm",
            "0:26:12aM",
            "00:26:12Pm",
            "Am 0:26:12",
            "pM 00:26:12",
            "Am0:26:12",
            "pM00:26:12",
            "0:26 PM",
            "01:26 am",
            "0:26PM",
            "01:26am",
            "Am 0:26",
            "pM 00:26",
            "Am0:26",
            "pM00:26",
            "23:26:12",
            "00:26:12",
            "0:26:12",
            "23:26",
            "0:26"
        ],
        "nonMatches": [
            "n/a"
        ],
        "pattern": "((a|p|A|P)(m|M)\\s{0,1}(0[0-9]|1[0-2]|[0-9]):[0-5][0-9]:[0-5][0-9])|((a|p|A|P)(m|M)\\s{0,1}(0[0-9]|1[0-2]|[0-9]):[0-5][0-9])|((0[0-9]|1[0-2]|[0-9]):[0-5][0-9]\\s{0,1}(a|p|A|P)(m|M))|((0[0-9]|1[0-2]|[0-9]):[0-5][0-9]:[0-5][0-9]\\s{0,1}(a|p|A|P)(m|M))|((0[0-9]|1[0-9]|2[0-3]|[0-9]):[0-5][0-9]:[0-5][0-9])|((0[0-9]|1[0-9]|2[0-3]|[0-9]):[0-5][0-9])",
        "title": "Test"
    },
    {
        "description": "This match an whole number",
        "matches": [
            "0",
            "100",
            "-100"
        ],
        "nonMatches": [
            "000",
            "-0",
            "+10",
            "a1",
            "1a"
        ],
        "pattern": "^[0]$|^-?[1-9]\\d*$",
        "title": "Test"
    },
    {
        "description": "Validate hh:minmin:ss",
        "matches": [
            "09:03:05",
            "08 : 03 : 57",
            "24:00: 05",
            "00: 00 :00",
            "17:54"
        ],
        "nonMatches": [
            "17:2",
            "3:52"
        ],
        "pattern": "(0\\d|1\\d|2[0-4]) ?: ?([0-5]\\d)( ?: ?[0-5]\\d)?",
        "title": "Test"
    },
    {
        "description": "Regular Expression for validate italian CAP (poste code).",
        "matches": [
            "23887, 23001, 20066"
        ],
        "nonMatches": [
            "1234, 1996,"
        ],
        "pattern": "^(V-|I-)?[0-9]{5}$",
        "title": "Test"
    },
    {
        "description": "Pattern for ISBN 13",
        "matches": [
            "978-1-86197-876-9",
            "978 1 86197 876 9"
        ],
        "nonMatches": [
            "no isbn number"
        ],
        "pattern": "[0-9]*[-| ][0-9]*[-| ][0-9]*[-| ][0-9]*[-| ][0-9]*",
        "title": "Test"
    },
    {
        "description": "Description This is for the Finnish social security numbers (henkil\u00F6tunnus / hetu). It consists of eleven characters of the form DDMMYYCZZZQ, where DDMMYY is the date of birth, C the century sign (-,+, or A), ZZZ the individual number (even for men and odd for female), and Q the control character or the checksum. It is calculated DDMMYYZZZ mod 31, where the remainder 0,1,2,..,31 is converted from the list 0,1,...A,B,C..Y . The G,I, O and Q are not in the list, they are too similar to numbers 1, 8 and 0 (zero). Note: This regex does not calculate the checksum (mod 31).",
        "matches": [
            "010593-123A",
            "010503A123A",
            "210566-022Y"
        ],
        "nonMatches": [
            "010593123A",
            "011403A123A",
            "011203-123O"
        ],
        "pattern": "^(0[1-9]|[12]\\d|3[01])(0[1-9]|1[0-2])([5-9]\\d\\+|\\d\\d-|[01]\\dA)\\d{3}[\\dABCDEFHJKLMNPRSTUVWXY]$",
        "title": "Test"
    },
    {
        "description": "Simple regular expression for Macedonian cell phone numbers.",
        "matches": [
            "+389 078 443 246 +389 078-443-246 +389 078/443/246 +389(0)78443246 0038978123456 +389078499039 +38978499039 +389 078.443.246"
        ],
        "nonMatches": [
            "02 4432 246"
        ],
        "pattern": "^((00)?\\+?[389]{3})?[\\/\\-\\s*\\.]?(((\\(0\\))|0)?\\s*7\\d{1})[\\/\\-\\s*\\.\\,]?([\\d]{3})[\\/\\-\\s*\\.\\,]?([\\d]{3})$",
        "title": "Test"
    },
    {
        "description": "Verify all Pakistan mobile numbers.",
        "matches": [
            "+923343751446, 00923343751446, 03343751446"
        ],
        "nonMatches": [
            "3343751446, 33437514467, 2343751446"
        ],
        "pattern": "^(?:(([+]|00)92)|0)((3[0-6][0-9]))(\\d{7})$",
        "title": "Test"
    },
    {
        "description": "Date in MM/DD/YYYY (USA Format). Allows for 1 or 2 digit month and day. Requires 4 digit year between 1900-2999. Allows for dash, slash, period or space for separators.",
        "matches": [
            "01/02/2015",
            "5-7-1915",
            "12.8.2035",
            "7 15 1963"
        ],
        "nonMatches": [
            "11-11-1845",
            "31/12/2000",
            "10-17-85"
        ],
        "pattern": "^(0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])[- /.](19|20)\\d\\d$",
        "title": "Test"
    },
    {
        "description": "Password validator for a high complexity secure passwords. Length minimum 16 characters At least one number At least one lowercase character At least one uppercase character At least one special character from the following set \u201C(!@#$%^\u0026*()_+|~\\- =\\\u0060{}[\\]:\u201D;\u0027\u003C\u003E?,.\\/, )]\u201D No sequential repeating characters",
        "matches": [
            "Pas$words0123456"
        ],
        "nonMatches": [
            "Password"
        ],
        "pattern": "^(?=.{16,})(?=.*[1-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[(!@#$%^\u0026*()_+|~\\- =\\\u0060{}[\\]:\u201D;\u0027\u003C\u003E?,.\\/, )])(?!.*(.)\\1{2,}).+$",
        "title": "Test"
    },
    {
        "description": "Check License Plate of Iranian Cars",
        "matches": [
            "41 \u062C 143"
        ],
        "nonMatches": [
            "41 \u062C 1433"
        ],
        "pattern": "^([10-99]{2})+\\s?([\\u0600-\\u06FF]\\s{1})+\\s?([100-999]{3})$",
        "title": "Test"
    },
    {
        "description": "Matches a string against valid Canadian postal codes",
        "matches": [
            "T2Z 4Z7",
            "L8V 2J5"
        ],
        "nonMatches": [
            "A2D 1FZ",
            "D1E 8F0"
        ],
        "pattern": "^(?![DFIOQUWZ])[A-Z]{1}[0-9]{1}(?![DFIOQU])[A-Z]{1}[ ]{1}[0-9]{1}(?![DFIOQU])[A-Z]{1}[0-9]{1}$",
        "title": "Test"
    },
    {
        "description": "If you are confronting any kind of Quicken hiccups, then don\u2019t wag off just feel free and avail Quicken contact number in a very short time. We always treat the customers like a friend so be your own boss and choose your own hours. Just dial 1-888-315-8364 without any confusion and get hand to hand solution in an ease way.",
        "matches": [
            "Quicken Customer Service"
        ],
        "nonMatches": [
            "confusion"
        ],
        "pattern": "Quicken Contact Number,Quicken Customer Service",
        "title": "Test"
    },
    {
        "description": "To overcome technical problems concerning your Facebook account, you need expert help by your side. Just ring our Facebook contact help phone Number to get the expert help you are willing to get. Our techies have years of experience and they are smart enough to help you against any pesky issue concerning Facebook . Our contact number 1888-758-7985 is toll-free",
        "matches": [
            "http://www.facebook-support-number.com/"
        ],
        "nonMatches": [
            "http://www.facebook-support-number.com/"
        ],
        "pattern": "http://www.facebook-support-number.com/",
        "title": "Test"
    },
    {
        "description": "Full Kenyan Mobile Phone Numbers starting with +254 or 254",
        "matches": [
            "+25471234568,254733333333"
        ],
        "nonMatches": [
            "0722222222, 0733333333"
        ],
        "pattern": "^(?:\\+254|254)(\\d{9})$",
        "title": "Test"
    },
    {
        "description": "Jiangsu Great Industrials Group Corp, Ltd is the leading manufactures group specializing in the manufacturing and exporting high quality auto spare parts to serve the customers worldwide since last 25 years. We produce over 1800 models covering 85 % of the commercial and passenger vehicles in the market including European, America, Middle East, Asia and African. Products detail: 1) Clutch system (clutch kit, clutch cover, clutch plate, release bearing, clutch facing, clutch button). 2) Brake system (brake pads, brake shoes, brake linings, brake lining rolls). 3) Metal products (clutch diaphragm spring, steel plate/steel strip) Our group is located in the eastern China, the most developed area of China, Jiangsu province, we welcome all our friends, new or old, come to visit us, and promote both the friendship and business through mutual endeavor; http://www.chinagrtech.com",
        "matches": [
            "1"
        ],
        "nonMatches": [
            "1"
        ],
        "pattern": "Jiangsu Great Industrials Group Corp, Ltd is the leading manufactures group specializing in the manufacturing and exporting high quality auto spare parts to serve the customers worldwide since last 25 years. We produce over 1800 models covering 85 % of the commercial and passenger vehicles in the market including European, America, Middle East, Asia and African. Products detail: 1) Clutch system (clutch kit, clutch cover, clutch plate, release bearing, clutch facing, clutch button). 2) Brake system (brake pads, brake shoes, brake linings, brake lining rolls). 3) Metal products (clutch diaphragm spring, steel plate/steel strip) Our group is located in the eastern China, the most developed area of China, Jiangsu province, we welcome all our friends, new or old, come to visit us, and promote both the friendship and business through mutual endeavor; http://www.chinagrtech.com",
        "title": "Test"
    },
    {
        "description": "Escort in Whitefield is one of the greatest urban regions in Bengalore. It is in like manner a main present day locale. This place is especially related and included by Whitefield escort in bangalore to its upper east.Escorts in Whitefield is outstanding for conveying henna. It is where you can have some good times. Whitefield Escorts Service offers you a choice advantage giving you the delightful and immaculate young women. Despite what kind of Call Girls you would need to hang out when you will go for Whitefield escorts advantage you can contribute your vitality with the most bewildering call young ladies.Pls visit us:http//www.bestescortinbangalore.com/escorts-in-whitefield/ and call us 9899936735",
        "matches": [
            "Escort Service In Whitefield, Escort Services in Whitefield, Call Girl in Whitefield, Escort in Whitefield, Whitefield Escorts, Call Girls in Whitefield, Independent Escort in Whitefield,Escorts in Whitefield,Escorts in Whitefield Bangalore"
        ],
        "nonMatches": [
            "Escort Service In Whitefield, Escort Services in Whitefield, Call Girl in Whitefield, Escort in Whitefield, Whitefield Escorts, Call Girls in Whitefield, Independent Escort in Whitefield,Escorts in Whitefield,Escorts in Whitefield Bangalore"
        ],
        "pattern": "Escorts in Whitefield Bangalore",
        "title": "Test"
    },
    {
        "description": "Matches the format from www.cpr.dk and fixed to match 29th February for leap years",
        "matches": [
            "020955-2012 .020955-2012 241283-1234",
            "290204-1234 010111-1111"
        ],
        "nonMatches": [
            "459434-1234 123456-1234"
        ],
        "pattern": "((((0[1-9]|[12][0-9]|3[01])(0[13578]|10|12)(\\d{2}))|(([0][1-9]|[12][0-9]|30)(0[469]|11)(\\d{2}))|((0[1-9]|1[0-9]|2[0-8])(02)(\\d{2}))|((29)(02)(0(0|4|8)))|((29)(02)([2468][048]))|((29)(02)([13579][26])))[- ]?\\d{4})",
        "title": "Test"
    },
    {
        "description": "Validate Phone number like USA/North American Phone style country code allow max 3 digit (required 0 or + as prefix) suffix space or dash is optional",
        "matches": [
            "1234567890",
            "+11234567890",
            "+1 1234567890",
            "123 456 7890",
            "123-456-7890",
            "123.456.7890",
            "(123)4567890",
            "(123) 456 7890",
            "(123)-456-7890",
            "(123).456.7890",
            "+1123 456 7890",
            "+1123-456-7890",
            "+1123.456.7890",
            "+1 123 456 7890",
            "+1 123-456-7890",
            "+1 123.456.7890",
            "+1(123)4567890",
            "+1(123) 456 7890",
            "+1(123)-456-7890",
            "+1(123).456.7890",
            "+1 (123)4567890",
            "+1 (123) 456 7890",
            "+1 (123)-456-7890",
            "+1 (123).456.7890",
            "01123 456 7890",
            "01123-456-7890",
            "01123.456.7890",
            "01 123 456 7890",
            "01 123-456-7890",
            "01 123.456.7890",
            "01(123)4567890",
            "01(123) 456 7890",
            "01(123)-456-7890",
            "01(123).456.7890",
            "01 (123)4"
        ],
        "nonMatches": [
            "+ (123).456.7890",
            "+1234 123 456 7890",
            "0 (123).456.7890",
            "01234 123 456 7890",
            "123 123 456 7890",
            "123 4567890",
            "123456 7890",
            "(123 4567890",
            "(1234567890",
            "123-456 7890",
            "123.456 7890",
            "123 4567890",
            "+1 123 4567890",
            "+1 123456 7890",
            "+1 (123 4567890",
            "+1 (1234567890",
            "+1 123-456 7890",
            "+1 123.456 7890",
            "+1 123 4567890",
            "+1123 4567890",
            "+1123456 7890",
            "+1(123 4567890",
            "+1(1234567890",
            "+1123-456 7890",
            "+1123.456 7890",
            "+1123 4567890"
        ],
        "pattern": "^([+0]\\d{1,3}[\\ \\-]?)?(\\()?([0-9]{3})(?(2)\\)|(\\))?)([\\-\\.\\ ])?([0-9]{3})(?(5)\\5|\\5?)([0-9]{4})$",
        "title": "Test"
    },
    {
        "description": "Regex for current available mobile numbers mention at https://fa.wikipedia.org/wiki/%D8%B4%D9%85%D8%A7%D8%B1%D9%87%E2%80%8C%D9%87%D8%A7%DB%8C_%D8%AA%D9%84%D9%81%D9%86_%D8%AF%D8%B1_%D8%A7%DB%8C%D8%B1%D8%A7%D9%86",
        "matches": [
            "09221113344"
        ],
        "nonMatches": [
            "09057614584"
        ],
        "pattern": "(\\+989|9|09)(0[1-3]|1[0-9]|2[0-2]|3[0-9]|90|9[8-9])\\d{7}",
        "title": "Test"
    },
    {
        "description": "Validate lat/lon coordinates",
        "matches": [
            "45\u00B023\u002736.0\u0022 N 10\u00B033\u002748.0\u0022 E or 45\u00B023\u002736.123456\u0022N 010\u00B033\u002748\u0022E"
        ],
        "nonMatches": [
            "45\u00B023\u002736.\u0022 N 10\u00B033\u002748.0\u0022 E or 45\u00B023\u002736.1234567\u0022N 010\u00B033\u002748\u0022E"
        ],
        "pattern": "([0-8]?\\d(\u00B0|\\s)[0-5]?\\d(\u0027|\\s)[0-5]?\\d(\\.\\d{1,6})?\u0022?|90(\u00B0|\\s)0?0(\u0027|\\s)0?0\u0022?)\\s{0,}[NnSs]\\s{1,}([0-1]?[0-7]?\\d(\u00B0|\\s)[0-5]?\\d(\u0027|\\s)[0-5]?\\d(\\.\\d{1,6})?\u0022?|180(\u00B0|\\s)0?0(\u0027|\\s)0?0\u0022?)\\s{0,}[EeOoWw]",
        "title": "Test"
    },
    {
        "description": "Matches valid South African ID numbers based on all criteria (except of course the checksum digit at the end). Matches the format defined as: YYMMDDSSSSCAZ. YY - Year, MM - Month, DD - Day, SSSS - Gender, C - Denotes citizenship (0 or a 1), A - Always an 8, Z - Checksum digit (doesn\u0027t validate if the checksum itself is valid). Also supports the following ways of entering it: YYMMDDSSSSCAZ | YYMMDD SSSS CAZ | YYMMDD SSSS CA Z . See this for a reference: https://www.westerncape.gov.za/general-publication/decoding-your-south-african-id-number-0",
        "matches": [
            "9202204720082",
            "920220 4720 082",
            "920220 4720 08 2",
            "920220-4720-082",
            "920220-4720-08-2 9202204720183",
            "920220 4720 183",
            "920220 4720 18 3",
            "920220-4720-183",
            "920220-4720-18-3"
        ],
        "nonMatches": [
            "9202204720282",
            "920220 4720 052",
            "920220 4720 05 2",
            "920220-4720-252"
        ],
        "pattern": "(((\\d{2}((0[13578]|1[02])(0[1-9]|[12]\\d|3[01])|(0[13456789]|1[012])(0[1-9]|[12]\\d|30)|02(0[1-9]|1\\d|2[0-8])))|([02468][048]|[13579][26])0229))(( |-)(\\d{4})( |-)([01]8((( |-)\\d{1})|\\d{1}))|(\\d{4}[01]8\\d{1}))",
        "title": "Test"
    },
    {
        "description": "The Quickensupportnumber247.com is the right destination for Quicken customer technical support chat number. This is an effective strategy \u0026 Business Support Call on 1-800-277-6571.",
        "matches": [
            "Quicken customer technical support chat number"
        ],
        "nonMatches": [
            "An effective Quicken customer"
        ],
        "pattern": "How do find the phone number for Quicken support?",
        "title": "Test"
    },
    {
        "description": "Get Quicken online client technical support visit by dialing our support toll-free telephone number +1-800-277-6571 by Quicken Inc",
        "matches": [
            "Quicken online customer tech support"
        ],
        "nonMatches": [
            "Technical support"
        ],
        "pattern": "Suitable Quicken online chat support",
        "title": "Test"
    },
    {
        "description": "There is a truly reliable Outlook Customer Service Number where you can call any time when you are having problems with your Outlook email account. The Outlook Support Number +1 (844)-444-4174 is a dedicated 24/7 toll-free Microsoft Outlook help desk in the USA to help you get the exact solution.",
        "matches": [
            "outlook"
        ],
        "nonMatches": [
            "outlook"
        ],
        "pattern": "outlook",
        "title": "Test"
    },
    {
        "description": "12 to 40 characters. At least one lowercase, one uppercase, 1 digit and 1 special character.",
        "matches": [
            "d32sdlkfj\u0027qsmdkfjsqmsdflkD",
            "UFfo45\u0022!VD\u0022zkosphnnlmi",
            "Qwerty123!!!"
        ],
        "nonMatches": [
            "Qwerty123!!!\u00E0\u00E0\u00E0",
            "QwertyQwertyQwerty",
            "123456"
        ],
        "pattern": "^(?=.*[\\d])(?=.*[A-Z])(?=.*[a-z])(?=.*[!\u0022#$%\u0026\\\u0027()*+,-.\\/:;\u003C=\u003E?@[\\]^_\u0060{|}~])[\\w\\d!\u0022#$%\u0026\\\u0027()*+,-.\\/:;\u003C=\u003E?@[\\]^_\u0060{|}~]{12,40}$",
        "title": "Test"
    },
    {
        "description": "Password must be at least 6 characters, no more than 20 characters, and must include at least one upper case letter, one lower case letter, and one numeric digit or one special character",
        "matches": [
            "Infy123",
            "India@21",
            "France@)!*"
        ],
        "nonMatches": [
            "Fin 1245g",
            "12323444",
            "\u0026^#\u0026@^#*@"
        ],
        "pattern": "^(?=.*[a-z])(?=.*[A-Z])((?=.*\\d)|(?=.*[!@#$%^\u0026*()\u0027\u0022]))[A-Za-z\\d!@#$%^\u0026*()\u0027\u0022](?!\\s).{5,21}$",
        "title": "Test"
    },
    {
        "description": "Simple email validation",
        "matches": [
            "q@w.com",
            "q1.w@w.com",
            "q1.w@w.r.co"
        ],
        "nonMatches": [
            "1@w.com",
            "w@1.com",
            "q1.w@w.r.c"
        ],
        "pattern": "^(\\D)+(\\w)*((\\.(\\w)+)?)+@(\\D)+(\\w)*((\\.(\\D)+(\\w)*)+)?(\\.)[a-z]{2,}$",
        "title": "Test"
    },
    {
        "description": "Regex for russian phone numbers.",
        "matches": [
            "+7-(916)-233-97-97",
            "+79152319694",
            "8-917-2329675"
        ],
        "nonMatches": [
            "+44-928-634-23-23",
            "891723445678",
            "8005553535"
        ],
        "pattern": "^(\\+?7{1}|8{1})[ -]?\\(?[0-9]{0,3}\\)?[ -]?[0-9]{3}[ -]?[0-9]{2}[ -]?[0-9]{2}$",
        "title": "Test"
    },
    {
        "description": "Includes all 50 states, some territories, plus two-letter abbreviations. Specifically excludes \u0022Baja California\u0022 due to the data set that originally drove me to this expression.",
        "matches": [
            "California, NY, VI"
        ],
        "nonMatches": [
            "Baja California, MP, York"
        ],
        "pattern": "^(?:Ala(?:(?:bam|sk)a)|American Samoa|Arizona|Arkansas|(?:^(?!Baja )California)|Colorado|Connecticut|Delaware|District of Columbia|Florida|Georgia|Guam|Hawaii|Idaho|Illinois|Indiana|Iowa|Kansas|Kentucky|Louisiana|Maine|Maryland|Massachusetts|Michigan|Minnesota|Miss(?:(?:issipp|our)i)|Montana|Nebraska|Nevada|New (?:Hampshire|Jersey|Mexico|York)|North (?:(?:Carolin|Dakot)a)|Ohio|Oklahoma|Oregon|Pennsylvania|Puerto Rico|Rhode Island|South (?:(?:Carolin|Dakot)a)|Tennessee|Texas|Utah|Vermont|Virgin(?:ia| Island(s?))|Washington|West Virginia|Wisconsin|Wyoming|A[KLRSZ]|C[AOT]|D[CE]|FL|G[AU]|HI|I[ADLN]|K[SY]|LA|M[ADEINOST]|N[CDEHJMVY]|O[HKR]|P[AR]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY])$",
        "title": "Test"
    },
    {
        "description": "Using this regex you can check any type of persian date",
        "matches": [
            "1376/12/12",
            "1376/2/2",
            "1376/02/2",
            "1376/2/02",
            "1376/02/02"
        ],
        "nonMatches": [
            "1376-12-12",
            "136/12/12"
        ],
        "pattern": "^[1-4]\\d{3}\\/((0[1-6]\\/((3[0-1])|([1-2][0-9])|(0[1-9])))|([1-6]\\/((3[0-1])|([1-2][0-9])|(0[1-9])))|((1[0-2]|(0[7-9])|([1-9])|(0[1-9]))\\/(30|([1-2][0-9])|(0[1-9])|([1-9]))))$",
        "title": "Test"
    },
    {
        "description": "This regular expression is used for validating password with the following criteria. a. Should start and end with an alphanumeric character. b. Atleast 1 uppercase letter. c. Atleast 1 lower case letter. d. Atleast 1 Number. e. Atleast 1 special character from the list(!@#$%^\u0026*_\u003C\u003E?|). f. Minimum 8 characters length.",
        "matches": [
            "Example@19, eXample@19, 19eXample@2K"
        ],
        "nonMatches": [
            "@19eXample2K, 19eXample2K#, 19example@2K, example@K"
        ],
        "pattern": "/^(?=.*\\d)(?=.*[!@#$%^\u0026*_\u003C\u003E?|])(?=.*[a-z])(?=.*[A-Z])[A-Za-z\\d][A-Za-z\\d!@#$%^\u0026*_\u003C\u003E?|]{6,}[A-Za-z\\d]$/",
        "title": "Test"
    },
    {
        "description": "Checks for phone numbers if they begin with either + or 00(countrycode), or with 0. As well there can be no 0 after the countrycode. Only works for 2-digit country codes.",
        "matches": [
            "0041 41 440 84 40",
            "0041414408440",
            "+41 41 440 84 40",
            "+41414408440",
            "041 440 84 40",
            "0414408440"
        ],
        "nonMatches": [
            "+41 41 440 84 40",
            "0041-041-440-84-40",
            "040213123123"
        ],
        "pattern": "(((^\\+|^0{2})[1-9]{2})|(^0[1-9]{2})) ?[1-9]{1}[\\d ]*$",
        "title": "Test"
    },
    {
        "description": "^ :Means Start from ((\\+91)?|91) :Means +91 or 91 ? :Means OR [789][0-9]{9} :Means Mobile Number starting from 7,8 or 9.",
        "matches": [
            "917000000000,918000000000,919000000000, +917000000000, 9800000000, 8200000000"
        ],
        "nonMatches": [
            "916000000000, +027000000000, 909000000000"
        ],
        "pattern": "^((\\+91)?|91)?[789][0-9]{9}",
        "title": "Test"
    },
    {
        "description": "checks if input is a valid Australian number",
        "matches": [
            "0403240016",
            "1300546812",
            "+61403240016"
        ],
        "nonMatches": [
            "403240016",
            "4032400165",
            "04032400161"
        ],
        "pattern": "^(((([\\+]61[1-9]{0,1}|([\\(]{0,1}0[\\)]{0,1}[1-9]{1}|[\\(]{0,1}0[1-9]{1}[\\)]{0,1})))([0-9]{8}|([\\\\s*]|[\\-]{1})[0-9]{3}([\\\\s*]|[\\-]{1})[0-9]{3}([\\\\s*]|[\\-]{1})[0-9]{3}|(([\\\\s*]|[\\-]{0,1})[0-9]{4}([\\\\s*]|[\\-]{0,1})[0-9]{4})))|((1([\\\\s*]|[\\-]{0,1})((300|800|900|902)|3[0-9]{2}))([\\\\s*]|[\\-]{0,1})([0-9]{3}([\\\\s*]|[\\-]{0,1})[0-9]{3}|[0-9]{6}))|((13[0-9]{1}([\\\\s*]|[\\-]){0,1}[0-9]{3}|13([\\\\s*]|[\\-]){1}[0-9]{2}([\\\\s*]|[\\-]){1}[0-9]{2})))$",
        "title": "Test"
    },
    {
        "description": "Techno Vizions is an online computer technical support service provider if the user does not have their solution on available web pages then mail on given mail id. We provide a solution regarding your issues. If you want an instant solution, to contact us on given toll-free number, our technicians provide you best solution within a minute. Our services available at 24*7.",
        "matches": [
            "Technical support"
        ],
        "nonMatches": [
            "spam"
        ],
        "pattern": "Norton antivirus product offers a good solution for users to remove viruses and threats. It gives more benefits to all users of the Norton products. It is available in some online portal to download and install the software with a simple process.",
        "title": "Test"
    },
    {
        "description": "Can start with or include any of the following special characters: ~ ! @ # $ % ^ \u0026 * _ - + = \u0060 | \\ ( ) { } [ ] : ; \u0022\u0027\u003C\u003E , . ? / \u00A3",
        "matches": [
            "#Sudoroot SecAptget"
        ],
        "nonMatches": [
            "345708"
        ],
        "pattern": "~ ! @ # $ % ^ \u0026 * _ - + = \u0060 | \\ ( ) { } [ ] : ; \u0022\u0027\u003C\u003E , . ? / \u00A3",
        "title": "Test"
    },
    {
        "description": "This regex is for validating the Egypt\u0027s mobile numbers for the major operators Etisalat, Vodafone, Orange and WE",
        "matches": [
            "01022101381",
            "201022101381",
            "+201022101381",
            "01122101381",
            "01222101381",
            "01522101381"
        ],
        "nonMatches": [
            "00022101381",
            "201322101381",
            "+201422101381",
            "01122101381",
            "01622101381"
        ],
        "pattern": "^(\\+(?=2))?2?01(?![3-4])[0-5]{1}[0-9]{8}$",
        "title": "Test"
    },
    {
        "description": "Matches the ISODate string format from nodejs",
        "matches": [
            "2100-01-01T02:00:00.000Z",
            "2100-01-01T02:00:00",
            "2100-01-01T02:00:00.000-0300",
            "2006-12-31 17:58:00",
            "20061231175800",
            "2006-12-31"
        ],
        "nonMatches": [
            "2006-13-36 25:61:62"
        ],
        "pattern": "^(\\d{4})\\D?(0[1-9]|1[0-2])\\D?([12]\\d|0[1-9]|3[01])(\\D?([01]\\d|2[0-3])\\D?([0-5]\\d)\\D?([0-5]\\d)?)?(\\D\\d{3}(\\D(\\d{4})?)?)?$",
        "title": "Test"
    },
    {
        "description": "Matches troy credit cards (length 16, prefix 9792)",
        "matches": [
            "9792131111111111",
            "9792461111111111",
            "9792111111111111"
        ],
        "nonMatches": [
            "9792 1311 1111 1111",
            "1234561234561234"
        ],
        "pattern": "^9792\\d{12}$",
        "title": "Test"
    },
    {
        "description": "This RegEx works for percentage",
        "matches": [
            "100\u0026 , 89.23"
        ],
        "nonMatches": [
            "101.20 , 99.231"
        ],
        "pattern": "^100$|[0-9]{2}\\\\.[0-9]{2}",
        "title": "Test"
    },
    {
        "description": "Get support for Webroot antivirus by calling at webroot support phone number +1-800-656-0360 and get instant solution to your issues.",
        "matches": [
            "https://www.onlinehelp247.com/webroot-antivirus-support-phone-number/"
        ],
        "nonMatches": [
            "https://www.onlinehelp247.com/webroot-antivirus-support-phone-number/"
        ],
        "pattern": "Webroot Antivirus Issues",
        "title": "Test"
    },
    {
        "description": "A@A.A with A is any lowercase English letter or Arabic digit or both together.",
        "matches": [
            "abc@xooxle.com",
            "tiger01@xooxleschool07.edu",
            "1@0xooxle0.70 ."
        ],
        "nonMatches": [
            "@xooxle.com",
            "helloworld",
            "x@abc ."
        ],
        "pattern": "^([a-z0-9]+)@([a-z0-9]+)\\\\.([a-zA-Z0-9]+)",
        "title": "Test"
    },
    {
        "description": "This regex has validate the Iranian IBAN (Sheba)",
        "matches": [
            "IR123000000987654321012345",
            "ir123000000987654321012345",
            "Ir123000000987654321012345"
        ],
        "nonMatches": [
            "123000000987654321012345",
            "Ir12300000098765432101",
            "IR 123000000987654321012345"
        ],
        "pattern": "^(?i:IR)(?=.{24}$)[0-9]*$",
        "title": "Test"
    },
    {
        "description": "https://led-edit-effects.com DOWNLOAD LED EDIT AND EFFECT IN SWF",
        "matches": [
            "led edit"
        ],
        "nonMatches": [
            "lededit"
        ],
        "pattern": "A-Z]{6,6}[A-Z2-9][A-NP-Z0-9]([A-Z0-9]{3,3}){0,1}",
        "title": "Test"
    },
    {
        "description": "https://led-edit-effects.com",
        "matches": [
            "https://led-edit-effects.com"
        ],
        "nonMatches": [
            "https://led-edit-effects.com"
        ],
        "pattern": "https://led-edit-effects.com",
        "title": "Test"
    },
    {
        "description": "Hello, my name is Zara Aria live in Australia. I did graduation from Australia University in computer science and working with Outlook Customer Support Company; if any issue with your email account calls Outlook Support Phone number.",
        "matches": [
            "utlook account recovery australia"
        ],
        "nonMatches": [
            "https://outlook.supportnumberaustralia.com.au/"
        ],
        "pattern": "utlook account recovery australia",
        "title": "Test"
    },
    {
        "description": "- first 2 digits are 01 - second 1 digit is 0 for (Vodafone) or 1 for (Etisalat) or 2 for (orange) or 5 for (We) - third 8 digits are between 0 and 9",
        "matches": [
            "01022685544 - 01122685544 - 01222685544 - 01522685544"
        ],
        "nonMatches": [
            "+0201622685544 - 01322685544 - 01422685544 - 01622685544 - 01722685544 - 01822685544 - 01922685544"
        ],
        "pattern": "^01[0125]{1}[0-9]{8}",
        "title": "Test"
    },
    {
        "description": "This is the same Address Parser as the one by NoBug but I extended it to allow you to add apt and apt# at the end. The original can be found in the source link.",
        "matches": [
            "101 W Main St",
            "101 W Main St. N",
            "101 W Main St N Apt 5"
        ],
        "nonMatches": [
            "Main St",
            "55a Main St",
            "123 Street"
        ],
        "pattern": "^(\\d{2,})\\s?(\\w{0,5})\\s([a-zA-Z]{2,30})\\s([a-zA-Z]{2,15})\\s?(\\w{0,5})\\s?([a-zA-Z]{0,15})\\.?\\s?(\\d{0,5})$",
        "title": "Test"
    },
    {
        "description": "This matches valid dates (including leap year dates of the following formats : dd/mm/yy dd/mm/yyyy d/m/yy d/m/yyyy dd-mm-yy dd-mm-yyyy d-m-yy d-m-yyyy dd.mm.yy dd.mm.yyyy d.m.yy d.m.yyyy use the named groups day, month, year",
        "matches": [
            "29/02/2096"
        ],
        "nonMatches": [
            "29/02/2097, 31/04/2020"
        ],
        "pattern": "(?:\\s|^)(?P\u003Cday\u003E(?P\u003Cthreeone\u003E31)|(?P\u003Cthirty\u003E30)|(?P\u003Ctwonine\u003E29)|(?P\u003Ctwoeight\u003E2[0-8]|1[0-9]|0?[1-9]))(?P\u003Csep\u003E[/\\-\\.:])(?P\u003Cmonth\u003E(?(threeone)(?:1[02]|0?[13578]))(?(thirty)(?:1[012]|0?[13456789]))(?(twonine)(?:1[012]|0?[13-9]|(?P\u003Cleap\u003E0?2)))(?(twoeight)(?:1[012]|0?[1-9])))(?P=sep)(?P\u003Cyear\u003E(?:\\d\\d)?(?(leap)(?:(?:[02468][048])|(?:[13579][26]))|(?:\\d\\d)))(?:$|\\s)",
        "title": "Test"
    },
    {
        "description": "Validates dates in the (d)d-MMM-(yy)yy format",
        "matches": [
            "29-feb-2020, 1-jan-01"
        ],
        "nonMatches": [
            "29-feb-19, 31-sep-2010"
        ],
        "pattern": "(?:\\s|^)(?P\u003Cday\u003E(?P\u003Cthreeone\u003E31)|(?P\u003Cthirty\u003E30)|(?P\u003Ctwonine\u003E29)|(?P\u003Ctwoeight\u003E2[0-8]|1[0-9]|0?[1-9]))(?P\u003Csep\u003E[/\\-\\.:])(?P\u003Cmonth\u003E(?(threeone)(?:jan|mar|may|jul|aug|oct|dec))(?(thirty)(?:jan|mar|apr|may|jun|jul|aug|sep|oct|nov|dec))(?(twonine)(?:jan|(?P\u003Cfeb\u003Efeb)|mar|apr|may|jun|jul|aug|sep|oct|nov|dec|))(?(twoeight)(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)))(?P=sep)(?P\u003Cyear\u003E(?:\\d\\d)?(?(twonine)(?(feb)(?:(?:[02468][048])|(?:[13579][26]))|(?:\\d\\d))|(?:\\d\\d)))(?:$|\\s)",
        "title": "Test"
    },
    {
        "description": "Does full ordinal british dates",
        "matches": [
            "2nd february 2020, 30th of january, 2020"
        ],
        "nonMatches": [
            "30th february 2020"
        ],
        "pattern": "(?:\\s|^)(?P\u003Cday\u003E(?P\u003Cthreeone\u003E31(?:st)?)|(?P\u003Cthirty\u003E30(?:th)?)|(?P\u003Ctwonine\u003E29(?:th)?)|(?P\u003Ctwoeight\u003E2(?:1(?:st)?|2(?:nd)?|3(?:rd)?)|2[04-8](?:th)?|1[0-9](?:th)?|0?1(?:st)?|0?2(?:nd)?|0?3(?:rd)?|0?[4-9](?:th))?)(?:(?P\u003Csep\u003E[/\\-\\.:])|\\s|\\sof\\s)(?P\u003Cmonth\u003E(?(threeone)(?:jan|mar|may|jul|aug|oct|dec|january|march|july|august|october|december))(?(thirty)(?:jan|mar|apr|may|jun|jul|aug|sep|oct|nov|dec|janurary|march|april|june|july|august|september|october|november|december))(?(twonine)(?:jan|(?P\u003Cfeb\u003Efeb|february)|mar|apr|may|jun|jul|aug|sep|oct|nov|dec|january|march|april|june|july|august|september|october|november|december))(?(twoeight)(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec|january|february|march|april|june|july|august|september|october|november|december)))(?(sep)(?P=sep)|,?\\s)(?P\u003Cyear\u003E(?:\\d\\d)?(?(twonine)(?(feb)(?:(?:[02468][048])|(?:[13579][26]))|(?:\\d\\d))|(?:\\d\\d)))(?:$|\\s)",
        "title": "Test"
    },
    {
        "description": "If you are searching for Engine Bay Cleaning, We Aaa Prestige Car Care is known as a Best Engine Bay Cleaning Brisbane Australia. Know More Details: https://www.aaaprestigecarcare.com.au/engine-bay-Cleaning-brisbane/",
        "matches": [
            "Engine Bay Cleaning Brisbane"
        ],
        "nonMatches": [
            "Engine Bay Cleaning Brisbane"
        ],
        "pattern": "Engine Bay Cleaning Brisbane",
        "title": "Test"
    },
    {
        "description": "We are known as a top Ceramic Coating Brisbane, Australia. Get the Best Ceramic Coating in Brisbane. https://www.aaaprestigecarcare.com.au/ceramic-coating-brisbane/",
        "matches": [
            "Ceramic Coating Brisbane"
        ],
        "nonMatches": [
            "Ceramic Coating Brisbane"
        ],
        "pattern": "Ceramic Coating Brisbane",
        "title": "Test"
    },
    {
        "description": "Now a Days Sanitizing is most important, AAA Prestige Car Care provid Best Car Sanitizing Services Brisbane. https://www.aaaprestigecarcare.com.au/car-sanitizing-services-brisbane/",
        "matches": [
            "Car Sanitizing Services Brisbane"
        ],
        "nonMatches": [
            "Car Sanitizing Services Brisbane"
        ],
        "pattern": "Car Sanitizing Services Brisbane",
        "title": "Test"
    },
    {
        "description": "We provide Car Quick Wash Brisbane, We don\u0027t waste your time... Aaa Prestige Car Care wash fast to your car. Know More: https://www.aaaprestigecarcare.com.au/car-wash-services-brisbane/",
        "matches": [
            "Car Quick Wash Brisbane"
        ],
        "nonMatches": [
            "Car Quick Wash Brisbane"
        ],
        "pattern": "Car Quick Wash Brisbane",
        "title": "Test"
    },
    {
        "description": "This expression validate the YYYYMMDDHHMMSS datetime format but also only the date YYYYMMDD. It does not control month length or leap years. Made for a SAP retail sales tickets interface. For XML pattern facet this would do: ([0-9]{4}(0[1-9]|1[0-2])(0[1-9]|[1-2][0-9]|3[0-1])(([01][0-9]|2[0-3])[0-5][0-9][0-5][0-9]))|([0-9]{4}(0[1-9]|1[0-2])(0[1-9]|[1-2][0-9]|3[0-1]))",
        "matches": [
            "20200707181818",
            "20200707",
            "20200231010000",
            "20200931",
            "00011231235959",
            "00000101"
        ],
        "nonMatches": [
            "20201232",
            "20201301",
            "20200028",
            "20200500",
            "20200707235978",
            "20201231128533",
            "20200327453030"
        ],
        "pattern": "^[0-9]{4}(0[1-9]|1[0-2])(0[1-9]|[1-2][0-9]|3[0-1])($|(([01][0-9]|2[0-3])[0-5][0-9][0-5][0-9])$)",
        "title": "Test"
    },
    {
        "description": "Match valid IPv4 address. Constraints: matches only IP. All numbers must be between 0-255 for each block, delimited by dots, and cannot be zero padded or be suffixed by a dot on the last class.",
        "matches": [
            "0.0.0.0",
            "192.168.1.35",
            "169.254.0.0"
        ],
        "nonMatches": [
            "127.0.0.01",
            "255.255.255.256",
            "7.7.7.7."
        ],
        "pattern": "^((25[0-5]|2[0-4]\\d|1\\d{2}|[1-9]?\\d)(\\.|$)){4}\\b",
        "title": "Test"
    },
    {
        "description": "Supports 7 digits (starting with 3,4,5,6,7,8,9) 8 digits (starting with 4,5,7,8), machine-to-machine (M2M) numbers 9-12 digits (starting with 8).",
        "matches": [
            "300 3000",
            "300-3000",
            "3003000"
        ],
        "nonMatches": [
            "3000 3000",
            "9000 9000 9000"
        ],
        "pattern": "(^[3|4|5|6|7|8|9]\\d{2}(\\ |-){0,1}\\d{4}$)|(^[4|5|7|8]\\d{3}(\\ |-){0,1}\\d{4}$)|(^8\\d{2,3}(\\ |-){0,1}\\d{3,4}(\\ |-){0,1}\\d{3,4}$)",
        "title": "Test"
    },
    {
        "description": "Matches the hissing noise of a snake. Link to my GitHub: https://github.com/StoddardSpencer96",
        "matches": [
            "ssssssssss wwwwwwwwwwwsssssssssssssssssss"
        ],
        "nonMatches": [
            "effsgrgrsfefsv54543534544 FKR$\u003E%\u003E??W?EK#$Krkdk3oror"
        ],
        "pattern": "([s]){10,}",
        "title": "Test"
    },
    {
        "description": "Looking for Social Media Lead Generation B2b Company for business growth? Then you are at the best place, We, Leads Nonstop are known for the Best Social Media Lead Generation company in all over UK, at a price that would not harm to your pockets. https://leadsnonstop.co.uk/social-media-web-leads/",
        "matches": [
            "Social Media Lead Generation B2b"
        ],
        "nonMatches": [
            "Social Media Web Leads"
        ],
        "pattern": "Leads Nonstop",
        "title": "Test"
    },
    {
        "description": "A simple regexp to filter out URLs embedded in large corpus. Figured this out while working on NLP tasks",
        "matches": [
            "http://abcnews.go.com/Video/playerIndex?id=2105341",
            "https://en.wikipedia.org/wiki/Talk:A%E2%88%B4A%E2%88%B4",
            "http://www.raspberrypi.org/forum/features-and-requests/lcd-lvds-interface-for-raspberry-pi"
        ],
        "nonMatches": [
            "(www.nndb.com)",
            "[www.asia.com]",
            ""
        ],
        "pattern": "\u0027https?:/{2}\\S+\u0027",
        "title": "Test"
    },
    {
        "description": "you can use this",
        "matches": [
            "41307-9666232-9"
        ],
        "nonMatches": [
            "41307-966623299"
        ],
        "pattern": "/[0-9]{5}(-)[0-9]{7}(-)[0-9]{1}/",
        "title": "Test"
    },
    {
        "description": "When it comes to making Home Additions West New Yorkg has been a staunch proponent in the field, however, it is important to note that while it is definitely one of the most lucrative investment fields anyone can enter, it is also quite confusing for many, and while the barriers to entry is essentially just the finances, one of the most important things to understand is that there is quite a bit an individual must be knowledgeable about before taking the leap \u2013 especially as they might be planning to invest their hard earned money into the project. For more information, visit https://www.realtyimprovement.com/home-additions-guttenberg/",
        "matches": [
            "Interior Designing",
            "Home Improvement",
            "Bathroom Remodeling"
        ],
        "nonMatches": [
            "Vinyl Siding",
            "Roofing"
        ],
        "pattern": "Home Additions West New York - Realty Improvement LLC",
        "title": "Test"
    },
    {
        "description": "UK NI number. ensured that the suffix is always a single character of A-D (as these are the only values currently supported by HMRC). Created 2021",
        "matches": [
            "XY123456D"
        ],
        "nonMatches": [
            "XY123456E"
        ],
        "pattern": "(?!BG|GB|KN|NK|NT|TN|ZZ)[A-CEGHJ-PR-TW-Z][A-CEGHJ-NPR-TW-Z][0-9]{6}[A-D]",
        "title": "Test"
    },
    {
        "description": "1. 3 generic Alphabets 2. 1 specific alphabet 3. 1 generic alphabet 4. 4 digits 5. 1 generic alphabet (alphabets: small or capital)",
        "matches": [
            "AABCL5045N"
        ],
        "nonMatches": [
            "AABXL5045N"
        ],
        "pattern": "([A-Za-z]{3})([pchabgjlftPCHABGJLFT])([a-zA-Z])([0-9]{4})([A-Za-z]{1})",
        "title": "Test"
    },
    {
        "description": "ENB= Escorts Nearby. We are providing best escorts for you and We promote escorts profiles in Australia. Visit our website and choose independent \u0026 private escorts in Australia. https://www.escortsnearby.com.au/",
        "matches": [
            "Escorts in Australia"
        ],
        "nonMatches": [
            "Escorts in Australia"
        ],
        "pattern": "Escorts in Australia",
        "title": "Test"
    }
]